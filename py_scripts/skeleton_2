class StrategyTestingFramework:
    def __init__(self, catalog_path: str, venue: Venue, instrument_id: InstrumentId):
        self.catalog_path = catalog_path
        self.venue = venue
        self.instrument_id = instrument_id
        self.catalog = ParquetDataCatalog(self.catalog_path)
        self._backtest_node = None
        self._live_node = None
    def _binance_instrument_provider_config(self, load_all: bool = True) -> InstrumentProviderConfig:
        return InstrumentProviderConfig(load_all=load_all, log_warnings=False)
    def _binance_data_client_config(
        self,
        api_key: str | None,
        api_secret: str | None,
        account_type: BinanceAccountType,
        testnet: bool = False,
        us: bool = False,
        base_url_http: str | None = None,
        base_url_ws: str | None = None,
        proxy_url: str | None = None,
        update_instruments_interval_mins: int | None = 60,
        use_agg_trade_ticks: bool = False,
    ) -> BinanceDataClientConfig:
        return BinanceDataClientConfig(
            venue=self.venue,
            api_key=api_key,
            api_secret=api_secret,
            account_type=account_type,
            base_url_http=base_url_http,
            base_url_ws=base_url_ws,
            proxy_url=proxy_url,
            us=us,
            testnet=testnet,
            instrument_provider=self._binance_instrument_provider_config(),
            update_instruments_interval_mins=update_instruments_interval_mins,
            use_agg_trade_ticks=use_agg_trade_ticks,
        )
    def _binance_exec_client_config(
        self,
        api_key: str | None,
        api_secret: str | None,
        account_type: BinanceAccountType,
        testnet: bool = False,
        us: bool = False,
        base_url_http: str | None = None,
        base_url_ws: str | None = None,
        proxy_url: str | None = None,
        use_gtd: bool = True,
        use_reduce_only: bool = True,
        use_position_ids: bool = True,
        use_trade_lite: bool = False,
        treat_expired_as_canceled: bool = False,
    ) -> BinanceExecClientConfig:
        return BinanceExecClientConfig(
            venue=self.venue,
            api_key=api_key,
            api_secret=api_secret,
            account_type=account_type,
            base_url_http=base_url_http,
            base_url_ws=base_url_ws,
            proxy_url=proxy_url,
            us=us,
            testnet=testnet,
            instrument_provider=self._binance_instrument_provider_config(),
            use_gtd=use_gtd,
            use_reduce_only=use_reduce_only,
            use_position_ids=use_position_ids,
            use_trade_lite=use_trade_lite,
            treat_expired_as_canceled=treat_expired_as_canceled,
        )
    def ingest_order_book_deltas(
        self,
        snapshot_path: str,
        updates_path: str,
        nrows_updates: int | None = None,
        clear_catalog: bool = False,
    ) -> None:
        if clear_catalog:
            shutil.rmtree(self.catalog_path, ignore_errors=True)
            Path(self.catalog_path).mkdir(parents=True, exist_ok=True)
            self.catalog = ParquetDataCatalog(self.catalog_path)
        instrument = self._locate_or_stub_instrument()
        df_snap = BinanceOrderBookDeltaDataLoader.load(snapshot_path)
        df_updates = BinanceOrderBookDeltaDataLoader.load(updates_path, nrows=nrows_updates)
        wrangler = OrderBookDeltaDataWrangler(instrument)
        deltas = wrangler.process(df_snap)
        deltas += wrangler.process(df_updates)
        deltas.sort(key=lambda x: x.ts_init)
        self.catalog.write_data([instrument])
        self.catalog.write_data(deltas)
    def _locate_or_stub_instrument(self) -> Instrument:
        instrument = self.catalog.instrument(self.instrument_id)
        if instrument:
            return instrument
        provider = TestInstrumentProvider()
        instrument = provider.find(self.instrument_id)
        if instrument:
            return instrument
        raise RuntimeError("Instrument unavailable; seed catalog first.")
    def build_backtest_run_config(
        self,
        start: int | None = None,
        end: int | None = None,
        bar_type: BarType | None = None,
        book_type: str = "L2_MBP",
        starting_balances: list[str] | None = None,
        strategy_config_factory: Callable[[InstrumentId], dict] | None = None,
        strategy_import_path: str = "",
        strategy_config_path: str = "",
    ) -> BacktestRunConfig:
        data_cfgs = [
            BacktestDataConfig(
                catalog_path=self.catalog_path,
                data_cls=OrderBookDelta,
                instrument_id=self.instrument_id,
                start_time=start,
                end_time=end,
            ),
        ]
        venues_cfgs = [
            BacktestVenueConfig(
                name=self.venue.value,
                oms_type="NETTING",
                account_type="CASH",
                base_currency=None,
                starting_balances=starting_balances or ["1_000_000 USDT"],
                book_type=book_type,
            ),
        ]
        strategies_cfgs = [
            ImportableStrategyConfig(
                strategy_path=strategy_import_path,
                config_path=strategy_config_path,
                config=strategy_config_factory(self.instrument_id) if strategy_config_factory else {},
            ),
        ]
        return BacktestRunConfig(
            engine=BacktestEngineConfig(
                strategies=strategies_cfgs,
                logging=LoggingConfig(log_level="ERROR"),
            ),
            data=data_cfgs,
            venues=venues_cfgs,
        )
    def initialize_backtest_node(self, run_config: BacktestRunConfig) -> None:
        self._backtest_node = BacktestNode(configs=[run_config])
    def run_backtest(self) -> BacktestResult | None:
        if not self._backtest_node:
            return None
        return self._backtest_node.run()
    def teardown_backtest(self) -> None:
        if self._backtest_node:
            self._backtest_node.dispose()
            self._backtest_node = None
    def build_live_trading_node(
        self,
        trader_id: str,
        data_client_cfgs: dict[str, BinanceDataClientConfig],
        exec_client_cfgs: dict[str, BinanceExecClientConfig],
        strategies: list[Strategy],
        cache_cfg: CacheConfig | None = None,
        data_engine_cfg: LiveDataEngineConfig | None = None,
        exec_engine_cfg: LiveExecEngineConfig | None = None,
        logging_cfg: LoggingConfig | None = None,
    ) -> None:
        cfg = TradingNodeConfig(
            trader_id=TraderId(trader_id),
            logging=logging_cfg or LoggingConfig(log_level="INFO"),
            data_engine=data_engine_cfg or LiveDataEngineConfig(),
            exec_engine=exec_engine_cfg or LiveExecEngineConfig(reconciliation=True),
            cache=cache_cfg or CacheConfig(timestamps_as_iso8601=True, flush_on_start=False),
            data_clients=data_client_cfgs,
            exec_clients=exec_client_cfgs,
        )
        self._live_node = TradingNode(config=cfg)
        for key in data_client_cfgs:
            self._live_node.add_data_client_factory(key, BinanceLiveDataClientFactory)
        for key in exec_client_cfgs:
            self._live_node.add_exec_client_factory(key, BinanceLiveExecClientFactory)
        for strat in strategies:
            self._live_node.trader.add_strategy(strat)
    def run_live_trading(self) -> None:
        if not self._live_node:
            return
        self._live_node.build()
        try:
            self._live_node.run()
        finally:
            self._live_node.dispose()
    def dispose_live_trading(self) -> None:
        if self._live_node:
            self._live_node.dispose()
            self._live_node = None
def create_strategy_config(instrument_id: InstrumentId) -> dict:
    pass
def create_strategy(instrument: Instrument) -> Strategy:
    pass
def allocate_strategy_set(instrument: Instrument) -> list[Strategy]:
    pass
def orchestrate_full_pipeline(
    framework: StrategyTestingFramework,
    snapshot_path: str,
    updates_path: str,
    strategy_path: str,
    strategy_config_path: str,
    trader_id: str,
    run_live: bool = False,
) -> None:
    framework.ingest_order_book_deltas(snapshot_path, updates_path, clear_catalog=True)
    backtest_cfg = framework.build_backtest_run_config(
        strategy_config_factory=create_strategy_config,
        strategy_import_path=strategy_path,
        strategy_config_path=strategy_config_path,
    )
    framework.initialize_backtest_node(backtest_cfg)
    framework.run_backtest()
    framework.teardown_backtest()
    if run_live:
        strategy_instances = allocate_strategy_set(framework._locate_or_stub_instrument())
        data_cfg = {
            framework.venue.value: framework._binance_data_client_config(
                api_key=None,
                api_secret=None,
                account_type=BinanceAccountType.USDT_FUTURES,
                testnet=True,
            ),
        }
        exec_cfg = {
            framework.venue.value: framework._binance_exec_client_config(
                api_key=None,
                api_secret=None,
                account_type=BinanceAccountType.USDT_FUTURES,
                testnet=True,
                use_reduce_only=False,
                use_position_ids=False,
            ),
        }
        framework.build_live_trading_node(
            trader_id=trader_id,
            data_client_cfgs=data_cfg,
            exec_client_cfgs=exec_cfg,
            strategies=strategy_instances,
        )
        framework.run_live_trading()
        framework.dispose_live_trading()
from dataclasses import dataclass
from collections import deque
from decimal import Decimal
import os
import matplotlib.pyplot as plt
import pandas as pd

@dataclass(frozen=True)
class SimpleBarMomentumConfig(StrategyConfig):
    instrument_id: InstrumentId
    bar_type: BarType
    lookback: int
    threshold: Decimal
    trade_size: Decimal
    cooldown_secs: float

class SimpleBarMomentumStrategy(Strategy):
    def __init__(self, config: SimpleBarMomentumConfig) -> None:
        super().__init__(config)
        self._instrument: Instrument | None = None
        self._window: deque[Decimal] = deque(maxlen=config.lookback)
        self._last_signal_ts: int = 0
    def on_start(self) -> None:
        instrument = self.cache.instrument(self.config.instrument_id)
        if instrument is None:
            self.log.error(f"Instrument {self.config.instrument_id} missing from cache.")
            self.stop()
            return
        self._instrument = instrument
        self.subscribe_bars(self.config.bar_type)
    def on_bar(self, bar: Bar) -> None:
        if self._instrument is None or bar.instrument_id != self.config.instrument_id:
            return
        price = bar.close.as_decimal()
        self._window.append(price)
        if len(self._window) < self.config.lookback:
            return
        mean_price = sum(self._window) / Decimal(len(self._window))
        upper = mean_price * (Decimal("1.0") + self.config.threshold)
        lower = mean_price * (Decimal("1.0") - self.config.threshold)
        now_ns = self.clock.timestamp_ns()
        if now_ns - self._last_signal_ts < self.config.cooldown_secs * 1e9:
            return
        if price > upper:
            self._submit_order(OrderSide.SELL)
            self._last_signal_ts = now_ns
        elif price < lower:
            self._submit_order(OrderSide.BUY)
            self._last_signal_ts = now_ns
    def _submit_order(self, side: OrderSide) -> None:
        qty = self._instrument.make_qty(self.config.trade_size)
        order = self.order_factory.market(
            instrument_id=self.config.instrument_id,
            order_side=side,
            quantity=qty,
        )
        self.submit_order(order)

def create_strategy_config(instrument_id: InstrumentId) -> dict:
    bar_type = BarType.from_str(f"{instrument_id.value}-1-MINUTE-LAST-EXTERNAL")
    return {
        "instrument_id": instrument_id,
        "bar_type": bar_type,
        "lookback": 21,
        "threshold": Decimal("0.0015"),
        "trade_size": Decimal("0.001"),
        "cooldown_secs": 30.0,
    }

def create_strategy(instrument: Instrument) -> Strategy:
    cfg = SimpleBarMomentumConfig(
        instrument_id=instrument.id,
        bar_type=BarType.from_str(f"{instrument.id.value}-1-MINUTE-LAST-EXTERNAL"),
        lookback=21,
        threshold=Decimal("0.0015"),
        trade_size=Decimal("0.001"),
        cooldown_secs=30.0,
    )
    return SimpleBarMomentumStrategy(cfg)

def allocate_strategy_set(instrument: Instrument) -> list[Strategy]:
    return [create_strategy(instrument)]

def _coerce_dataframe(obj) -> pd.DataFrame:
    if hasattr(obj, "to_pandas"):
        return obj.to_pandas()
    if isinstance(obj, pd.DataFrame):
        return obj.copy()
    return pd.DataFrame(obj)

def _plot_academic_performance(account_df: pd.DataFrame, positions_df: pd.DataFrame, title: str) -> None:
    if account_df.empty:
        return
    account_df = account_df.sort_values("ts_event").reset_index(drop=True)
    account_df["equity"] = account_df["net_liquidation_value"].astype(float)
    account_df["time"] = pd.to_datetime(account_df["ts_event"])
    account_df["cummax"] = account_df["equity"].cummax()
    account_df["drawdown"] = account_df["equity"] / account_df["cummax"] - 1.0
    plt.style.use("seaborn-v0_8-deep")
    fig, axes = plt.subplots(2, 1, figsize=(12, 10), constrained_layout=True)
    axes[0].plot(account_df["time"], account_df["equity"], color="#003f5c", linewidth=2.2)
    axes[0].set_title(f"{title} â€” Equity Trajectory", fontsize=14, fontweight="bold")
    axes[0].set_ylabel("Net Liquidation (quote units)")
    axes[0].grid(alpha=0.25)
    axes[1].fill_between(account_df["time"], account_df["drawdown"], color="#bc5090", alpha=0.6)
    axes[1].set_title("Relative Drawdown", fontsize=13, fontweight="bold")
    axes[1].set_ylabel("Drawdown")
    axes[1].set_ylim(-0.25, 0.05)
    axes[1].grid(alpha=0.25)
    if not positions_df.empty and "net_qty" in positions_df:
        ax2 = axes[0].twinx()
        ax2.step(pd.to_datetime(positions_df["ts_event"]), positions_df["net_qty"], color="#ffa600", linewidth=1.5, alpha=0.6)
        ax2.set_ylabel("Position (contracts)")
    plt.show()

def main() -> None:
    venue = BINANCE_VENUE
    instrument_id = InstrumentId.from_str("BTCUSDT-PERP.BINANCE")
    catalog_path = os.environ.get("NAUTILUS_CATALOG_PATH", "catalog/binance_orderbooks")
    snapshot_path = os.environ.get("BINANCE_SNAPSHOT_PATH", "data/BTCUSDT_snap.csv")
    updates_path = os.environ.get("BINANCE_UPDATES_PATH", "data/BTCUSDT_updates.csv")
    framework = StrategyTestingFramework(catalog_path, venue, instrument_id)
    framework.ingest_order_book_deltas(snapshot_path, updates_path, clear_catalog=False)
    backtest_cfg = framework.build_backtest_run_config(
        strategy_config_factory=create_strategy_config,
        strategy_import_path="__main__:SimpleBarMomentumStrategy",
        strategy_config_path="__main__:SimpleBarMomentumConfig",
    )
    framework.initialize_backtest_node(backtest_cfg)
    framework.run_backtest()
    engine = framework._backtest_node.get_engine(backtest_cfg.id)
    account_df = _coerce_dataframe(engine.trader.generate_account_report(venue))
    positions_df = _coerce_dataframe(engine.trader.generate_positions_report())
    _plot_academic_performance(account_df, positions_df, title="Simple Bar Momentum Study")
    framework.teardown_backtest()

if __name__ == "__main__":
    main()
    
