<documents><document index="1472">
<source>docs/api_reference/adapters/binance.md</source>
<document_content>
# Binance
```{eval-rst}
.. automodule:: nautilus_trader.adapters.binance
   :show-inheritance:
   :inherited-members:
   :members:
   :member-order: bysource
```
## Config
```{eval-rst}
.. automodule:: nautilus_trader.adapters.binance.config
   :show-inheritance:
   :inherited-members:
   :members:
   :member-order: bysource
```
## Factories
```{eval-rst}
.. automodule:: nautilus_trader.adapters.binance.factories
   :show-inheritance:
   :inherited-members:
   :members:
   :member-order: bysource
```
## Enums
```{eval-rst}
.. automodule:: nautilus_trader.adapters.binance.common.enums
   :show-inheritance:
   :inherited-members:
   :members:
   :member-order: bysource
```
## Types
```{eval-rst}
.. automodule:: nautilus_trader.adapters.binance.common.types
   :show-inheritance:
   :inherited-members:
   :members:
   :member-order: bysource
```
## Futures
### Data
```{eval-rst}
.. automodule:: nautilus_trader.adapters.binance.futures.data
   :show-inheritance:
   :inherited-members:
   :members:
   :member-order: bysource
```
### Enums
```{eval-rst}
.. automodule:: nautilus_trader.adapters.binance.futures.enums
   :show-inheritance:
   :inherited-members:
   :members:
   :member-order: bysource
```
### Execution
```{eval-rst}
.. automodule:: nautilus_trader.adapters.binance.futures.execution
   :show-inheritance:
   :inherited-members:
   :members:
   :member-order: bysource
```
### Providers
```{eval-rst}
.. automodule:: nautilus_trader.adapters.binance.futures.providers
   :show-inheritance:
   :inherited-members:
   :members:
   :member-order: bysource
```
### Types
```{eval-rst}
.. automodule:: nautilus_trader.adapters.binance.futures.types
   :show-inheritance:
   :inherited-members:
   :members:
   :member-order: bysource
```
## Spot
### Data
```{eval-rst}
.. automodule:: nautilus_trader.adapters.binance.spot.data
   :show-inheritance:
   :inherited-members:
   :members:
   :member-order: bysource
```
### Enums
```{eval-rst}
.. automodule:: nautilus_trader.adapters.binance.spot.enums
   :show-inheritance:
   :inherited-members:
   :members:
   :member-order: bysource
```
### Execution
```{eval-rst}
.. automodule:: nautilus_trader.adapters.binance.spot.execution
   :show-inheritance:
   :inherited-members:
   :members:
   :member-order: bysource
```
### Providers
```{eval-rst}
.. automodule:: nautilus_trader.adapters.binance.spot.providers
   :show-inheritance:
   :inherited-members:
   :members:
   :member-order: bysource
```
</document_content>
</document>
<document index="1550">
<source>docs/integrations/binance.md</source>
<document_content>
# Binance
Founded in 2017, Binance is one of the largest cryptocurrency exchanges in terms
of daily trading volume, and open interest of crypto assets and crypto
derivative products.
This integration supports live market data ingest and order execution for:
- **Binance Spot** (including Binance US)
- **Binance USDT-Margined Futures** (perpetuals and delivery contracts)
- **Binance Coin-Margined Futures**
## Examples
You can find live example scripts [here](https://github.com/nautechsystems/nautilus_trader/tree/develop/examples/live/binance/).
## Overview
This guide assumes a trader is setting up for both live market data feeds, and trade execution.
The Binance adapter includes multiple components, which can be used together or separately depending
on the use case.
- `BinanceHttpClient`: Low-level HTTP API connectivity.
- `BinanceWebSocketClient`: Low-level WebSocket API connectivity.
- `BinanceInstrumentProvider`: Instrument parsing and loading functionality.
- `BinanceSpotDataClient`/`BinanceFuturesDataClient`: A market data feed manager.
- `BinanceSpotExecutionClient`/`BinanceFuturesExecutionClient`: An account management and trade execution gateway.
- `BinanceLiveDataClientFactory`: Factory for Binance data clients (used by the trading node builder).
- `BinanceLiveExecClientFactory`: Factory for Binance execution clients (used by the trading node builder).
:::note
Most users will define a configuration for a live trading node (as below),
and won't need to necessarily work with these lower level components directly.
:::
### Product support
| Product Type                             | Supported | Notes                               |
|------------------------------------------|-----------|-------------------------------------|
| Spot Markets (incl. Binance US)          | ✓         |                                     |
| Margin Accounts (Cross & Isolated)       | -         | Margin trading not implemented.     |
| USDT-Margined Futures (PERP & Delivery)  | ✓         |                                     |
| Coin-Margined Futures                    | ✓         |                                     |
:::note
Margin trading (cross & isolated) is not implemented at this time.
Contributions via [GitHub issue #2631](https://github.com/nautechsystems/nautilus_trader/issues/#2631)
or pull requests to add margin trading functionality are welcome.
:::
## Data types
To provide complete API functionality to traders, the integration includes several
custom data types:
- `BinanceTicker`: Represents data returned for Binance 24-hour ticker subscriptions, including comprehensive price and statistical information.
- `BinanceBar`: Represents data for historical requests or real-time subscriptions to Binance bars, with additional volume metrics.
- `BinanceFuturesMarkPriceUpdate`: Represents mark price updates for Binance Futures subscriptions.
See the Binance [API Reference](../api_reference/adapters/binance.md) for full definitions.
## Symbology
As per the Nautilus unification policy for symbols, the native Binance symbols are used where possible including for
spot assets and futures contracts. Because NautilusTrader is capable of multi-venue + multi-account
trading, it's necessary to explicitly clarify the difference between `BTCUSDT` as the spot and margin traded
pair, and the `BTCUSDT` perpetual futures contract (this symbol is used for *both* natively by Binance).
Therefore, Nautilus appends the suffix `-PERP` to all perpetual symbols.
E.g. for Binance Futures, the `BTCUSDT` perpetual futures contract symbol would be `BTCUSDT-PERP` within the Nautilus system boundary.
## Order capability
The following tables detail the order types, execution instructions, and time-in-force options supported across different Binance account types:
### Order types
| Order Type             | Spot | Margin | USDT Futures | Coin Futures | Notes                   |
|------------------------|------|--------|--------------|--------------|-------------------------|
| `MARKET`               | ✓    | ✓      | ✓            | ✓            | Quote quantity support: Spot/Margin only. |
| `LIMIT`                | ✓    | ✓      | ✓            | ✓            |                         |
| `STOP_MARKET`          | -    | ✓      | ✓            | ✓            | Not supported for Spot. |
| `STOP_LIMIT`           | ✓    | ✓      | ✓            | ✓            |                         |
| `MARKET_IF_TOUCHED`    | -    | -      | ✓            | ✓            | Futures only.           |
| `LIMIT_IF_TOUCHED`     | ✓    | ✓      | ✓            | ✓            |                         |
| `TRAILING_STOP_MARKET` | -    | -      | ✓            | ✓            | Futures only.           |
### Execution instructions
| Instruction   | Spot | Margin | USDT Futures | Coin Futures | Notes                                 |
|---------------|------|--------|--------------|--------------|---------------------------------------|
| `post_only`   | ✓    | ✓      | ✓            | ✓            | See restrictions below.               |
| `reduce_only` | -    | -      | ✓            | ✓            | Futures only; disabled in Hedge Mode. |
#### Post-only restrictions
Only *limit* order types support `post_only`.
| Order Type               | Spot | Margin | USDT Futures | Coin Futures | Notes                                                      |
|--------------------------|------|--------|--------------|--------------|------------------------------------------------------------|
| `LIMIT`                  | ✓    | ✓      | ✓            | ✓            | Uses `LIMIT_MAKER` for Spot/Margin, `GTX` TIF for Futures. |
| `STOP_LIMIT`             | -    | -      | ✓            | ✓            | Not supported for Spot/Margin.                             |
### Time in force
| Time in force | Spot | Margin | USDT Futures | Coin Futures | Notes                                           |
|---------------|------|--------|--------------|--------------|-------------------------------------------------|
| `GTC`         | ✓    | ✓      | ✓            | ✓            | Good Till Canceled.                             |
| `GTD`         | ✓*   | ✓*     | ✓            | ✓            | *Converted to GTC for Spot/Margin with warning. |
| `FOK`         | ✓    | ✓      | ✓            | ✓            | Fill or Kill.                                   |
| `IOC`         | ✓    | ✓      | ✓            | ✓            | Immediate or Cancel.                            |
### Advanced order features
| Feature            | Spot | Margin | USDT Futures | Coin Futures | Notes                                        |
|--------------------|------|--------|--------------|--------------|----------------------------------------------|
| Order Modification | ✓    | ✓      | ✓            | ✓            | Price and quantity for `LIMIT` orders only.  |
| Bracket/OCO Orders | ✓    | ✓      | ✓            | ✓            | One-Cancels-Other for stop loss/take profit. |
| Iceberg Orders     | ✓    | ✓      | ✓            | ✓            | Large orders split into visible portions.    |
### Batch operations
| Operation          | Spot | Margin | USDT Futures | Coin Futures | Notes                                        |
|--------------------|------|--------|--------------|--------------|----------------------------------------------|
| Batch Submit       | ✓    | ✓      | ✓            | ✓            | Submit multiple orders in single request.    |
| Batch Modify       | -    | -      | ✓            | ✓            | Modify multiple orders in single request. Futures only. |
| Batch Cancel       | ✓    | ✓      | ✓            | ✓            | Cancel multiple orders in single request.    |
### Position management
| Feature              | Spot | Margin | USDT Futures | Coin Futures | Notes                                      |
|---------------------|------|--------|--------------|--------------|---------------------------------------------|
| Query positions     | -    | ✓      | ✓            | ✓            | Real-time position updates.                 |
| Position mode       | -    | -      | ✓            | ✓            | One-Way vs Hedge mode (position IDs).       |
| Leverage control    | -    | ✓      | ✓            | ✓            | Dynamic leverage adjustment per symbol.     |
| Margin mode         | -    | ✓      | ✓            | ✓            | Cross vs Isolated margin per symbol.        |
### Risk events
| Feature              | Spot | Margin | USDT Futures | Coin Futures | Notes                                       |
|----------------------|------|--------|--------------|--------------|---------------------------------------------|
| Liquidation handling | -    | -      | ✓            | ✓            | Exchange-forced position closures.          |
| ADL handling         | -    | -      | ✓            | ✓            | Auto-Deleveraging events.                   |
Binance Futures can trigger exchange-generated orders in response to risk events:
- **Liquidations**: When insufficient margin exists to maintain a position, Binance forcibly closes it at the bankruptcy price. These orders have client IDs starting with `autoclose-`.
- **ADL (Auto-Deleveraging)**: When the insurance fund is depleted, Binance closes profitable positions to cover losses. These orders use client ID `adl_autoclose`.
- **Settlements**: Quarterly contract deliveries use client IDs starting with `settlement_autoclose-`.
The adapter detects these special order types via their client ID patterns and execution type (`CALCULATED`), then:
1. Logs a warning with order details for monitoring.
2. Generates an `OrderStatusReport` to seed the cache.
3. Generates a `FillReport` with correct fill details and TAKER liquidity side.
This ensures liquidation and ADL events are properly reflected in portfolio state and PnL calculations.
### Order querying
| Feature              | Spot | Margin | USDT Futures | Coin Futures | Notes                                      |
|---------------------|------|--------|--------------|--------------|---------------------------------------------|
| Query open orders   | ✓    | ✓      | ✓            | ✓            | List all active orders.                     |
| Query order history | ✓    | ✓      | ✓            | ✓            | Historical order data.                      |
| Order status updates| ✓    | ✓      | ✓            | ✓            | Real-time order state changes.              |
| Trade history       | ✓    | ✓      | ✓            | ✓            | Execution and fill reports.                 |
### Contingent orders
| Feature              | Spot | Margin | USDT Futures | Coin Futures | Notes                                       |
|---------------------|------|--------|--------------|--------------|----------------------------------------------|
| Order lists         | -    | -      | -            | -            | *Not supported*.                             |
| OCO orders          | ✓    | ✓      | ✓            | ✓            | One-Cancels-Other for stop loss/take profit. |
| Bracket orders      | ✓    | ✓      | ✓            | ✓            | Stop loss + take profit combinations.        |
| Conditional orders  | ✓    | ✓      | ✓            | ✓            | Stop and market-if-touched orders.           |
### Order parameters
Customize individual orders by supplying a `params` dictionary when calling `Strategy.submit_order`. The Binance execution clients currently recognise:
| Parameter       | Type   | Account types     | Description |
|-----------------|--------|-------------------|-------------|
| `price_match`   | `str`  | USDT/COIN Futures | Set one of Binance's `priceMatch` modes (see Price match section below) to delegate price selection to the exchange. Cannot be combined with `post_only` or iceberg (`display_qty`) instructions. |
### Price match
Binance Futures supports BBO (Best Bid/Offer) price matching via the `priceMatch` parameter, which delegates price selection to the exchange. This feature allows limit orders to dynamically join the order book at optimal prices without manually specifying the exact price level.
When using `price_match`, you submit a limit order with a reference price (for local risk checks), but Binance determines the actual working price based on the current market state and the selected price match mode.
#### Valid price match values
Valid `priceMatch` values for Binance Futures:
| Value         | Behaviour                                                      |
|---------------|----------------------------------------------------------------|
| `OPPONENT`    | Join the best price on the opposing side of the book.          |
| `OPPONENT_5`  | Join the opposing side price but allow up to a 5-tick offset.  |
| `OPPONENT_10` | Join the opposing side price but allow up to a 10-tick offset. |
| `OPPONENT_20` | Join the opposing side price but allow up to a 20-tick offset. |
| `QUEUE`       | Join the best price on the same side (stay maker).             |
| `QUEUE_5`     | Join the same-side queue but offset up to 5 ticks.             |
| `QUEUE_10`    | Join the same-side queue but offset up to 10 ticks.            |
| `QUEUE_20`    | Join the same-side queue but offset up to 20 ticks.            |
:::info
For more details, see the [official documentation](https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api).
:::
#### Event sequence
When an order is submitted with `price_match`, the following sequence of events occurs:
1. **Order submission**: Nautilus sends the order to Binance with the `priceMatch` parameter but omits the limit price in the API request.
2. **Order acceptance**: Binance accepts the order and determines the actual working price based on the current market and the specified price match mode.
3. **OrderAccepted event**: Nautilus generates an `OrderAccepted` event when the order is confirmed.
4. **OrderUpdated event**: If the Binance-accepted price differs from the original reference price, Nautilus immediately generates an `OrderUpdated` event with the actual working price.
5. **Price synchronization**: The order's limit price in the Nautilus cache is now synchronized with the actual price accepted by Binance.
This ensures that the order price in your system accurately reflects what Binance has accepted, which is critical for position management, risk calculations, and strategy logic.
#### Example
```python
order = strategy.order_factory.limit(
    instrument_id=InstrumentId.from_str("BTCUSDT-PERP.BINANCE"),
    order_side=OrderSide.BUY,
    quantity=Quantity.from_int(1),
    price=Price.from_str("65000"),  # Reference price for local risk checks
)
strategy.submit_order(
    order,
    params={"price_match": "QUEUE"},
)
```
:::note
After submission, if Binance accepts the order at a different price (e.g., 64,995.50), you will receive both an `OrderAccepted` event followed by an `OrderUpdated` event with the new price.
:::
### Trailing stops
For trailing stop market orders on Binance:
- Use `activation_price` (optional) to specify when the trailing mechanism activates
- When omitted, Binance uses the current market price at submission time
- Use `trailing_offset` for the callback rate (in basis points)
:::warning
Do not use `trigger_price` for trailing stop orders - it will fail with an error. Use `activation_price` instead.
:::
## Order books
Order books can be maintained at full or partial depths depending on the
subscription. WebSocket stream throttling is different between Spot and Futures exchanges,
Nautilus will use the highest streaming rate possible:
Order books can be maintained at full or partial depths based on the subscription settings.
WebSocket stream update rates differ between Spot and Futures exchanges, with Nautilus using the
highest available streaming rate:
- **Spot**: 100ms
- **Futures**: 0ms (*unthrottled*)
There is a limitation of one order book per instrument per trader instance.
As stream subscriptions may vary, the latest order book data (deltas or snapshots)
subscription will be used by the Binance data client.
Order book snapshot rebuilds will be triggered on:
- Initial subscription of the order book data.
- Data websocket reconnects.
The sequence of events is as follows:
- Deltas will start buffered.
- Snapshot is requested and awaited.
- Snapshot response is parsed to `OrderBookDeltas`.
- Snapshot deltas are sent to the `DataEngine`.
- Buffered deltas are iterated, dropping those where the sequence number is not greater than the last delta in the snapshot.
- Deltas will stop buffering.
- Remaining deltas are sent to the `DataEngine`.
## Binance data differences
The `ts_event` field value for `QuoteTick` objects will differ between Spot and Futures exchanges,
where the former does not provide an event timestamp, so the `ts_init` is used (which means `ts_event` and `ts_init` are identical).
## Binance specific data
It's possible to subscribe to Binance specific data streams as they become available to the
adapter over time.
:::note
Bars are not considered 'Binance specific' and can be subscribed to in the normal way.
As more adapters are built out which need for example mark price and funding rate updates, then these
methods may eventually become first-class (not requiring custom/generic subscriptions as below).
:::
### `BinanceFuturesMarkPriceUpdate`
You can subscribe to `BinanceFuturesMarkPriceUpdate` (including funding rating info)
data streams by subscribing in the following way from your actor or strategy:
```python
# In your `on_start` method
self.subscribe_data(
    data_type=DataType(BinanceFuturesMarkPriceUpdate, metadata={"instrument_id": self.instrument.id}),
    client_id=ClientId("BINANCE"),
)
```
This will result in your actor/strategy passing these received `BinanceFuturesMarkPriceUpdate`
objects to your `on_data` method. You will need to check the type, as this
method acts as a flexible handler for all custom/generic data.
```python
def on_data(self, data: Data):
    # First check the type of data
    if isinstance(data, BinanceFuturesMarkPriceUpdate):
        # Do something with the data
```
## Rate limiting
Binance uses an interval-based rate limiting system where request weight is tracked per fixed time window (e.g., every minute resets at :00 seconds). The adapter uses token bucket rate limiters to approximate this behavior, helping to reduce the risk of quota violations while maintaining high throughput for normal trading operations.
| Key / Endpoint        | Limit (weight/min) | Notes                                                 |
|-----------------------|--------------------|-------------------------------------------------------|
| `binance:global`      | Spot: 6,000<br>Futures: 2,400 | Default bucket applied to every request.   |
| `/api/v3/order`       | 3,000              | Spot order placement.                                 |
| `/api/v3/allOrders`   | 150                | Spot all-orders endpoint (20× weight multiplier).     |
| `/api/v3/klines`      | 600                | Spot historical klines.                               |
| `/fapi/v1/order`      | 1,200              | Futures order placement.                              |
| `/fapi/v1/allOrders`  | 60                 | Futures historical orders (20× multiplier).           |
| `/fapi/v1/klines`     | 600                | Futures historical klines.                            |
Binance assigns request weight dynamically (e.g. `/klines` scales with `limit`). The quotas above mirror the static limits but the client still draws a single token per call, so long history pulls may need manual pacing to respect the live `X-MBX-USED-WEIGHT-*` headers.
:::warning
Binance returns HTTP 429 when you exceed the allowed weight and repeated bursts can trigger temporary IP bans, so leave enough headroom between batches.
:::
:::info
For more details on rate limiting, see the official documentation: <https://binance-docs.github.io/apidocs/futures/en/#limits>.
:::
## Configuration
### Data client configuration options
| Option                             | Default | Description |
|------------------------------------|---------|-------------|
| `venue`                            | `BINANCE` | Venue identifier used when registering the client. |
| `api_key`                          | `None`  | Binance API key; loaded from environment variables when omitted. |
| `api_secret`                       | `None`  | Binance API secret; loaded from environment variables when omitted. |
| `key_type`                         | `HMAC`  | Cryptographic key type (`HMAC`, `RSA`, or `ED25519`). |
| `account_type`                     | `SPOT`  | Account type for data endpoints (spot, margin, USDT futures, coin futures). |
| `base_url_http`                    | `None`  | Override for the HTTP REST base URL. |
| `base_url_ws`                      | `None`  | Override for the WebSocket base URL. |
| `proxy_url`                        | `None`  | Optional proxy URL for HTTP requests. |
| `us`                               | `False` | Route requests to Binance US endpoints when `True`. |
| `testnet`                          | `False` | Use Binance testnet endpoints when `True`. |
| `update_instruments_interval_mins` | `60`    | Interval (minutes) between instrument catalogue refreshes. |
| `use_agg_trade_ticks`              | `False` | When `True`, subscribe to aggregated trade ticks instead of raw trades. |
### Execution client configuration options
| Option                               | Default | Description |
|--------------------------------------|---------|-------------|
| `venue`                              | `BINANCE` | Venue identifier used when registering the client. |
| `api_key`                            | `None`  | Binance API key; loaded from environment variables when omitted. |
| `api_secret`                         | `None`  | Binance API secret; loaded from environment variables when omitted. |
| `key_type`                           | `HMAC`  | Cryptographic key type (`HMAC`, `RSA`, or `ED25519`). |
| `account_type`                       | `SPOT`  | Account type for order placement (spot, margin, USDT futures, coin futures). |
| `base_url_http`                      | `None`  | Override for the HTTP REST base URL. |
| `base_url_ws`                        | `None`  | Override for the WebSocket base URL. |
| `proxy_url`                          | `None`  | Optional proxy URL for HTTP requests. |
| `us`                                 | `False` | Route requests to Binance US endpoints when `True`. |
| `testnet`                            | `False` | Use Binance testnet endpoints when `True`. |
| `use_gtd`                            | `True`  | When `False`, remaps GTD orders to GTC for local expiry management. |
| `use_reduce_only`                    | `True`  | When `True`, passes through `reduce_only` instructions to Binance. |
| `use_position_ids`                   | `True`  | Enable Binance hedging position IDs; set `False` for virtual hedging. |
| `use_trade_lite`                     | `False` | Use TRADE_LITE execution events that include derived fees. |
| `treat_expired_as_canceled`          | `False` | Treat `EXPIRED` execution types as `CANCELED` when `True`. |
| `recv_window_ms`                     | `5,000` | Receive window (milliseconds) for signed REST requests. |
| `max_retries`                        | `None`  | Maximum retry attempts for order submission/cancel/modify calls. |
| `retry_delay_initial_ms`             | `None`  | Initial delay (milliseconds) between retry attempts. |
| `retry_delay_max_ms`                 | `None`  | Maximum delay (milliseconds) between retry attempts. |
| `futures_leverages`                  | `None`  | Mapping of `BinanceSymbol` to initial leverage for futures accounts. |
| `futures_margin_types`               | `None`  | Mapping of `BinanceSymbol` to futures margin type (isolated/cross). |
| `listen_key_ping_max_failures`       | `3`     | Consecutive listen key ping failures allowed before recovery triggers. |
| `log_rejected_due_post_only_as_warning` | `True` | Log post-only rejections as warnings when `True`; otherwise as errors. |
The most common use case is to configure a live `TradingNode` to include Binance
data and execution clients. To achieve this, add a `BINANCE` section to your client
configuration(s):
```python
config = TradingNodeConfig(
    ...,  # Omitted
    data_clients={
        BINANCE: {
            "api_key": "YOUR_BINANCE_API_KEY",
            "api_secret": "YOUR_BINANCE_API_SECRET",
            "account_type": "spot",  # {spot, margin, usdt_future, coin_future}
            "base_url_http": None,  # Override with custom endpoint
            "base_url_ws": None,  # Override with custom endpoint
            "us": False,  # If client is for Binance US
        },
    },
    exec_clients={
        BINANCE: {
            "api_key": "YOUR_BINANCE_API_KEY",
            "api_secret": "YOUR_BINANCE_API_SECRET",
            "account_type": "spot",  # {spot, margin, usdt_future, coin_future}
            "base_url_http": None,  # Override with custom endpoint
            "base_url_ws": None,  # Override with custom endpoint
            "us": False,  # If client is for Binance US
        },
    },
)
```
Then, create a `TradingNode` and add the client factories:
```python
# Instantiate the live trading node with a configuration
node = TradingNode(config=config)
# Register the client factories with the node
node.add_data_client_factory(BINANCE, BinanceLiveDataClientFactory)
node.add_exec_client_factory(BINANCE, BinanceLiveExecClientFactory)
# Finally build the node
node.build()
```
### Key types
Binance supports multiple cryptographic key types for API authentication:
- **HMAC** (default): Uses HMAC-SHA256 with your API secret
- **RSA**: Uses RSA signature with your private key
- **Ed25519**: Uses Ed25519 signature with your private key
You can specify the key type in your configuration:
```python
config = TradingNodeConfig(
    data_clients={
        BINANCE: {
            "api_key": "YOUR_BINANCE_API_KEY",
            "api_secret": "YOUR_BINANCE_API_SECRET",  # For HMAC
            "key_type": BinanceKeyType.ED25519,  # or RSA, HMAC (default)
            "account_type": "spot",
        },
    },
)
```
:::note
Ed25519 keys must be provided in base64-encoded ASN.1/DER format. The implementation automatically extracts the 32-byte seed from the DER structure.
:::
### API credentials
There are multiple options for supplying your credentials to the Binance clients.
Either pass the corresponding values to the configuration objects, or
set the following environment variables:
For Binance live clients (shared between Spot/Margin and Futures), you can set:
- `BINANCE_API_KEY`
- `BINANCE_API_SECRET` (for all key types)
For Binance Spot/Margin testnet clients, you can set:
- `BINANCE_TESTNET_API_KEY`
- `BINANCE_TESTNET_API_SECRET` (for all key types)
For Binance Futures testnet clients, you can set:
- `BINANCE_FUTURES_TESTNET_API_KEY`
- `BINANCE_FUTURES_TESTNET_API_SECRET` (for all key types)
When starting the trading node, you'll receive immediate confirmation of whether your
credentials are valid and have trading permissions.
### Account type
All the Binance account types will be supported for live trading. Set the `account_type`
using the `BinanceAccountType` enum. The account type options are:
- `SPOT`
- `MARGIN` (Margin shared between open positions)
- `ISOLATED_MARGIN` (Margin assigned to a single position)
- `USDT_FUTURES` (USDT or BUSD stablecoins as collateral)
- `COIN_FUTURES` (other cryptocurrency as collateral)
:::tip
We recommend using environment variables to manage your credentials.
:::
### Base URL overrides
It's possible to override the default base URLs for both HTTP Rest and
WebSocket APIs. This is useful for configuring API clusters for performance reasons,
or when Binance has provided you with specialized endpoints.
### Binance US
There is support for Binance US accounts by setting the `us` option in the configs
to `True` (this is `False` by default). All functionality available to US accounts
should behave identically to standard Binance.
### Testnets
It's also possible to configure one or both clients to connect to the Binance testnet.
Set the `testnet` option to `True` (this is `False` by default):
```python
config = TradingNodeConfig(
    ...,  # Omitted
    data_clients={
        BINANCE: {
            "api_key": "YOUR_BINANCE_TESTNET_API_KEY",
            "api_secret": "YOUR_BINANCE_TESTNET_API_SECRET",
            "account_type": "spot",  # {spot, margin, usdt_future}
            "testnet": True,  # If client uses the testnet
        },
    },
    exec_clients={
        BINANCE: {
            "api_key": "YOUR_BINANCE_TESTNET_API_KEY",
            "api_secret": "YOUR_BINANCE_TESTNET_API_SECRET",
            "account_type": "spot",  # {spot, margin, usdt_future}
            "testnet": True,  # If client uses the testnet
        },
    },
)
```
### Aggregated trades
Binance provides aggregated trade data endpoints as an alternative source of trades.
In comparison to the default trade endpoints, aggregated trade data endpoints can return all
ticks between a `start_time` and `end_time`.
To use aggregated trades and the endpoint features, set the `use_agg_trade_ticks` option
to `True` (this is `False` by default.)
### Parser warnings
Some Binance instruments are unable to be parsed into Nautilus objects if they
contain enormous field values beyond what can be handled by the platform.
In these cases, a *warn and continue* approach is taken (the instrument will not
be available).
These warnings may cause unnecessary log noise, and so it's possible to
configure the provider to not log the warnings, as per the client configuration
example below:
```python
instrument_provider=InstrumentProviderConfig(
    load_all=True,
    log_warnings=False,
)
```
### Futures hedge mode
Binance Futures Hedge mode is a position mode where a trader opens positions in both long and short
directions to mitigate risk and potentially profit from market volatility.
To use Binance Future Hedge mode, you need to follow the three items below:
- 1. Before starting the strategy, ensure that hedge mode is configured on Binance.
- 2. Set the `use_reduce_only` option to `False` in BinanceExecClientConfig (this is `True` by default).
    ```python
        config = TradingNodeConfig(
        ...,  # Omitted
        data_clients={
            BINANCE: BinanceDataClientConfig(
                api_key=None,  # 'BINANCE_API_KEY' env var
                api_secret=None,  # 'BINANCE_API_SECRET' env var
                account_type=BinanceAccountType.USDT_FUTURES,
                base_url_http=None,  # Override with custom endpoint
                base_url_ws=None,  # Override with custom endpoint
            ),
        },
        exec_clients={
            BINANCE: BinanceExecClientConfig(
                api_key=None,  # 'BINANCE_API_KEY' env var
                api_secret=None,  # 'BINANCE_API_SECRET' env var
                account_type=BinanceAccountType.USDT_FUTURES,
                base_url_http=None,  # Override with custom endpoint
                base_url_ws=None,  # Override with custom endpoint
                use_reduce_only=False,  # Must be disabled for Hedge mode
            ),
        }
    )
    ```
- 3. When submitting an order, use a suffix (`LONG` or `SHORT` ) in the `position_id` to indicate the position direction.
    ```python
    class EMACrossHedgeMode(Strategy):
        ...,  # Omitted
        def buy(self) -> None:
            """
            Users simple buy method (example).
            """
            order: MarketOrder = self.order_factory.market(
                instrument_id=self.instrument_id,
                order_side=OrderSide.BUY,
                quantity=self.instrument.make_qty(self.trade_size),
                # time_in_force=TimeInForce.FOK,
            )
            # LONG suffix is recognized as a long position by Binance adapter.
            position_id = PositionId(f"{self.instrument_id}-LONG")
            self.submit_order(order, position_id)
        def sell(self) -> None:
            """
            Users simple sell method (example).
            """
            order: MarketOrder = self.order_factory.market(
                instrument_id=self.instrument_id,
                order_side=OrderSide.SELL,
                quantity=self.instrument.make_qty(self.trade_size),
                # time_in_force=TimeInForce.FOK,
            )
            # SHORT suffix is recognized as a short position by Binance adapter.
            position_id = PositionId(f"{self.instrument_id}-SHORT")
            self.submit_order(order, position_id)
    ```
:::info
For additional features or to contribute to the Binance adapter, please see our
[contributing guide](https://github.com/nautechsystems/nautilus_trader/blob/develop/CONTRIBUTING.md).
:::
</document_content>
</document>
<document index="1563">
<source>docs/tutorials/backtest_binance_orderbook.ipynb</source>
<document_content>
{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "0",
   "metadata": {},
   "source": [
    "# Backtest: Binance OrderBook data\n",
    "\n",
    "Tutorial for [NautilusTrader](https://nautilustrader.io/docs/latest/) a high-performance algorithmic trading platform and event driven backtester.\n",
    "\n",
    "[View source on GitHub](https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/tutorials/backtest_binance_orderbook.ipynb).\n",
    "\n",
    ":::info\n",
    "We are currently working on this tutorial.\n",
    ":::"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1",
   "metadata": {},
   "source": [
    "## Overview\n",
    "\n",
    "This tutorial runs through how to set up the data catalog and a `BacktestNode` to backtest an `OrderBookImbalance` strategy or order book data. This example requires you bring your own Binance order book data."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2",
   "metadata": {},
   "source": [
    "## Prerequisites\n",
    "\n",
    "- Python 3.12+ installed\n",
    "- [JupyterLab](https://jupyter.org/) or similar installed (`uv pip install jupyterlab`)\n",
    "- [NautilusTrader](https://pypi.org/project/nautilus_trader/) latest release installed (`uv pip install nautilus_trader`)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3",
   "metadata": {},
   "source": [
    "## Imports\n",
    "\n",
    "We'll start with all of our imports for the remainder of this guide:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import shutil\n",
    "from decimal import Decimal\n",
    "from pathlib import Path\n",
    "\n",
    "import pandas as pd\n",
    "\n",
    "    "    "    "    "    "    "    "    "    "    "    "    "   ]
  },
  {
   "cell_type": "markdown",
   "id": "5",
   "metadata": {},
   "source": [
    "## Loading data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Path to your data directory, using user /Downloads as an example\n",
    "DATA_DIR = \"~/Downloads\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7",
   "metadata": {},
   "outputs": [],
   "source": [
    "data_path = Path(DATA_DIR).expanduser() / \"Data\" / \"Binance\"\n",
    "raw_files = list(data_path.iterdir())\n",
    "raw_files"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# First we'll load the initial order book snapshot\n",
    "path_snap = data_path / \"BTCUSDT_T_DEPTH_2022-11-01_depth_snap.csv\"\n",
    "df_snap = BinanceOrderBookDeltaDataLoader.load(path_snap)\n",
    "df_snap.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Then we'll load the order book updates, to save time here we're limiting to 1 million rows\n",
    "path_update = data_path / \"BTCUSDT_T_DEPTH_2022-11-01_depth_update.csv\"\n",
    "nrows = 1_000_000\n",
    "df_update = BinanceOrderBookDeltaDataLoader.load(path_update, nrows=nrows)\n",
    "df_update.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "10",
   "metadata": {},
   "source": [
    "### Process deltas using a wrangler"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "11",
   "metadata": {},
   "outputs": [],
   "source": [
    "BTCUSDT_BINANCE = TestInstrumentProvider.btcusdt_binance()\n",
    "wrangler = OrderBookDeltaDataWrangler(BTCUSDT_BINANCE)\n",
    "\n",
    "deltas = wrangler.process(df_snap)\n",
    "deltas += wrangler.process(df_update)\n",
    "deltas.sort(key=lambda x: x.ts_init)  # Ensure data is non-decreasing by `ts_init`\n",
    "deltas[:10]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "12",
   "metadata": {},
   "source": [
    "### Set up data catalog"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "13",
   "metadata": {},
   "outputs": [],
   "source": [
    "CATALOG_PATH = os.getcwd() + \"/catalog\"\n",
    "\n",
    "# Clear if it already exists, then create fresh\n",
    "if os.path.exists(CATALOG_PATH):\n",
    "    shutil.rmtree(CATALOG_PATH)\n",
    "os.mkdir(CATALOG_PATH)\n",
    "\n",
    "# Create a catalog instance\n",
    "catalog = ParquetDataCatalog(CATALOG_PATH)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "14",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Write instrument and ticks to catalog\n",
    "catalog.write_data([BTCUSDT_BINANCE])\n",
    "catalog.write_data(deltas)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "15",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Confirm the instrument was written\n",
    "catalog.instruments()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "16",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Explore the available data in the catalog\n",
    "start = dt_to_unix_nanos(pd.Timestamp(\"2022-11-01\", tz=\"UTC\"))\n",
    "end =  dt_to_unix_nanos(pd.Timestamp(\"2022-11-04\", tz=\"UTC\"))\n",
    "\n",
    "deltas = catalog.order_book_deltas(start=start, end=end)\n",
    "print(len(deltas))\n",
    "deltas[:10]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "17",
   "metadata": {},
   "source": [
    "## Configure backtest"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "18",
   "metadata": {},
   "outputs": [],
   "source": [
    "instrument = catalog.instruments()[0]\n",
    "book_type = \"L2_MBP\"  # Ensure data book type matches venue book type\n",
    "\n",
    "data_configs = [BacktestDataConfig(\n",
    "        catalog_path=CATALOG_PATH,\n",
    "        data_cls=OrderBookDelta,\n",
    "        instrument_id=instrument.id,\n",
    "        # start_time=start,  # Run across all data\n",
    "        # end_time=end,  # Run across all data\n",
    "    )\n",
    "]\n",
    "\n",
    "venues_configs = [\n",
    "    BacktestVenueConfig(\n",
    "        name=\"BINANCE\",\n",
    "        oms_type=\"NETTING\",\n",
    "        account_type=\"CASH\",\n",
    "        base_currency=None,\n",
    "        starting_balances=[\"20 BTC\", \"100000 USDT\"],\n",
    "        book_type=book_type,  # <-- Venues book type\n",
    "    )\n",
    "]\n",
    "\n",
    "strategies = [\n",
    "    ImportableStrategyConfig(\n",
    "        strategy_path=\"nautilus_trader.examples.strategies.orderbook_imbalance:OrderBookImbalance\",\n",
    "        config_path=\"nautilus_trader.examples.strategies.orderbook_imbalance:OrderBookImbalanceConfig\",\n",
    "        config={\n",
    "            \"instrument_id\": instrument.id,\n",
    "            \"book_type\": book_type,\n",
    "            \"max_trade_size\": Decimal(\"1.000\"),\n",
    "            \"min_seconds_between_triggers\": 1.0,\n",
    "        },\n",
    "    ),\n",
    "]\n",
    "\n",
    "# NautilusTrader currently exceeds the rate limit for Jupyter notebook logging (stdout output),\n",
    "# this is why the `log_level` is set to \"ERROR\". If you lower this level to see\n",
    "# more logging then the notebook will hang during cell execution. A fix is currently\n",
    "# being investigated which involves either raising the configured rate limits for\n",
    "# Jupyter, or throttling the log flushing from Nautilus.\n",
    "# https://github.com/jupyterlab/jupyterlab/issues/12845\n",
    "# https://github.com/deshaw/jupyterlab-limit-output\n",
    "config = BacktestRunConfig(\n",
    "    engine=BacktestEngineConfig(\n",
    "        strategies=strategies,\n",
    "        logging=LoggingConfig(log_level=\"ERROR\"),\n",
    "    ),\n",
    "    data=data_configs,\n",
    "    venues=venues_configs,\n",
    ")\n",
    "\n",
    "config"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "19",
   "metadata": {},
   "source": [
    "## Run the backtest"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "20",
   "metadata": {},
   "outputs": [],
   "source": [
    "node = BacktestNode(configs=[config])\n",
    "\n",
    "result = node.run()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "21",
   "metadata": {},
   "outputs": [],
   "source": [
    "result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "22",
   "metadata": {},
   "outputs": [],
   "source": [
    "    "    "\n",
    "\n",
    "engine: BacktestEngine = node.get_engine(config.id)\n",
    "\n",
    "engine.trader.generate_order_fills_report()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "23",
   "metadata": {},
   "outputs": [],
   "source": [
    "engine.trader.generate_positions_report()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "24",
   "metadata": {},
   "outputs": [],
   "source": [
    "engine.trader.generate_account_report(Venue(\"BINANCE\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "25",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
</document_content>
</document>
<document index="1576">
<source>examples/backtest/crypto_ema_cross_with_binance_provider.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  limitations under the License.
# -------------------------------------------------------------------------------------------------
import asyncio
import time
from decimal import Decimal
import pandas as pd
async def create_provider():
    """
    Create a provider to load all instrument data from live exchange.
    """
    clock = LiveClock()
    client = get_cached_binance_http_client(
        clock=clock,
        account_type=BinanceAccountType.USDT_FUTURES,
        is_testnet=True,
    )
    binance_provider = BinanceFuturesInstrumentProvider(
        client=client,
        clock=clock,
        config=InstrumentProviderConfig(load_all=True, log_warnings=False),
    )
    await binance_provider.load_all_async()
    return binance_provider
if __name__ == "__main__":
    # Configure backtest engine
    config = BacktestEngineConfig(
        trader_id=TraderId("BACKTESTER-001"),
        logging=LoggingConfig(log_level="INFO"),
    )
    # Build the backtest engine
    engine = BacktestEngine(config=config)
    # Add a trading venue (multiple venues possible)
    # Use actual Binance instrument for backtesting
    provider: BinanceFuturesInstrumentProvider = asyncio.run(create_provider())
    instrument_id = InstrumentId(symbol=Symbol("ETHUSDT-PERP"), venue=BINANCE_VENUE)
    instrument = provider.find(instrument_id)
    if instrument is None:
        raise RuntimeError(f"Unable to find instrument {instrument_id}")
    engine.add_venue(
        venue=BINANCE_VENUE,
        oms_type=OmsType.NETTING,
        account_type=AccountType.MARGIN,
        base_currency=None,
        starting_balances=[Money(1_000_000, instrument.quote_currency)],
    )
    engine.add_instrument(instrument)
    bar_type = BarType.from_str(f"{instrument_id.value}-1-MINUTE-BID-INTERNAL")
    wrangler = QuoteTickDataWrangler(instrument=instrument)
    ticks = wrangler.process_bar_data(
        bid_data=TestDataProvider().read_csv_bars("btc-perp-20211231-20220201_1m.csv"),
        ask_data=TestDataProvider().read_csv_bars("btc-perp-20211231-20220201_1m.csv"),
    )
    engine.add_data(ticks)
    # Configure your strategy
    strategy_config = EMACrossTrailingStopConfig(
        instrument_id=instrument.id,
        bar_type=bar_type,
        trade_size=Decimal("1"),
        fast_ema_period=10,
        slow_ema_period=20,
        atr_period=20,
        trailing_atr_multiple=3.0,
        trailing_offset_type="PRICE",
        trigger_type="LAST_PRICE",
    )
    # Instantiate and add your strategy
    strategy = EMACrossTrailingStop(config=strategy_config)
    engine.add_strategy(strategy=strategy)
    time.sleep(0.1)
    input("Press Enter to continue...")
    # Run the engine (from start to end of data)
    engine.run()
    # Optionally view reports
    with pd.option_context(
        "display.max_rows",
        100,
        "display.max_columns",
        None,
        "display.width",
        300,
    ):
        print(engine.trader.generate_account_report(BINANCE_VENUE))
        print(engine.trader.generate_order_fills_report())
        print(engine.trader.generate_positions_report())
    # For repeated backtest runs make sure to reset the engine
    engine.reset()
    # Good practice to dispose of the object
    engine.dispose()
</document_content>
</document>
<document index="1628">
<source>examples/live/binance/binance_futures_testnet_ema_cross.py</source>
<document_content>
# -------------------------------------------------------------------------------------------------
#  Copyright (C) 2015-2025 Nautech Systems Pty Ltd. All rights reserved.
#
#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
#
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  limitations under the License.
# -------------------------------------------------------------------------------------------------
from decimal import Decimal
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***
# Strategy config params
symbol = "ETHUSDT-PERP"
instrument_id = InstrumentId.from_str(f"{symbol}.{BINANCE}")
order_qty = Decimal("0.02")
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO"),
    exec_engine=LiveExecEngineConfig(
        # debug=True,
        reconciliation=True,
        reconciliation_lookback_mins=1440,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
    ),
    cache=CacheConfig(
        # database=DatabaseConfig(timeout=2),
        timestamps_as_iso8601=True,
        flush_on_start=False,
    ),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(timeout=2),
    #     timestamps_as_iso8601=True,
    #     use_instance_id=False,
    #     # types_filter=[QuoteTick],
    #     stream_per_topic=False,
    #     external_streams=["bybit"],
    #     autotrim_mins=30,
    # ),
    data_clients={
        BINANCE: BinanceDataClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.USDT_FUTURES,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=True,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    exec_clients={
        BINANCE: BinanceExecClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.USDT_FUTURES,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=True,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
            max_retries=3,
            use_position_ids=False,
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)
node = TradingNode(config=config_node)
strat_config = EMACrossConfig(
    instrument_id=instrument_id,
    external_order_claims=[instrument_id],
    bar_type=BarType.from_str(f"{instrument_id}-1-MINUTE-LAST-EXTERNAL"),
    fast_ema_period=10,
    slow_ema_period=20,
    trade_size=order_qty,
    order_id_tag="001",
    oms_type="HEDGING",
    subscribe_trade_ticks=True,
    subscribe_quote_ticks=True,
)
# Instantiate your strategy
strategy = EMACross(config=strat_config)
# Add your strategies and modules
node.trader.add_strategy(strategy)
# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BINANCE, BinanceLiveDataClientFactory)
node.add_exec_client_factory(BINANCE, BinanceLiveExecClientFactory)
node.build()
# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()
</document_content>
</document>
<document index="1629">
<source>examples/live/binance/binance_futures_testnet_exec_tester.py</source>
<document_content>

from decimal import Decimal
# Strategy config params
symbol = "ETHUSDT-PERP"
instrument_id = InstrumentId.from_str(f"{symbol}.{BINANCE}")
order_qty = Decimal("0.02")
# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        # log_level_file="DEBUG",
        # log_file_format="json",
        log_colors=True,
        use_pyo3=True,
    ),
    data_engine=LiveDataEngineConfig(
        external_clients=[ClientId(BINANCE)],
    ),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        open_check_interval_secs=5.0,
        open_check_open_only=False,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
        purge_closed_orders_interval_mins=1,  # Example of purging closed orders for HFT
        purge_closed_orders_buffer_mins=0,  # Purged orders closed for at least an hour
        purge_closed_positions_interval_mins=1,  # Example of purging closed positions for HFT
        purge_closed_positions_buffer_mins=0,  # Purge positions closed for at least an hour
        purge_account_events_interval_mins=1,  # Example of purging account events for HFT
        purge_account_events_lookback_mins=0,  # Purge account events occurring more than an hour ago
        purge_from_database=True,  # Set True with caution
        graceful_shutdown_on_exception=True,
    ),
    cache=CacheConfig(
        # database=DatabaseConfig(),
        timestamps_as_iso8601=True,
        flush_on_start=False,
    ), 
    data_clients={
        BINANCE: BinanceDataClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.USDT_FUTURES,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=True,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    exec_clients={
        BINANCE: BinanceExecClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.USDT_FUTURES,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=True,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
            max_retries=3,
            log_rejected_due_post_only_as_warning=False,
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)
# Instantiate the node with a configuration
node = TradingNode(config=config_node)
# Configure your strategy
strat_config = ExecTesterConfig(
    instrument_id=instrument_id,
    external_order_claims=[instrument_id],
    # subscribe_book=True,
    subscribe_quotes=True,
    subscribe_trades=True,
    order_qty=order_qty,
    # order_params={"price_match": "QUEUE_5"},
    # enable_buys=False,
    # enable_sells=False,
    open_position_on_start_qty=order_qty,
    # tob_offset_ticks=0,
    # use_batch_cancel_on_stop=True,
    # use_individual_cancels_on_stop=True,
    use_post_only=True,
    # close_positions_on_stop=False,
    # log_rejected_due_post_only_as_warning=False,
    # test_reject_post_only=True,
    log_data=False,
)
# Instantiate your strategy
strategy = ExecTester(config=strat_config)
# Add your strategies and modules
node.trader.add_strategy(strategy)
# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BINANCE, BinanceLiveDataClientFactory)
node.add_exec_client_factory(BINANCE, BinanceLiveExecClientFactory)
node.build()
# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()
</document_content>
</document>
<document index="1630">
<source>examples/live/binance/binance_spot_and_futures_market_maker.py</source>
<document_content>

from decimal import Decimal
# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***
# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="DEBUG",
        # log_level_file="DEBUG",
        # log_file_format="json",
        use_pyo3=True,
    ),
    # data_engine=LiveDataEngineConfig(debug=True),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
    ),
    cache=CacheConfig(
        # database=DatabaseConfig(),
        timestamps_as_iso8601=True,
        buffer_interval_ms=100,
        flush_on_start=False,
    ),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(),
    #     encoding="json",
    #     timestamps_as_iso8601=True,
    #     buffer_interval_ms=100,
    #     streams_prefix="quoters",
    #     use_instance_id=False,
    #     types_filter=[QuoteTick],
    #     autotrim_mins=30,
    #     heartbeat_interval_secs=1,
    # ),
    # streaming=StreamingConfig(catalog_path="catalog"),
    data_clients={
        "BINANCE_SPOT": BinanceDataClientConfig(
            venue=Venue("BINANCE_SPOT"),
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=False,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
        "BINANCE_FUTURES": BinanceDataClientConfig(
            venue=Venue("BINANCE_FUTURES"),
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.USDT_FUTURES,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=True,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    exec_clients={
        "BINANCE_SPOT": BinanceExecClientConfig(
            venue=Venue("BINANCE_SPOT"),
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=False,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
            max_retries=3,
        ),
        "BINANCE_FUTURES": BinanceExecClientConfig(
            venue=Venue("BINANCE_FUTURES"),
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.USDT_FUTURES,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=True,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
            max_retries=3,
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)
# Instantiate the node with a configuration
node = TradingNode(config=config_node)
# Configure your strategies
spot_symbol = "ETHUSDT"
strat_config_spot = VolatilityMarketMakerConfig(
    instrument_id=InstrumentId.from_str(f"{spot_symbol}.BINANCE_SPOT"),
    external_order_claims=[InstrumentId.from_str(f"{spot_symbol}.BINANCE_SPOT")],
    bar_type=BarType.from_str(f"{spot_symbol}.BINANCE_SPOT-1-MINUTE-LAST-INTERNAL"),
    atr_period=20,
    atr_multiple=6.0,
    trade_size=Decimal("0.010"),
    client_id=ClientId("BINANCE_SPOT"),
)
futures_symbol = "ETHUSDT-PERP"
strat_config_futures = VolatilityMarketMakerConfig(
    instrument_id=InstrumentId.from_str(f"{futures_symbol}.BINANCE_FUTURES"),
    external_order_claims=[InstrumentId.from_str(f"{futures_symbol}.BINANCE_FUTURES")],
    bar_type=BarType.from_str(f"{futures_symbol}.BINANCE_FUTURES-1-MINUTE-LAST-EXTERNAL"),
    atr_period=20,
    atr_multiple=6.0,
    trade_size=Decimal("0.010"),
    client_id=ClientId("BINANCE_FUTURES"),
)
# Instantiate your strategies
strategy_spot = VolatilityMarketMaker(config=strat_config_spot)
strategy_futures = VolatilityMarketMaker(config=strat_config_futures)
# Add your strategies and modules
node.trader.add_strategies([strategy_spot, strategy_futures])
# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory("BINANCE_SPOT", BinanceLiveDataClientFactory)
node.add_exec_client_factory("BINANCE_SPOT", BinanceLiveExecClientFactory)
node.add_data_client_factory("BINANCE_FUTURES", BinanceLiveDataClientFactory)
node.add_exec_client_factory("BINANCE_FUTURES", BinanceLiveExecClientFactory)
node.build()
# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()
</document_content>
</document>
<document index="1631">
<source>examples/live/binance/binance_spot_ema_cross.py</source>
<document_content>

from decimal import Decimal
# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***
# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO"),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        reconciliation_lookback_mins=1440,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
    ),
    # cache=CacheConfig(
    #     database=DatabaseConfig(),
    #     buffer_interval_ms=100,
    # ),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(),
    #     encoding="json",
    #     streams_prefix="quoters",
    #     use_instance_id=False,
    #     timestamps_as_iso8601=True,
    #     # types_filter=[QuoteTick],
    #     autotrim_mins=1,
    #     heartbeat_interval_secs=1,
    # ),
    data_clients={
        BINANCE: BinanceDataClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=False,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    exec_clients={
        BINANCE: BinanceExecClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=False,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
            max_retries=3,
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)
# Instantiate the node with a configuration
node = TradingNode(config=config_node)
# Configure your strategy
strat_config = EMACrossConfig(
    instrument_id=InstrumentId.from_str("ETHUSDT.BINANCE"),
    external_order_claims=[InstrumentId.from_str("ETHUSDT.BINANCE")],
    bar_type=BarType.from_str("ETHUSDT.BINANCE-1-MINUTE-LAST-EXTERNAL"),
    fast_ema_period=10,
    slow_ema_period=20,
    trade_size=Decimal("0.010"),
    order_id_tag="001",
)
# Instantiate your strategy
strategy = EMACross(config=strat_config)
# Add your strategies and modules
node.trader.add_strategy(strategy)
# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BINANCE, BinanceLiveDataClientFactory)
node.add_exec_client_factory(BINANCE, BinanceLiveExecClientFactory)
node.build()
# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()
</document_content>
</document>
<document index="1632">
<source>examples/live/binance/binance_spot_ema_cross_bracket_algo.py</source>
<document_content>

from decimal import Decimal
# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***
# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        log_level_file="INFO",
    ),
    exec_engine=LiveExecEngineConfig(
        reconciliation=False,
        reconciliation_lookback_mins=1440,
    ),
    data_clients={
        BINANCE: BinanceDataClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=False,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    exec_clients={
        BINANCE: BinanceExecClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=False,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
            max_retries=3,
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)
# Instantiate the node with a configuration
node = TradingNode(config=config_node)
# Configure your strategy
symbol = "ETHUSDT"
strat_config = EMACrossBracketAlgoConfig(
    order_id_tag="001",
    instrument_id=f"{symbol}.BINANCE",
    external_order_claims=[f"{symbol}.BINANCE"],
    bar_type=f"{symbol}.BINANCE-1-MINUTE-LAST-EXTERNAL",
    fast_ema_period=10,
    slow_ema_period=20,
    bracket_distance_atr=1.0,
    trade_size=Decimal("0.05"),
    emulation_trigger="BID_ASK",
    entry_exec_algorithm_id=ExecAlgorithmId("TWAP"),
    entry_exec_algorithm_params={
        "horizon_secs": 10.0,
        "interval_secs": 2.5,
    },
)
# Instantiate your strategy and execution algorithm
strategy = EMACrossBracketAlgo(config=strat_config)
exec_algorithm = TWAPExecAlgorithm()
# Add your strategies and modules
node.trader.add_strategy(strategy)
node.trader.add_exec_algorithm(exec_algorithm)
# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BINANCE, BinanceLiveDataClientFactory)
node.add_exec_client_factory(BINANCE, BinanceLiveExecClientFactory)
node.build()
# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()
</document_content>
</document>
<document index="1633">
<source>examples/live/binance/binance_spot_exec_tester.py</source>
<document_content>

from decimal import Decimal
# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***
# Strategy config params
symbol = "ETHUSDT"
instrument_id = InstrumentId.from_str(f"{symbol}.{BINANCE}")
order_qty = Decimal("0.01")
# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(
        log_level="INFO",
        # log_level_file="DEBUG",
        # log_file_format="json",
        use_pyo3=True,
    ),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        # snapshot_orders=True,
        # snapshot_positions=True,
        # snapshot_positions_interval_secs=5.0,
        open_check_interval_secs=5.0,
        # manage_own_order_books=True,
    ),
    # cache=CacheConfig(
    #     # database=DatabaseConfig(),
    #     timestamps_as_iso8601=True,
    #     buffer_interval_ms=100,
    #     flush_on_start=False,
    # ),
    # message_bus=MessageBusConfig(
    #     database=DatabaseConfig(),
    #     encoding="json",
    #     timestamps_as_iso8601=True,
    #     buffer_interval_ms=100,
    #     streams_prefix="quoters",
    #     use_instance_id=False,
    #     types_filter=[QuoteTick],
    #     autotrim_mins=30,
    #     heartbeat_interval_secs=1,
    # ),
    # streaming=StreamingConfig(catalog_path="catalog"),
    data_clients={
        BINANCE: BinanceDataClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            # key_type=BinanceKeyType.ED25519,
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=False,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    exec_clients={
        BINANCE: BinanceExecClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            # key_type=BinanceKeyType.ED25519,
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=False,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
            max_retries=3,
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)
# Instantiate the node with a configuration
node = TradingNode(config=config_node)
# Configure your strategy
config_strat = ExecTesterConfig(
    instrument_id=instrument_id,
    external_order_claims=[instrument_id],
    order_qty=order_qty,
    # open_position_on_start_qty=order_qty,
    # tob_offset_ticks=0,
    # log_data=False,
)
# Instantiate your strategy
strategy = ExecTester(config=config_strat)
# Add your strategies and modules
node.trader.add_strategy(strategy)
# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BINANCE, BinanceLiveDataClientFactory)
node.add_exec_client_factory(BINANCE, BinanceLiveExecClientFactory)
node.build()
# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()
</document_content>
</document>
<document index="1634">
<source>examples/live/binance/binance_spot_testnet_exec_tester.py</source>
<document_content>

from decimal import Decimal
# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***
# Strategy config params
symbol = "ETHUSDT"
instrument_id = InstrumentId.from_str(f"{symbol}.{BINANCE}")
order_qty = Decimal("0.01")
# Configure the trading node
config_node = TradingNodeConfig(
    trader_id=TraderId("TESTER-001"),
    logging=LoggingConfig(log_level="INFO"),
    exec_engine=LiveExecEngineConfig(
        reconciliation=True,
        reconciliation_lookback_mins=1440,
    ),
    data_clients={
        BINANCE: BinanceDataClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=True,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
        ),
    },
    exec_clients={
        BINANCE: BinanceExecClientConfig(
            api_key=None,  # 'BINANCE_API_KEY' env var
            api_secret=None,  # 'BINANCE_API_SECRET' env var
            account_type=BinanceAccountType.SPOT,
            base_url_http=None,  # Override with custom endpoint
            base_url_ws=None,  # Override with custom endpoint
            us=False,  # If client is for Binance US
            testnet=True,  # If client uses the testnet
            instrument_provider=InstrumentProviderConfig(load_all=True),
            max_retries=3,
        ),
    },
    timeout_connection=30.0,
    timeout_reconciliation=10.0,
    timeout_portfolio=10.0,
    timeout_disconnection=10.0,
    timeout_post_stop=5.0,
)
# Instantiate the node with a configuration
node = TradingNode(config=config_node)
# Configure your strategy
config_strat = ExecTesterConfig(
    instrument_id=instrument_id,
    external_order_claims=[instrument_id],
    order_qty=order_qty,
    open_position_on_start_qty=order_qty,
    use_post_only=True,
    # tob_offset_ticks=0,
    # log_data=False,
)
# Instantiate your strategy
strategy = ExecTester(config=config_strat)
# Add your strategies and modules
node.trader.add_strategy(strategy)
# Register your client factories with the node (can take user-defined factories)
node.add_data_client_factory(BINANCE, BinanceLiveDataClientFactory)
node.add_exec_client_factory(BINANCE, BinanceLiveExecClientFactory)
node.build()
# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    try:
        node.run()
    finally:
        node.dispose()
</document_content>
</document>
<document index="1677">
<source>examples/sandbox/binance_futures_testnet_sandbox.py</source>
<document_content>

import asyncio
from decimal import Decimal
# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***
async def main():
    """
    Show how to run a strategy in a sandbox for the Binance venue.
    """
    # Configure the trading node
    config_node = TradingNodeConfig(
        trader_id=TraderId("TESTER-001"),
        logging=LoggingConfig(
            log_level="INFO",
            # log_level_file="DEBUG",
            # log_file_format="json",
            log_colors=True,
            use_pyo3=True,
        ),
        exec_engine=LiveExecEngineConfig(
            reconciliation=True,
            reconciliation_lookback_mins=1440,
            filter_position_reports=True,
            # snapshot_orders=True,
            # snapshot_positions=True,
            # snapshot_positions_interval_secs=5.0,
        ),
        cache=CacheConfig(
            # database=DatabaseConfig(timeout=2),
            timestamps_as_iso8601=True,
            flush_on_start=False,
        ),
        # message_bus=MessageBusConfig(
        #     database=DatabaseConfig(timeout=2),
        #     encoding="json",
        #     timestamps_as_iso8601=True,
        #     streams_prefix="quoters",
        #     use_instance_id=False,
        #     # types_filter=[QuoteTick],
        #     autotrim_mins=30,
        #     heartbeat_interval_secs=1,
        # ),
        data_clients={
            BINANCE: BinanceDataClientConfig(
                api_key=None,  # 'BINANCE_API_KEY' env var
                api_secret=None,  # 'BINANCE_API_SECRET' env var
                account_type=BinanceAccountType.USDT_FUTURES,
                base_url_http=None,  # Override with custom endpoint
                base_url_ws=None,  # Override with custom endpoint
                us=False,  # If client is for Binance US
                testnet=True,  # If client uses the testnet
                instrument_provider=InstrumentProviderConfig(load_all=True),
            ),
        },
        exec_clients={
            BINANCE: SandboxExecutionClientConfig(
                venue=BINANCE_VENUE,
                starting_balances=["10_000 USDT", "10 ETH"],
            ),
        },
        timeout_connection=30.0,
        timeout_reconciliation=10.0,
        timeout_portfolio=10.0,
        timeout_disconnection=10.0,
        timeout_post_stop=5.0,
    )
    # Instantiate the node with a configuration
    node = TradingNode(config=config_node)
    # Configure your strategy
    strat_config = VolatilityMarketMakerConfig(
        instrument_id=InstrumentId.from_str("ETHUSDT-PERP.BINANCE"),
        external_order_claims=[InstrumentId.from_str("ETHUSDT-PERP.BINANCE")],
        bar_type=BarType.from_str("ETHUSDT-PERP.BINANCE-1-MINUTE-LAST-EXTERNAL"),
        atr_period=20,
        atr_multiple=6.0,
        trade_size=Decimal("0.010"),
        # manage_gtd_expiry=True,
    )
    # Instantiate your strategy
    strategy = VolatilityMarketMaker(config=strat_config)
    # Add your strategies and modules
    node.trader.add_strategy(strategy)
    # Register your client factories with the node (can take user-defined factories)
    node.add_data_client_factory(BINANCE, BinanceLiveDataClientFactory)
    node.add_exec_client_factory(BINANCE, SandboxLiveExecClientFactory)
    node.build()
    try:
        await node.run_async()
    finally:
        await node.stop_async()
        await asyncio.sleep(1)
        node.dispose()
# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    asyncio.run(main())
</document_content>
</document>
<document index="1678">
<source>examples/sandbox/binance_spot_futures_sandbox.py</source>
<document_content>

import asyncio
import json
from decimal import Decimal
# *** THIS IS A TEST STRATEGY WITH NO ALPHA ADVANTAGE WHATSOEVER. ***
# *** IT IS NOT INTENDED TO BE USED TO TRADE LIVE WITH REAL MONEY. ***
class TestStrategyConfig(StrategyConfig, frozen=True):
    futures_client_id: ClientId
    futures_instrument_id: InstrumentId
    spot_instrument_id: InstrumentId
class TestStrategy(Strategy):
    def __init__(self, config: TestStrategyConfig) -> None:
        super().__init__(config)
        self.futures_instrument: Instrument | None = None  # Initialized in on_start
        self.spot_instrument: Instrument | None = None  # Initialized in on_start
        self.futures_client_id = config.futures_client_id
    def on_start(self) -> None:
        self.futures_instrument = self.cache.instrument(self.config.futures_instrument_id)
        if self.futures_instrument is None:
            self.log.error(
                f"Could not find instrument for {self.config.futures_instrument_id}"
                f"\nPossible instruments: {self.cache.instrument_ids()}",
            )
            self.stop()
            return
        self.spot_instrument = self.cache.instrument(self.config.spot_instrument_id)
        if self.spot_instrument is None:
            self.log.error(
                f"Could not find futures instrument for {self.config.spot_instrument_id}"
                f"\nPossible instruments: {self.cache.instrument_ids()}",
            )
            self.stop()
            return
        account = self.portfolio.account(venue=self.futures_instrument.venue)
        balances = {str(currency): str(balance) for currency, balance in account.balances().items()}
        self.log.info(f"Futures balances\n{json.dumps(balances, indent=4)}", LogColor.GREEN)
        account = self.portfolio.account(venue=self.spot_instrument.venue)
        balances = {str(currency): str(balance) for currency, balance in account.balances().items()}
        self.log.info(f"Spot balances\n{json.dumps(balances, indent=4)}", LogColor.GREEN)
        # Subscribe to live data
        self.subscribe_quote_ticks(self.config.futures_instrument_id)
        self.subscribe_quote_ticks(self.config.spot_instrument_id)
        self.subscribe_data(
            data_type=DataType(
                BinanceFuturesMarkPriceUpdate,
                metadata={"instrument_id": self.futures_instrument.id},
            ),
            client_id=self.futures_client_id,
        )
    def on_data(self, data: Data) -> None:
        self.log.info(repr(data), LogColor.CYAN)
    def on_quote_tick(self, tick: QuoteTick) -> None:
        self.log.info(repr(tick), LogColor.CYAN)
    def on_trade_tick(self, tick: TradeTick) -> None:
        self.log.info(repr(tick), LogColor.CYAN)
    def on_bar(self, bar: Bar) -> None:
        self.log.info(repr(bar), LogColor.CYAN)
    def on_stop(self) -> None:
        # Unsubscribe from data
        self.unsubscribe_quote_ticks(self.config.futures_instrument_id)
        self.unsubscribe_quote_ticks(self.config.spot_instrument_id)
async def main():
    """
    Show how to run a strategy in a sandbox for the Binance venue.
    """
    # Configure the trading node
    config_node = TradingNodeConfig(
        trader_id=TraderId("TESTER-001"),
        logging=LoggingConfig(
            log_level="INFO",
            log_colors=True,
            use_pyo3=True,
        ),
        exec_engine=LiveExecEngineConfig(
            reconciliation=True,
            reconciliation_lookback_mins=1440,
            filter_position_reports=True,
        ),
        cache=CacheConfig(
            timestamps_as_iso8601=True,
            flush_on_start=False,
        ),
        data_clients={
            "BINANCE_FUTURES": BinanceDataClientConfig(
                venue=Venue("BINANCE_FUTURES"),
                api_key=None,  # 'BINANCE_API_KEY' env var
                api_secret=None,  # 'BINANCE_API_SECRET' env var
                account_type=BinanceAccountType.USDT_FUTURES,
                base_url_http=None,  # Override with custom endpoint
                base_url_ws=None,  # Override with custom endpoint
                us=False,  # If client is for Binance US
                testnet=False,  # If client uses the testnet
                instrument_provider=InstrumentProviderConfig(load_all=True),
            ),
            "BINANCE_SPOT": BinanceDataClientConfig(
                venue=Venue("BINANCE_SPOT"),
                api_key=None,  # 'BINANCE_API_KEY' env var
                api_secret=None,  # 'BINANCE_API_SECRET' env var
                account_type=BinanceAccountType.SPOT,
                base_url_http=None,  # Override with custom endpoint
                base_url_ws=None,  # Override with custom endpoint
                us=False,  # If client is for Binance US
                testnet=False,  # If client uses the testnet
                instrument_provider=InstrumentProviderConfig(load_all=True),
            ),
        },
        exec_clients={
            "BINANCE_FUTURES": SandboxExecutionClientConfig(
                venue="BINANCE_FUTURES",
                account_type="MARGIN",
                starting_balances=["10_000 USDC", "0.005 BTC"],
                default_leverage=Decimal("5"),
            ),
            "BINANCE_SPOT": SandboxExecutionClientConfig(
                venue="BINANCE_SPOT",
                account_type="CASH",
                starting_balances=["1_000 USDC", "0.001 BTC"],
            ),
        },
        timeout_connection=30.0,
        timeout_reconciliation=10.0,
        timeout_portfolio=10.0,
        timeout_disconnection=10.0,
        timeout_post_stop=5.0,
    )
    # Instantiate the node with a configuration
    node = TradingNode(config=config_node)
    # Configure your strategy
    strat_config = TestStrategyConfig(
        futures_client_id=ClientId("BINANCE_FUTURES"),
        futures_instrument_id=InstrumentId.from_str("BTCUSDT-PERP.BINANCE_FUTURES"),
        spot_instrument_id=InstrumentId.from_str("BTCUSDC.BINANCE_SPOT"),
    )
    # Instantiate your strategy
    strategy = TestStrategy(config=strat_config)
    # Add your strategies and modules
    node.trader.add_strategy(strategy)
    # Register your client factories with the node (can take user-defined factories)
    node.add_data_client_factory("BINANCE_FUTURES", BinanceLiveDataClientFactory)
    node.add_data_client_factory("BINANCE_SPOT", BinanceLiveDataClientFactory)
    node.add_exec_client_factory("BINANCE_FUTURES", SandboxLiveExecClientFactory)
    node.add_exec_client_factory("BINANCE_SPOT", SandboxLiveExecClientFactory)
    node.build()
    try:
        await node.run_async()
    finally:
        await node.stop_async()
        await asyncio.sleep(1)
        node.dispose()
# Stop and dispose of the node with SIGINT/CTRL+C
if __name__ == "__main__":
    asyncio.run(main())
</document_content>
</document>
<document index="1732">
<source>nautilus_trader/adapters/binance/__init__.py</source>
<document_content>

"""
Binance cryptocurreny exchange integration adapter.
This subpackage provides an instrument provider, data and execution clients,
configurations, data types and constants for connecting to and interacting with
Binance's API.
For convenience, the most commonly used symbols are re-exported at the
subpackage's top level, so downstream code can simply import from
``nautilus_trader.adapters.binance``.
"""
from typing import Final
import pyarrow as pa
register_serializable_type(
    BinanceBar,
    BinanceBar.to_dict,
    BinanceBar.from_dict,
)
register_serializable_type(
    BinanceTicker,
    BinanceTicker.to_dict,
    BinanceTicker.from_dict,
)
BINANCE_BAR_ARROW_SCHEMA: Final[pa.schema] = pa.schema(
    {
        "bar_type": pa.dictionary(pa.int16(), pa.string()),
        "instrument_id": pa.dictionary(pa.int64(), pa.string()),
        "open": pa.string(),
        "high": pa.string(),
        "low": pa.string(),
        "close": pa.string(),
        "volume": pa.string(),
        "quote_volume": pa.string(),
        "count": pa.uint64(),
        "taker_buy_base_volume": pa.string(),
        "taker_buy_quote_volume": pa.string(),
        "ts_event": pa.uint64(),
        "ts_init": pa.uint64(),
    },
)
NAUTILUS_ARROW_SCHEMA[BinanceBar] = BINANCE_BAR_ARROW_SCHEMA
register_arrow(
    BinanceBar,
    BINANCE_BAR_ARROW_SCHEMA,
    encoder=make_dict_serializer(BINANCE_BAR_ARROW_SCHEMA),
    decoder=make_dict_deserializer(BinanceBar),
)
__all__ = [
    "BINANCE",
    "BINANCE_CLIENT_ID",
    "BINANCE_VENUE",
    "BinanceAccountType",
    "BinanceDataClientConfig",
    "BinanceExecClientConfig",
    "BinanceFuturesInstrumentProvider",
    "BinanceFuturesMarkPriceUpdate",
    "BinanceKeyType",
    "BinanceLiveDataClientFactory",
    "BinanceLiveExecClientFactory",
    "BinanceOrderBookDeltaDataLoader",
    "BinanceSpotInstrumentProvider",
    "get_cached_binance_http_client",
]
</document_content>
</document>
<document index="1733">
<source>nautilus_trader/adapters/binance/common/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="1734">
<source>nautilus_trader/adapters/binance/common/constants.py</source>
<document_content>

from decimal import Decimal
from typing import Final
BINANCE: Final[str] = "BINANCE"
BINANCE_VENUE: Final[Venue] = Venue(BINANCE)
BINANCE_CLIENT_ID: Final[ClientId] = ClientId(BINANCE)
BINANCE_MIN_CALLBACK_RATE: Final[Decimal] = Decimal("0.1")
BINANCE_MAX_CALLBACK_RATE: Final[Decimal] = Decimal("10.0")
# Set of Binance error codes for which Nautilus will attempt retries,
# potentially temporary conditions where a retry might make sense.
BINANCE_RETRY_ERRORS: set[BinanceErrorCode] = {
    BinanceErrorCode.DISCONNECTED,
    BinanceErrorCode.TOO_MANY_REQUESTS,  # Short retry delays may result in bans
    BinanceErrorCode.TIMEOUT,
    BinanceErrorCode.SERVER_BUSY,
    BinanceErrorCode.INVALID_TIMESTAMP,
    BinanceErrorCode.CANCEL_REJECTED,
    BinanceErrorCode.ME_RECVWINDOW_REJECT,
}
# Set of Binance error codes for which Nautilus will log a warning on failure, rather than an error
BINANCE_RETRY_WARNINGS: set[BinanceErrorCode] = {
    BinanceErrorCode.FOK_ORDER_REJECT,
    BinanceErrorCode.GTX_ORDER_REJECT,
}
# Valid `priceMatch` argument values for Binance Futures order placement.
BINANCE_PRICE_MATCH_VALUES: Final[frozenset[str]] = frozenset(
    {
        "OPPONENT",
        "OPPONENT_5",
        "OPPONENT_10",
        "OPPONENT_20",
        "QUEUE",
        "QUEUE_5",
        "QUEUE_10",
        "QUEUE_20",
    },
)
BINANCE_PRICE_MATCH_ORDER_TYPES: Final[frozenset[OrderType]] = frozenset(
    {
        OrderType.LIMIT,
        OrderType.STOP_LIMIT,
        OrderType.LIMIT_IF_TOUCHED,
    },
)
</document_content>
</document>
<document index="1735">
<source>nautilus_trader/adapters/binance/common/credentials.py</source>
<document_content>

def get_api_key(account_type: BinanceAccountType, is_testnet: bool) -> str:
    if is_testnet:
        if account_type.is_spot_or_margin:
            return get_env_key("BINANCE_TESTNET_API_KEY")
        else:
            return get_env_key("BINANCE_FUTURES_TESTNET_API_KEY")
    return get_env_key("BINANCE_API_KEY")
def get_api_secret(account_type: BinanceAccountType, is_testnet: bool) -> str:
    if is_testnet:
        if account_type.is_spot_or_margin:
            return get_env_key("BINANCE_TESTNET_API_SECRET")
        else:
            return get_env_key("BINANCE_FUTURES_TESTNET_API_SECRET")
    return get_env_key("BINANCE_API_SECRET")
</document_content>
</document>
<document index="1736">
<source>nautilus_trader/adapters/binance/common/enums.py</source>
<document_content>

"""
Defines Binance common enums.
References
----------
https://binance-docs.github.io/apidocs/spot/en/#public-api-definitions
https://binance-docs.github.io/apidocs/futures/en/#public-endpoints-info
"""
from enum import Enum
from enum import unique
@unique
class BinanceKeyType(Enum):
    """
    Represents a Binance private key cryptographic algorithm type.
    """
    HMAC = "HMAC"
    RSA = "RSA"
    ED25519 = "Ed25519"
@unique
class BinanceFuturesPositionSide(Enum):
    """
    Represents a Binance Futures position side.
    """
    BOTH = "BOTH"
    LONG = "LONG"
    SHORT = "SHORT"
@unique
class BinanceRateLimitType(Enum):
    """
    Represents a Binance rate limit type.
    """
    REQUEST_WEIGHT = "REQUEST_WEIGHT"
    ORDERS = "ORDERS"
    RAW_REQUESTS = "RAW_REQUESTS"
@unique
class BinanceRateLimitInterval(Enum):
    """
    Represents a Binance rate limit interval.
    """
    SECOND = "SECOND"
    MINUTE = "MINUTE"
    DAY = "DAY"
@unique
class BinanceKlineInterval(Enum):
    """
    Represents a Binance kline chart interval.
    """
    SECOND_1 = "1s"
    MINUTE_1 = "1m"
    MINUTE_3 = "3m"
    MINUTE_5 = "5m"
    MINUTE_15 = "15m"
    MINUTE_30 = "30m"
    HOUR_1 = "1h"
    HOUR_2 = "2h"
    HOUR_4 = "4h"
    HOUR_6 = "6h"
    HOUR_8 = "8h"
    HOUR_12 = "12h"
    DAY_1 = "1d"
    DAY_3 = "3d"
    WEEK_1 = "1w"
    MONTH_1 = "1M"
@unique
class BinanceExchangeFilterType(Enum):
    """
    Represents a Binance exchange filter type.
    """
    EXCHANGE_MAX_NUM_ORDERS = "EXCHANGE_MAX_NUM_ORDERS"
    EXCHANGE_MAX_NUM_ALGO_ORDERS = "EXCHANGE_MAX_NUM_ALGO_ORDERS"
@unique
class BinanceSymbolFilterType(Enum):
    """
    Represents a Binance symbol filter type.
    """
    PRICE_FILTER = "PRICE_FILTER"
    PERCENT_PRICE = "PERCENT_PRICE"
    PERCENT_PRICE_BY_SIDE = "PERCENT_PRICE_BY_SIDE"
    LOT_SIZE = "LOT_SIZE"
    MIN_NOTIONAL = "MIN_NOTIONAL"
    NOTIONAL = "NOTIONAL"
    ICEBERG_PARTS = "ICEBERG_PARTS"
    MARKET_LOT_SIZE = "MARKET_LOT_SIZE"
    MAX_NUM_ORDERS = "MAX_NUM_ORDERS"
    MAX_NUM_ALGO_ORDERS = "MAX_NUM_ALGO_ORDERS"
    MAX_NUM_ICEBERG_ORDERS = "MAX_NUM_ICEBERG_ORDERS"
    MAX_NUM_ORDER_LISTS = "MAX_NUM_ORDER_LISTS"
    MAX_NUM_ORDER_AMENDS = "MAX_NUM_ORDER_AMENDS"
    MAX_POSITION = "MAX_POSITION"
    TRAILING_DELTA = "TRAILING_DELTA"
    POSITION_RISK_CONTROL = "POSITION_RISK_CONTROL"
@unique
class BinanceAccountType(Enum):
    """
    Represents a Binance account type.
    """
    SPOT = "SPOT"
    MARGIN = "MARGIN"
    ISOLATED_MARGIN = "ISOLATED_MARGIN"
    USDT_FUTURES = "USDT_FUTURES"
    COIN_FUTURES = "COIN_FUTURES"
    @property
    def is_spot(self):
        return self == BinanceAccountType.SPOT
    @property
    def is_margin(self):
        return self in (
            BinanceAccountType.MARGIN,
            BinanceAccountType.ISOLATED_MARGIN,
        )
    @property
    def is_spot_or_margin(self):
        return self in (
            BinanceAccountType.SPOT,
            BinanceAccountType.MARGIN,
            BinanceAccountType.ISOLATED_MARGIN,
        )
    @property
    def is_futures(self) -> bool:
        return self in (
            BinanceAccountType.USDT_FUTURES,
            BinanceAccountType.COIN_FUTURES,
        )
@unique
class BinanceOrderSide(Enum):
    """
    Represents a Binance order side.
    """
    BUY = "BUY"
    SELL = "SELL"
@unique
class BinanceExecutionType(Enum):
    """
    Represents a Binance execution type.
    """
    NEW = "NEW"
    CANCELED = "CANCELED"
    CALCULATED = "CALCULATED"  # Liquidation Execution
    REJECTED = "REJECTED"
    TRADE = "TRADE"
    EXPIRED = "EXPIRED"
    AMENDMENT = "AMENDMENT"
    TRADE_PREVENTION = "TRADE_PREVENTION"
@unique
class BinanceOrderStatus(Enum):
    """
    Represents a Binance order status.
    """
    NEW = "NEW"
    PARTIALLY_FILLED = "PARTIALLY_FILLED"
    FILLED = "FILLED"
    CANCELED = "CANCELED"
    PENDING_CANCEL = "PENDING_CANCEL"
    REJECTED = "REJECTED"
    EXPIRED = "EXPIRED"
    EXPIRED_IN_MATCH = "EXPIRED_IN_MATCH"
    NEW_INSURANCE = "NEW_INSURANCE"  # Liquidation with Insurance Fund
    NEW_ADL = "NEW_ADL"  # Counterparty Liquidation
@unique
class BinanceTimeInForce(Enum):
    """
    Represents a Binance order time in force.
    """
    GTC = "GTC"
    IOC = "IOC"
    FOK = "FOK"
    GTX = "GTX"  # FUTURES only, Good Till Crossing (Post Only)
    GTD = "GTD"  # FUTURES only
    GTE_GTC = "GTE_GTC"  # Undocumented
@unique
class BinanceOrderType(Enum):
    """
    Represents a Binance order type.
    """
    LIMIT = "LIMIT"
    MARKET = "MARKET"
    STOP = "STOP"  # FUTURES only
    STOP_LOSS = "STOP_LOSS"  # SPOT/MARGIN only
    STOP_LOSS_LIMIT = "STOP_LOSS_LIMIT"  # SPOT/MARGIN only
    TAKE_PROFIT = "TAKE_PROFIT"
    TAKE_PROFIT_LIMIT = "TAKE_PROFIT_LIMIT"  # SPOT/MARGIN only
    LIMIT_MAKER = "LIMIT_MAKER"  # SPOT/MARGIN only
    STOP_MARKET = "STOP_MARKET"  # FUTURES only
    TAKE_PROFIT_MARKET = "TAKE_PROFIT_MARKET"  # FUTURES only
    TRAILING_STOP_MARKET = "TRAILING_STOP_MARKET"  # FUTURES only
    INSURANCE_FUND = "INSURANCE_FUND"
@unique
class BinanceSecurityType(Enum):
    """
    Represents a Binance endpoint security type.
    """
    NONE = "NONE"
    TRADE = "TRADE"
    MARGIN = "MARGIN"  # SPOT/MARGIN only
    USER_DATA = "USER_DATA"
    USER_STREAM = "USER_STREAM"
    MARKET_DATA = "MARKET_DATA"
@unique
class BinanceNewOrderRespType(Enum):
    """
    Represents a Binance newOrderRespType.
    """
    ACK = "ACK"
    RESULT = "RESULT"
    FULL = "FULL"
@unique
class BinanceErrorCode(Enum):
    """
    Represents a Binance error code (covers futures).
    """
    UNKNOWN = -1000
    DISCONNECTED = -1001
    UNAUTHORIZED = -1002
    TOO_MANY_REQUESTS = -1003
    DUPLICATE_IP = -1004
    NO_SUCH_IP = -1005
    UNEXPECTED_RESP = -1006
    TIMEOUT = -1007
    SERVER_BUSY = -1008
    ERROR_MSG_RECEIVED = -1010
    NON_WHITE_LIST = -1011
    INVALID_MESSAGE = -1013
    UNKNOWN_ORDER_COMPOSITION = -1014
    TOO_MANY_ORDERS = -1015
    SERVICE_SHUTTING_DOWN = -1016
    UNSUPPORTED_OPERATION = -1020
    INVALID_TIMESTAMP = -1021
    INVALID_SIGNATURE = -1022
    START_TIME_GREATER_THAN_END_TIME = -1023
    NOT_FOUND = -1099
    ILLEGAL_CHARS = -1100
    TOO_MANY_PARAMETERS = -1101
    MANDATORY_PARAM_EMPTY_OR_MALFORMED = -1102
    UNKNOWN_PARAM = -1103
    UNREAD_PARAMETERS = -1104
    PARAM_EMPTY = -1105
    PARAM_NOT_REQUIRED = -1106
    BAD_ASSET = -1108
    BAD_ACCOUNT = -1109
    BAD_INSTRUMENT_TYPE = -1110
    BAD_PRECISION = -1111
    NO_DEPTH = -1112
    WITHDRAW_NOT_NEGATIVE = -1113
    TIF_NOT_REQUIRED = -1114
    INVALID_TIF = -1115
    INVALID_ORDER_TYPE = -1116
    INVALID_SIDE = -1117
    EMPTY_NEW_CL_ORD_ID = -1118
    EMPTY_ORG_CL_ORD_ID = -1119
    BAD_INTERVAL = -1120
    BAD_SYMBOL = -1121
    INVALID_SYMBOL_STATUS = -1122
    INVALID_LISTEN_KEY = -1125
    ASSET_NOT_SUPPORTED = -1126
    MORE_THAN_XX_HOURS = -1127
    OPTIONAL_PARAMS_BAD_COMBO = -1128
    ORDER_AMEND_KEEP_PRIORITY_FAILED = -2038
    ORDER_QUERY_DUAL_ID_NOT_FOUND = -2039
    INVALID_PARAMETER = -1130
    INVALID_NEW_ORDER_RESP_TYPE = -1136
    INVALID_CALLBACK_RATE = -2007
    NEW_ORDER_REJECTED = -2010
    CANCEL_REJECTED = -2011
    CANCEL_ALL_FAIL = -2012
    NO_SUCH_ORDER = -2013
    BAD_API_KEY_FMT = -2014
    REJECTED_MBX_KEY = -2015
    NO_TRADING_WINDOW = -2016
    API_KEYS_LOCKED = -2017
    BALANCE_NOT_SUFFICIENT = -2018
    MARGIN_NOT_SUFFICIENT = -2019
    UNABLE_TO_FILL = -2020
    ORDER_WOULD_IMMEDIATELY_TRIGGER = -2021
    REDUCE_ONLY_REJECT = -2022
    USER_IN_LIQUIDATION = -2023
    POSITION_NOT_SUFFICIENT = -2024
    MAX_OPEN_ORDER_EXCEEDED = -2025
    REDUCE_ONLY_ORDER_TYPE_NOT_SUPPORTED = -2026
    MAX_LEVERAGE_RATIO = -2027
    MIN_LEVERAGE_RATIO = -2028
    INVALID_ORDER_STATUS = -4000
    PRICE_LESS_THAN_ZERO = -4001
    PRICE_GREATER_THAN_MAX_PRICE = -4002
    QTY_LESS_THAN_ZERO = -4003
    QTY_LESS_THAN_MIN_QTY = -4004
    QTY_GREATER_THAN_MAX_QTY = -4005
    STOP_PRICE_LESS_THAN_ZERO = -4006
    STOP_PRICE_GREATER_THAN_MAX_PRICE = -4007
    TICK_SIZE_LESS_THAN_ZERO = -4008
    MAX_PRICE_LESS_THAN_MIN_PRICE = -4009
    MAX_QTY_LESS_THAN_MIN_QTY = -4010
    STEP_SIZE_LESS_THAN_ZERO = -4011
    MAX_NUM_ORDERS_LESS_THAN_ZERO = -4012
    PRICE_LESS_THAN_MIN_PRICE = -4013
    PRICE_NOT_INCREASED_BY_TICK_SIZE = -4014
    INVALID_CL_ORD_ID_LEN = -4015
    PRICE_HIGHTER_THAN_MULTIPLIER_UP = -4016  # Binance's official typo (should be HIGHER)
    MULTIPLIER_UP_LESS_THAN_ZERO = -4017
    MULTIPLIER_DOWN_LESS_THAN_ZERO = -4018
    COMPOSITE_SCALE_OVERFLOW = -4019
    TARGET_STRATEGY_INVALID = -4020
    INVALID_DEPTH_LIMIT = -4021
    WRONG_MARKET_STATUS = -4022
    QTY_NOT_INCREASED_BY_STEP_SIZE = -4023
    PRICE_LOWER_THAN_MULTIPLIER_DOWN = -4024
    MULTIPLIER_DECIMAL_LESS_THAN_ZERO = -4025
    COMMISSION_INVALID = -4026
    INVALID_ACCOUNT_TYPE = -4027
    INVALID_LEVERAGE = -4028
    INVALID_TICK_SIZE_PRECISION = -4029
    INVALID_STEP_SIZE_PRECISION = -4030
    INVALID_WORKING_TYPE = -4031
    EXCEED_MAX_CANCEL_ORDER_SIZE = -4032
    INSURANCE_ACCOUNT_NOT_FOUND = -4033
    INVALID_BALANCE_TYPE = -4044
    MAX_STOP_ORDER_EXCEEDED = -4045
    NO_NEED_TO_CHANGE_MARGIN_TYPE = -4046
    THERE_EXISTS_OPEN_ORDERS = -4047
    THERE_EXISTS_QUANTITY = -4048
    ADD_ISOLATED_MARGIN_REJECT = -4049
    CROSS_BALANCE_INSUFFICIENT = -4050
    ISOLATED_BALANCE_INSUFFICIENT = -4051
    NO_NEED_TO_CHANGE_AUTO_ADD_MARGIN = -4052
    AUTO_ADD_CROSSED_MARGIN_REJECT = -4053
    ADD_ISOLATED_MARGIN_NO_POSITION_REJECT = -4054
    AMOUNT_MUST_BE_POSITIVE = -4055
    INVALID_API_KEY_TYPE = -4056
    INVALID_RSA_PUBLIC_KEY = -4057
    MAX_PRICE_TOO_LARGE = -4058
    NO_NEED_TO_CHANGE_POSITION_SIDE = -4059
    INVALID_POSITION_SIDE = -4060
    POSITION_SIDE_NOT_MATCH = -4061
    REDUCE_ONLY_CONFLICT = -4062
    INVALID_OPTIONS_REQUEST_TYPE = -4063
    INVALID_OPTIONS_TIME_FRAME = -4064
    INVALID_OPTIONS_AMOUNT = -4065
    INVALID_OPTIONS_EVENT_TYPE = -4066
    POSITION_SIDE_CHANGE_EXISTS_OPEN_ORDERS = -4067
    POSITION_SIDE_CHANGE_EXISTS_QUANTITY = -4068
    INVALID_OPTIONS_PREMIUM_FEE = -4069
    INVALID_CL_OPTIONS_ID_LEN = -4070
    INVALID_OPTIONS_DIRECTION = -4071
    OPTIONS_PREMIUM_NOT_UPDATE = -4072
    OPTIONS_PREMIUM_INPUT_LESS_THAN_ZERO = -4073
    OPTIONS_AMOUNT_BIGGER_THAN_UPPER = -4074
    OPTIONS_PREMIUM_OUTPUT_ZERO = -4075
    OPTIONS_PREMIUM_TOO_DIFF = -4076
    OPTIONS_PREMIUM_REACH_LIMIT = -4077
    OPTIONS_COMMON_ERROR = -4078
    INVALID_OPTIONS_ID = -4079
    OPTIONS_USER_NOT_FOUND = -4080
    OPTIONS_NOT_FOUND = -4081
    INVALID_BATCH_PLACE_ORDER_SIZE = -4082
    PLACE_BATCH_ORDERS_FAIL = -4083
    UPCOMING_METHOD = -4084
    INVALID_NOTIONAL_LIMIT_COEF = -4085
    INVALID_PRICE_SPREAD_THRESHOLD = -4086
    REDUCE_ONLY_ORDER_PERMISSION = -4087
    NO_PLACE_ORDER_PERMISSION = -4088
    INVALID_CONTRACT_TYPE = -4104
    INVALID_CLIENT_TRAN_ID_LEN = -4114
    DUPLICATED_CLIENT_TRAN_ID = -4115
    REDUCE_ONLY_MARGIN_CHECK_FAILED = -4118
    MARKET_ORDER_REJECT = -4131
    INVALID_ACTIVATION_PRICE = -4135
    QUANTITY_EXISTS_WITH_CLOSE_POSITION = -4137
    REDUCE_ONLY_MUST_BE_TRUE = -4138
    ORDER_TYPE_CANNOT_BE_MKT = -4139
    INVALID_OPENING_POSITION_STATUS = -4140
    SYMBOL_ALREADY_CLOSED = -4141
    STRATEGY_INVALID_TRIGGER_PRICE = -4142
    INVALID_PAIR = -4144
    ISOLATED_LEVERAGE_REJECT_WITH_POSITION = -4161
    MIN_NOTIONAL = -4164
    INVALID_TIME_INTERVAL = -4165
    ISOLATED_REJECT_WITH_JOINT_MARGIN = -4167
    JOINT_MARGIN_REJECT_WITH_ISOLATED = -4168
    JOINT_MARGIN_REJECT_WITH_MB = -4169
    JOINT_MARGIN_REJECT_WITH_OPEN_ORDER = -4170
    NO_NEED_TO_CHANGE_JOINT_MARGIN = -4171
    JOINT_MARGIN_REJECT_WITH_NEGATIVE_BALANCE = -4172
    ISOLATED_REJECT_WITH_JOINT_MARGIN_2 = -4183
    PRICE_LOWER_THAN_STOP_MULTIPLIER_DOWN = -4184
    COOLING_OFF_PERIOD = -4192
    ADJUST_LEVERAGE_KYC_FAILED = -4202
    ADJUST_LEVERAGE_ONE_MONTH_FAILED = -4203
    ADJUST_LEVERAGE_X_DAYS_FAILED = -4205
    ADJUST_LEVERAGE_KYC_LIMIT = -4206
    ADJUST_LEVERAGE_ACCOUNT_SYMBOL_FAILED = -4208
    ADJUST_LEVERAGE_SYMBOL_FAILED = -4209
    STOP_PRICE_HIGHER_THAN_PRICE_MULTIPLIER_LIMIT = -4210
    STOP_PRICE_LOWER_THAN_PRICE_MULTIPLIER_LIMIT = -4211
    TRADING_QUANTITATIVE_RULE = -4400
    COMPLIANCE_RESTRICTION = -4401
    COMPLIANCE_BLACK_SYMBOL_RESTRICTION = -4402
    ADJUST_LEVERAGE_COMPLIANCE_FAILED = -4403
    INVALID_PEG_OFFSET_TYPE = 1211
    FOK_ORDER_REJECT = -5021
    GTX_ORDER_REJECT = -5022
    MOVE_ORDER_NOT_ALLOWED_SYMBOL_REASON = -5024
    LIMIT_ORDER_ONLY = 5025
    EXCEED_MAXIMUM_MODIFY_ORDER_LIMIT = -5026
    SAME_ORDER = -5027
    ME_RECVWINDOW_REJECT = -5028
    INVALID_GOOD_TILL_DATE = -5040
class BinanceEnumParser:
    """
    Provides common parsing methods for enums used by the 'Binance' exchange.
    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """
    def __init__(self) -> None:
        # Construct dictionary hashmaps
        self.ext_to_int_status = {
            BinanceOrderStatus.NEW: OrderStatus.ACCEPTED,
            BinanceOrderStatus.CANCELED: OrderStatus.CANCELED,
            BinanceOrderStatus.PENDING_CANCEL: OrderStatus.PENDING_CANCEL,
            BinanceOrderStatus.REJECTED: OrderStatus.REJECTED,
            BinanceOrderStatus.PARTIALLY_FILLED: OrderStatus.PARTIALLY_FILLED,
            BinanceOrderStatus.FILLED: OrderStatus.FILLED,
            BinanceOrderStatus.NEW_ADL: OrderStatus.FILLED,
            BinanceOrderStatus.NEW_INSURANCE: OrderStatus.FILLED,
            BinanceOrderStatus.EXPIRED: OrderStatus.EXPIRED,
            BinanceOrderStatus.EXPIRED_IN_MATCH: OrderStatus.CANCELED,  # Canceled due self-trade prevention (STP)
        }
        self.ext_to_int_order_side = {
            BinanceOrderSide.BUY: OrderSide.BUY,
            BinanceOrderSide.SELL: OrderSide.SELL,
        }
        self.int_to_ext_order_side = {b: a for a, b in self.ext_to_int_order_side.items()}
        self.ext_to_int_bar_agg = {
            "s": BarAggregation.SECOND,
            "m": BarAggregation.MINUTE,
            "h": BarAggregation.HOUR,
            "d": BarAggregation.DAY,
            "w": BarAggregation.WEEK,
            "M": BarAggregation.MONTH,
        }
        self.int_to_ext_bar_agg = {b: a for a, b in self.ext_to_int_bar_agg.items()}
        self.ext_to_int_time_in_force = {
            BinanceTimeInForce.FOK: TimeInForce.FOK,
            BinanceTimeInForce.GTC: TimeInForce.GTC,
            BinanceTimeInForce.GTX: TimeInForce.GTC,  # Convert GTX to GTC
            BinanceTimeInForce.GTE_GTC: TimeInForce.GTC,  # Undocumented
            BinanceTimeInForce.IOC: TimeInForce.IOC,
            BinanceTimeInForce.GTD: TimeInForce.GTD,
        }
        self.int_to_ext_time_in_force = {
            TimeInForce.GTC: BinanceTimeInForce.GTC,
            TimeInForce.GTD: BinanceTimeInForce.GTD,
            TimeInForce.FOK: BinanceTimeInForce.FOK,
            TimeInForce.IOC: BinanceTimeInForce.IOC,
        }
    def parse_binance_order_side(self, order_side: BinanceOrderSide) -> OrderSide:
        try:
            return self.ext_to_int_order_side[order_side]
        except KeyError:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"unrecognized Binance order side, was {order_side}",  # pragma: no cover
            )
    def parse_internal_order_side(self, order_side: OrderSide) -> BinanceOrderSide:
        try:
            return self.int_to_ext_order_side[order_side]
        except KeyError:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"unrecognized Nautilus order side, was {order_side}",  # pragma: no cover
            )
    def parse_binance_time_in_force(self, time_in_force: BinanceTimeInForce) -> TimeInForce:
        try:
            return self.ext_to_int_time_in_force[time_in_force]
        except KeyError:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"unrecognized Binance time in force, was {time_in_force}",  # pragma: no cover
            )
    def parse_internal_time_in_force(self, time_in_force: TimeInForce) -> BinanceTimeInForce:
        try:
            return self.int_to_ext_time_in_force[time_in_force]
        except KeyError:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"unrecognized Nautilus time in force, was {time_in_force}",  # pragma: no cover
            )
    def parse_binance_order_status(self, order_status: BinanceOrderStatus) -> OrderStatus:
        try:
            return self.ext_to_int_status[order_status]
        except KeyError:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"unrecognized binance order status, was {order_status}",  # pragma: no cover
            )
    def parse_binance_order_type(self, order_type: BinanceOrderType) -> OrderType:
        # Implement in child class
        raise NotImplementedError
    def parse_internal_order_type(self, order: Order) -> BinanceOrderType:
        # Implement in child class
        raise NotImplementedError
    def parse_binance_bar_agg(self, bar_agg: str) -> BarAggregation:
        try:
            return self.ext_to_int_bar_agg[bar_agg]
        except KeyError:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"unrecognized Binance kline resolution, was {bar_agg}",
            )
    def parse_nautilus_bar_aggregation(self, bar_agg: BarAggregation) -> str:
        try:
            return self.int_to_ext_bar_agg[bar_agg]
        except KeyError:
            raise RuntimeError(  # pragma: no cover (design-time error)
                "unrecognized or non-supported Nautilus BarAggregation,",
                f"was {bar_aggregation_to_str(bar_agg)}",  # pragma: no cover
            )
    def parse_binance_kline_interval_to_bar_spec(
        self,
        kline_interval: BinanceKlineInterval,
    ) -> BarSpecification:
        step = kline_interval.value[:-1]
        binance_bar_agg = kline_interval.value[-1]
        return BarSpecification(
            step=int(step),
            aggregation=self.parse_binance_bar_agg(binance_bar_agg),
            price_type=PriceType.LAST,
        )
    def parse_binance_trigger_type(self, trigger_type: str) -> TriggerType:
        # Replace method in child class, if compatible
        raise NotImplementedError(  # pragma: no cover (design-time error)
            "Cannot parse binance trigger type (not implemented).",  # pragma: no cover
        )
    def parse_position_id_to_binance_futures_position_side(
        self,
        position_id: PositionId,
    ) -> BinanceFuturesPositionSide:
        if position_id.value.endswith("LONG"):  # Position Long
            return BinanceFuturesPositionSide.LONG
        elif position_id.value.endswith("SHORT"):  # Position Short
            return BinanceFuturesPositionSide.SHORT
        elif position_id.value.endswith("BOTH"):
            return BinanceFuturesPositionSide.BOTH
        else:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"unrecognized position id, was {position_id}",  # pragma: no cover
            )
</document_content>
</document>
<document index="1737">
<source>nautilus_trader/adapters/binance/common/schemas/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="1738">
<source>nautilus_trader/adapters/binance/common/schemas/account.py</source>
<document_content>

from decimal import Decimal
import msgspec
################################################################################
# HTTP responses
################################################################################
class BinanceUserTrade(msgspec.Struct, frozen=True):
    """
    HTTP response from Binance Spot/Margin `GET /api/v3/myTrades` HTTP response from
    Binance USD-M Futures `GET /fapi/v1/userTrades` HTTP response from Binance COIN-M
    Futures `GET /dapi/v1/userTrades`.
    """
    commission: str
    commissionAsset: str
    price: str
    qty: str
    # Parameters not present in 'fills' list (see FULL response of BinanceOrder)
    symbol: str | None = None
    id: int | None = None
    orderId: int | None = None
    time: int | None = None
    quoteQty: str | None = None  # SPOT/MARGIN & USD-M FUTURES only
    # Parameters in SPOT/MARGIN only:
    orderListId: int | None = None  # unless OCO, the value will always be -1
    isBuyer: bool | None = None
    isMaker: bool | None = None
    isBestMatch: bool | None = None
    tradeId: int | None = None  # only in BinanceOrder FULL response
    # Parameters in FUTURES only:
    buyer: bool | None = None
    maker: bool | None = None
    realizedPnl: str | None = None
    side: BinanceOrderSide | None = None
    positionSide: str | None = None
    baseQty: str | None = None  # COIN-M FUTURES only
    pair: str | None = None  # COIN-M FUTURES only
    def parse_to_fill_report(
        self,
        account_id: AccountId,
        instrument_id: InstrumentId,
        report_id: UUID4,
        ts_init: int,
        use_position_ids: bool = True,
    ) -> FillReport:
        venue_position_id: PositionId | None = None
        if self.positionSide is not None and use_position_ids:
            venue_position_id = PositionId(f"{instrument_id}-{self.positionSide}")
        order_side = OrderSide.BUY if self.isBuyer or self.buyer else OrderSide.SELL
        liquidity_side = LiquiditySide.MAKER if self.isMaker or self.maker else LiquiditySide.TAKER
        return FillReport(
            account_id=account_id,
            instrument_id=instrument_id,
            venue_order_id=VenueOrderId(str(self.orderId)),
            venue_position_id=venue_position_id,
            trade_id=TradeId(str(self.id)),
            order_side=order_side,
            last_qty=Quantity.from_str(self.qty),
            last_px=Price.from_str(self.price),
            commission=Money(self.commission, Currency.from_str(self.commissionAsset)),
            liquidity_side=liquidity_side,
            ts_event=millis_to_nanos(self.time),
            report_id=report_id,
            ts_init=ts_init,
        )
class BinanceOrder(msgspec.Struct, frozen=True):
    """
    HTTP response from Binance Spot/Margin `GET /api/v3/order` HTTP response from
    Binance USD-M Futures `GET /fapi/v1/order` HTTP response from Binance COIN-M Futures
    `GET /dapi/v1/order`.
    """
    symbol: str
    orderId: int
    clientOrderId: str
    # Parameters not in ACK response:
    price: str | None = None
    origQty: str | None = None
    executedQty: str | None = None
    status: BinanceOrderStatus | None = None
    timeInForce: BinanceTimeInForce | None = None
    goodTillDate: int | None = None
    type: BinanceOrderType | None = None
    side: BinanceOrderSide | None = None
    stopPrice: str | None = None  # please ignore when order type is TRAILING_STOP_MARKET
    time: int | None = None
    updateTime: int | None = None
    # Parameters in SPOT/MARGIN only:
    orderListId: int | None = None  # Unless OCO, the value will always be -1
    cumulativeQuoteQty: str | None = None  # cumulative quote qty
    icebergQty: str | None = None
    isWorking: bool | None = None
    workingTime: int | None = None
    origQuoteOrderQty: str | None = None
    selfTradePreventionMode: str | None = None
    transactTime: int | None = None  # POST & DELETE methods only
    fills: list[BinanceUserTrade] | None = None  # FULL response only
    # Parameters in FUTURES only:
    avgPrice: str | None = None
    origType: BinanceOrderType | None = None
    reduceOnly: bool | None = None
    positionSide: str | None = None
    closePosition: bool | None = None
    activatePrice: str | None = None  # activation price, only for TRAILING_STOP_MARKET order
    priceRate: str | None = None  # callback rate, only for TRAILING_STOP_MARKET order
    workingType: str | None = None
    priceProtect: bool | None = None  # if conditional order trigger is protected
    cumQuote: str | None = None  # USD-M FUTURES only
    cumBase: str | None = None  # COIN-M FUTURES only
    pair: str | None = None  # COIN-M FUTURES only
    def parse_to_order_status_report(
        self,
        account_id: AccountId,
        instrument_id: InstrumentId,
        report_id: UUID4,
        enum_parser: BinanceEnumParser,
        treat_expired_as_canceled: bool,
        ts_init: int,
    ) -> OrderStatusReport:
        if self.price is None:
            raise RuntimeError(
                "Cannot generate order status report from Binance ACK response.",
            )
        client_order_id = ClientOrderId(self.clientOrderId) if self.clientOrderId != "" else None
        order_list_id = OrderListId(str(self.orderListId)) if self.orderListId is not None else None
        contingency_type = (
            ContingencyType.OCO
            if self.orderListId is not None and self.orderListId != -1
            else ContingencyType.NO_CONTINGENCY
        )
        trigger_price = Decimal(self.stopPrice) if self.stopPrice is not None else Decimal()
        trigger_type = TriggerType.NO_TRIGGER
        if self.workingType is not None:
            trigger_type = enum_parser.parse_binance_trigger_type(self.workingType)
        elif trigger_price > 0:
            trigger_type = TriggerType.LAST_PRICE
        trailing_offset = None
        trailing_offset_type = TrailingOffsetType.NO_TRAILING_OFFSET
        if self.priceRate is not None:
            trailing_offset = Decimal(self.priceRate)
            trailing_offset_type = TrailingOffsetType.BASIS_POINTS
        avg_px = Decimal(self.avgPrice) if self.avgPrice is not None else None
        post_only = (
            self.type == BinanceOrderType.LIMIT_MAKER or self.timeInForce == BinanceTimeInForce.GTX
        )
        reduce_only = self.reduceOnly if self.reduceOnly is not None else False
        if self.side is None:
            raise ValueError("`side` was `None` when a value was expected")
        if self.type is None:
            raise ValueError("`type` was `None` when a value was expected")
        if self.timeInForce is None:
            raise ValueError("`timeInForce` was `None` when a value was expected")
        if self.status is None:
            raise ValueError("`status` was `None` when a value was expected")
        order_status = enum_parser.parse_binance_order_status(self.status)
        if treat_expired_as_canceled and order_status == OrderStatus.EXPIRED:
            order_status = OrderStatus.CANCELED
        return OrderStatusReport(
            account_id=account_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            order_list_id=order_list_id,
            venue_order_id=VenueOrderId(str(self.orderId)),
            order_side=enum_parser.parse_binance_order_side(self.side),
            order_type=enum_parser.parse_binance_order_type(self.type),
            contingency_type=contingency_type,
            time_in_force=(
                enum_parser.parse_binance_time_in_force(self.timeInForce)
                if self.timeInForce
                else None
            ),
            order_status=order_status,
            price=Price.from_str(self.price),
            trigger_price=Price.from_str(str(trigger_price)),  # `decimal.Decimal`
            trigger_type=trigger_type,
            trailing_offset=trailing_offset,
            trailing_offset_type=trailing_offset_type,
            quantity=Quantity.from_str(self.origQty),
            filled_qty=Quantity.from_str(self.executedQty),
            avg_px=avg_px,
            post_only=post_only,
            reduce_only=reduce_only,
            ts_accepted=millis_to_nanos(self.time),
            ts_last=millis_to_nanos(self.updateTime),
            report_id=report_id,
            ts_init=ts_init,
        )
class BinanceStatusCode(msgspec.Struct, frozen=True):
    """
    HTTP response status code.
    """
    code: int
    msg: str
</document_content>
</document>
<document index="1739">
<source>nautilus_trader/adapters/binance/common/schemas/market.py</source>
<document_content>

from decimal import Decimal
import msgspec
################################################################################
# HTTP responses
################################################################################
class BinanceTime(msgspec.Struct, frozen=True):
    """
    Schema of current server time GET response of `time`
    """
    serverTime: int
class BinanceExchangeFilter(msgspec.Struct):
    """
    Schema of an exchange filter, within response of GET `exchangeInfo.`
    """
    filterType: BinanceExchangeFilterType
    maxNumOrders: int | None = None
    maxNumAlgoOrders: int | None = None
class BinanceRateLimit(msgspec.Struct):
    """
    Schema of rate limit info, within response of GET `exchangeInfo.`
    """
    rateLimitType: BinanceRateLimitType
    interval: BinanceRateLimitInterval
    intervalNum: int
    limit: int
    count: int | None = None  # SPOT/MARGIN rateLimit/order response only
class BinanceSymbolFilter(msgspec.Struct):
    """
    Schema of a symbol filter, within response of GET `exchangeInfo.`
    """
    filterType: BinanceSymbolFilterType
    minPrice: str | None = None
    maxPrice: str | None = None
    tickSize: str | None = None
    multiplierUp: str | None = None
    multiplierDown: str | None = None
    multiplierDecimal: str | None = None
    avgPriceMins: int | None = None
    minQty: str | None = None
    maxQty: str | None = None
    stepSize: str | None = None
    limit: int | None = None
    maxNumOrders: int | None = None
    notional: str | None = None  # SPOT/MARGIN & USD-M FUTURES only
    minNotional: str | None = None  # SPOT/MARGIN & USD-M FUTURES only
    maxNumAlgoOrders: int | None = None  # SPOT/MARGIN & USD-M FUTURES only
    bidMultiplierUp: str | None = None  # SPOT/MARGIN only
    bidMultiplierDown: str | None = None  # SPOT/MARGIN only
    askMultiplierUp: str | None = None  # SPOT/MARGIN only
    askMultiplierDown: str | None = None  # SPOT/MARGIN only
    applyMinToMarket: bool | None = None  # SPOT/MARGIN only
    maxNotional: str | None = None  # SPOT/MARGIN only
    applyMaxToMarket: bool | None = None  # SPOT/MARGIN only
    maxNumIcebergOrders: int | None = None  # SPOT/MARGIN only
    maxPosition: str | None = None  # SPOT/MARGIN only
    minTrailingAboveDelta: int | None = None  # SPOT/MARGIN only
    maxTrailingAboveDelta: int | None = None  # SPOT/MARGIN only
    minTrailingBelowDelta: int | None = None  # SPOT/MARGIN only
    maxTrailingBelowDelta: int | None = None  # SPOT/MARGIN only
class BinanceDepth(msgspec.Struct, frozen=True):
    """
    Schema of a binance orderbook depth.
    GET response of `depth`.
    """
    lastUpdateId: int
    bids: list[tuple[str, str]]
    asks: list[tuple[str, str]]
    symbol: str | None = None  # COIN-M FUTURES only
    pair: str | None = None  # COIN-M FUTURES only
    E: int | None = None  # FUTURES only, Message output time
    T: int | None = None  # FUTURES only, Transaction time
    def parse_to_order_book_snapshot(
        self,
        instrument_id: InstrumentId,
        ts_init: int,
    ) -> OrderBookDeltas:
        bids = [
            BookOrder(OrderSide.BUY, Price.from_str(o[0]), Quantity.from_str(o[1]), 0)
            for o in self.bids or []
        ]
        asks = [
            BookOrder(OrderSide.SELL, Price.from_str(o[0]), Quantity.from_str(o[1]), 0)
            for o in self.asks or []
        ]
        deltas = [OrderBookDelta.clear(instrument_id, self.lastUpdateId, ts_init, ts_init)]
        deltas += [
            OrderBookDelta(
                instrument_id,
                BookAction.ADD,
                o,
                flags=0,
                sequence=self.lastUpdateId or 0,
                ts_event=ts_init,  # No event timestamp
                ts_init=ts_init,
            )
            for o in bids + asks
        ]
        return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
class BinanceTrade(msgspec.Struct, frozen=True):
    """
    Schema of a single trade.
    """
    id: int
    price: str
    qty: str
    quoteQty: str
    time: int
    isBuyerMaker: bool
    isBestMatch: bool | None = None  # SPOT/MARGIN only
    def parse_to_trade_tick(
        self,
        instrument_id: InstrumentId,
        ts_init: int | None = None,
    ) -> TradeTick:
        """
        Parse Binance trade to internal TradeTick.
        """
        ts_event = millis_to_nanos(self.time)
        return TradeTick(
            instrument_id=instrument_id,
            price=Price.from_str(self.price),
            size=Quantity.from_str(self.qty),
            aggressor_side=AggressorSide.SELLER if self.isBuyerMaker else AggressorSide.BUYER,
            trade_id=TradeId(str(self.id)),
            ts_event=ts_event,
            ts_init=(ts_init or ts_event),
        )
class BinanceAggTrade(msgspec.Struct, frozen=True):
    """
    Schema of a single compressed aggregate trade.
    """
    a: int  # Aggregate tradeId
    p: str  # Price
    q: str  # Quantity
    f: int  # First tradeId
    l: int  # Last tradeId
    T: int  # Timestamp
    m: bool  # Was the buyer the maker?
    M: bool | None = None  # SPOT/MARGIN only, was the trade the best price match?
    def parse_to_trade_tick(
        self,
        instrument_id: InstrumentId,
        ts_init: int | None = None,
    ) -> TradeTick:
        """
        Parse Binance trade to internal TradeTick.
        """
        ts_event = millis_to_nanos(self.T)
        return TradeTick(
            instrument_id=instrument_id,
            price=Price.from_str(self.p),
            size=Quantity.from_str(self.q),
            aggressor_side=AggressorSide.SELLER if self.m else AggressorSide.BUYER,
            trade_id=TradeId(str(self.a)),
            ts_event=ts_event,
            ts_init=(ts_init or ts_event),
        )
class BinanceKline(msgspec.Struct, array_like=True):
    """
    Array-like schema of single Binance kline.
    """
    open_time: int
    open: str
    high: str
    low: str
    close: str
    volume: str
    close_time: int
    asset_volume: str
    trades_count: int
    taker_base_volume: str
    taker_quote_volume: str
    ignore: str
    def parse_to_binance_bar(
        self,
        bar_type: BarType,
        ts_init: int | None = None,
    ) -> BinanceBar:
        """
        Parse kline to BinanceBar.
        """
        ts_event = millis_to_nanos(self.close_time)
        return BinanceBar(
            bar_type=bar_type,
            open=Price.from_str(self.open),
            high=Price.from_str(self.high),
            low=Price.from_str(self.low),
            close=Price.from_str(self.close),
            volume=Quantity.from_str(self.volume),
            quote_volume=Decimal(self.asset_volume),
            count=self.trades_count,
            taker_buy_base_volume=Decimal(self.taker_base_volume),
            taker_buy_quote_volume=Decimal(self.taker_quote_volume),
            ts_event=ts_event,
            ts_init=(ts_init or ts_event),
        )
class BinanceTicker24hr(msgspec.Struct, frozen=True):
    """
    Schema of single Binance 24hr ticker (FULL/MINI).
    """
    symbol: str | None
    lastPrice: str | None
    openPrice: str | None
    highPrice: str | None
    lowPrice: str | None
    volume: str | None
    openTime: int | None
    closeTime: int | None
    firstId: int | None
    lastId: int | None
    count: int | None
    priceChange: str | None = None  # FULL response only (SPOT/MARGIN)
    priceChangePercent: str | None = None  # FULL response only (SPOT/MARGIN)
    weightedAvgPrice: str | None = None  # FULL response only (SPOT/MARGIN)
    lastQty: str | None = None  # FULL response only (SPOT/MARGIN)
    prevClosePrice: str | None = None  # SPOT/MARGIN only
    bidPrice: str | None = None  # SPOT/MARGIN only
    bidQty: str | None = None  # SPOT/MARGIN only
    askPrice: str | None = None  # SPOT/MARGIN only
    askQty: str | None = None  # SPOT/MARGIN only
    pair: str | None = None  # COIN-M FUTURES only
    baseVolume: str | None = None  # COIN-M FUTURES only
    quoteVolume: str | None = None  # SPOT/MARGIN & USD-M FUTURES only
class BinanceTickerPrice(msgspec.Struct, frozen=True):
    """
    Schema of single Binance Price Ticker.
    """
    symbol: str | None
    price: str | None
    time: int | None = None  # FUTURES only
    pair: str | None = None  # USDT-M FUTURES only (v2 endpoint)
    ps: str | None = None  # COIN-M FUTURES only, pair
class BinanceTickerBook(msgspec.Struct, frozen=True):
    """
    Schema of a single Binance Order Book Ticker.
    """
    symbol: str | None
    bidPrice: str | None
    bidQty: str | None
    askPrice: str | None
    askQty: str | None
    pair: str | None = None  # USD-M FUTURES only
    time: int | None = None  # FUTURES only, transaction time
################################################################################
# WebSocket messages
################################################################################
class BinanceDataMsgWrapper(msgspec.Struct):
    """
    Provides a wrapper for data WebSocket messages from Binance.
    """
    stream: str | None = None
    id: int | None = None
class BinanceOrderBookDelta(msgspec.Struct, array_like=True):
    """
    Schema of single ask/bid delta.
    """
    price: str
    size: str
    def parse_to_order_book_delta(
        self,
        instrument_id: InstrumentId,
        side: OrderSide,
        flags: int,
        sequence: int,
        ts_event: int,
        ts_init: int,
    ) -> OrderBookDelta:
        size = Quantity.from_str(self.size)
        order = BookOrder(
            side=side,
            price=Price.from_str(self.price),
            size=Quantity.from_str(self.size),
            order_id=0,
        )
        return OrderBookDelta(
            instrument_id=instrument_id,
            action=BookAction.UPDATE if size > 0 else BookAction.DELETE,
            order=order,
            flags=flags,
            sequence=sequence,
            ts_event=ts_event,
            ts_init=ts_init,
        )
class BinanceOrderBookData(msgspec.Struct, frozen=True):
    """
    WebSocket message 'inner struct' for Binance Partial & Diff.
    Book Depth Streams.
    """
    e: str  # Event type
    E: int  # Event time
    s: str  # Symbol
    U: int  # First update ID in event
    u: int  # Final update ID in event
    b: list[BinanceOrderBookDelta]  # Bids to be updated
    a: list[BinanceOrderBookDelta]  # Asks to be updated
    T: int | None = None  # FUTURES only, transaction time
    pu: int | None = None  # FUTURES only, previous final update ID
    ps: str | None = None  # COIN-M FUTURES only, pair
    def parse_to_order_book_deltas(
        self,
        instrument_id: InstrumentId,
        ts_init: int,
        snapshot: bool = False,
    ) -> OrderBookDeltas:
        ts_event: int = millis_to_nanos(self.T) if self.T is not None else millis_to_nanos(self.E)
        deltas: list[OrderBookDelta] = []
        if snapshot:
            deltas.append(OrderBookDelta.clear(instrument_id, 0, ts_event, ts_init))
        bids_len = len(self.b)
        asks_len = len(self.a)
        for idx, bid in enumerate(self.b):
            flags = 0
            if idx == bids_len - 1 and asks_len == 0:
                # F_LAST, 1 << 7
                # Last message in the book event or packet from the venue for a given `instrument_id`
                flags = RecordFlag.F_LAST
            delta = bid.parse_to_order_book_delta(
                instrument_id=instrument_id,
                side=OrderSide.BUY,
                flags=RecordFlag.F_SNAPSHOT if snapshot else flags,
                sequence=self.u,
                ts_event=ts_event,
                ts_init=ts_init,
            )
            deltas.append(delta)
        for idx, ask in enumerate(self.a):
            flags = 0
            if idx == asks_len - 1:
                # F_LAST, 1 << 7
                # Last message in the book event or packet from the venue for a given `instrument_id`
                flags = RecordFlag.F_LAST
            delta = ask.parse_to_order_book_delta(
                instrument_id=instrument_id,
                side=OrderSide.SELL,
                flags=RecordFlag.F_SNAPSHOT if snapshot else flags,
                sequence=self.u,
                ts_event=ts_event,
                ts_init=ts_init,
            )
            deltas.append(delta)
        return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
class BinanceOrderBookMsg(msgspec.Struct, frozen=True):
    """
    WebSocket message from Binance Partial & Diff.
    Book Depth Streams.
    """
    stream: str
    data: BinanceOrderBookData
class BinanceQuoteData(msgspec.Struct, frozen=True):
    """
    WebSocket message from Binance Individual Symbol Book Ticker Streams.
    """
    s: str  # symbol
    u: int  # order book updateId
    b: str  # best bid price
    B: str  # best bid qty
    a: str  # best ask price
    A: str  # best ask qty
    T: int | None = None  # event time
    def parse_to_quote_tick(
        self,
        instrument_id: InstrumentId,
        ts_init: int | None = None,
    ) -> QuoteTick:
        ts_event = millis_to_nanos(self.T) if self.T else ts_init
        return QuoteTick(
            instrument_id=instrument_id,
            bid_price=Price.from_str(self.b),
            ask_price=Price.from_str(self.a),
            bid_size=Quantity.from_str(self.B),
            ask_size=Quantity.from_str(self.A),
            ts_event=ts_event,
            ts_init=(ts_init or ts_event),
        )
class BinanceQuoteMsg(msgspec.Struct, frozen=True):
    """
    WebSocket message from Binance Individual Symbol Book Ticker Streams.
    """
    stream: str
    data: BinanceQuoteData
class BinanceAggregatedTradeData(msgspec.Struct, frozen=True):
    """
    WebSocket message from Binance Aggregate Trade Streams.
    """
    e: str  # Event type
    E: int  # Event time
    s: str  # Symbol
    a: int  # Aggregate trade ID
    p: str  # Price
    q: str  # Quantity
    f: int  # First trade ID
    l: int  # Last trade ID
    T: int  # Trade time
    m: bool  # Is the buyer the market maker?
    def parse_to_trade_tick(
        self,
        instrument_id: InstrumentId,
        ts_init: int | None = None,
    ) -> TradeTick:
        ts_event = millis_to_nanos(self.T)
        return TradeTick(
            instrument_id=instrument_id,
            price=Price.from_str(self.p),
            size=Quantity.from_str(self.q),
            aggressor_side=AggressorSide.SELLER if self.m else AggressorSide.BUYER,
            trade_id=TradeId(str(self.a)),
            ts_event=ts_event,
            ts_init=(ts_init or ts_event),
        )
class BinanceAggregatedTradeMsg(msgspec.Struct, frozen=True):
    """
    WebSocket message.
    """
    stream: str
    data: BinanceAggregatedTradeData
class BinanceTickerData(msgspec.Struct, kw_only=True, frozen=True):
    """
    WebSocket message from Binance 24hr Ticker.
    Fields
    ------
    - e: Event type
    - E: Event time
    - s: Symbol
    - p: Price change
    - P: Price change percent
    - w: Weighted average price
    - x: Previous close price
    - c: Last price
    - Q: Last quantity
    - b: Best bid price
    - B: Best bid quantity
    - a: Best ask price
    - A: Best ask quantity
    - o: Open price
    - h: High price
    - l: Low price
    - v: Total traded base asset volume
    - q: Total traded quote asset volume
    - O: Statistics open time
    - C: Statistics close time
    - F: First trade ID
    - L: Last trade ID
    - n: Total number of trades
    """
    e: str  # Event type
    E: int  # Event time
    s: str  # Symbol
    p: str  # Price change
    P: str  # Price change percent
    w: str  # Weighted average price
    x: str | None = None  # First trade(F)-1 price (first trade before the 24hr rolling window)
    c: str  # Last price
    Q: str  # Last quantity
    b: str | None = None  # Best bid price
    B: str | None = None  # Best bid quantity
    a: str | None = None  # Best ask price
    A: str | None = None  # Best ask quantity
    o: str  # Open price
    h: str  # High price
    l: str  # Low price
    v: str  # Total traded base asset volume
    q: str  # Total traded quote asset volume
    O: int  # Statistics open time
    C: int  # Statistics close time
    F: int  # First trade ID
    L: int  # Last trade ID
    n: int  # Total number of trades
    def parse_to_binance_ticker(
        self,
        instrument_id: InstrumentId,
        ts_init: int,
    ) -> BinanceTicker:
        return BinanceTicker(
            instrument_id=instrument_id,
            price_change=Decimal(self.p),
            price_change_percent=Decimal(self.P),
            weighted_avg_price=Decimal(self.w),
            prev_close_price=Decimal(self.x) if self.x is not None else None,
            last_price=Decimal(self.c),
            last_qty=Decimal(self.Q),
            bid_price=Decimal(self.b) if self.b is not None else None,
            bid_qty=Decimal(self.B) if self.B is not None else None,
            ask_price=Decimal(self.a) if self.a is not None else None,
            ask_qty=Decimal(self.A) if self.A is not None else None,
            open_price=Decimal(self.o),
            high_price=Decimal(self.h),
            low_price=Decimal(self.l),
            volume=Decimal(self.v),
            quote_volume=Decimal(self.q),
            open_time_ms=self.O,
            close_time_ms=self.C,
            first_id=self.F,
            last_id=self.L,
            count=self.n,
            ts_event=millis_to_nanos(self.E),
            ts_init=ts_init,
        )
class BinanceTickerMsg(msgspec.Struct, frozen=True):
    """
    WebSocket message.
    """
    stream: str
    data: BinanceTickerData
class BinanceCandlestick(msgspec.Struct, frozen=True):
    """
    WebSocket message 'inner struct' for Binance Kline/Candlestick Streams.
    Fields
    ------
    - t: Kline start time
    - T: Kline close time
    - s: Symbol
    - i: Interval
    - f: First trade ID
    - L: Last trade ID
    - o: Open price
    - c: Close price
    - h: High price
    - l: Low price
    - v: Base asset volume
    - n: Number of trades
    - x: Is this kline closed?
    - q: Quote asset volume
    - V: Taker buy base asset volume
    - Q: Taker buy quote asset volume
    - B: Ignore
    """
    t: int  # Kline start time
    T: int  # Kline close time
    s: str  # Symbol
    i: BinanceKlineInterval  # Interval
    f: int  # First trade ID
    L: int  # Last trade ID
    o: str  # Open price
    c: str  # Close price
    h: str  # High price
    l: str  # Low price
    v: str  # Base asset volume
    n: int  # Number of trades
    x: bool  # Is this kline closed?
    q: str  # Quote asset volume
    V: str  # Taker buy base asset volume
    Q: str  # Taker buy quote asset volume
    B: str  # Ignore
    def parse_to_binance_bar(
        self,
        instrument_id: InstrumentId,
        enum_parser: BinanceEnumParser,
        ts_init: int | None = None,
    ) -> BinanceBar:
        bar_type = BarType(
            instrument_id=instrument_id,
            bar_spec=enum_parser.parse_binance_kline_interval_to_bar_spec(self.i),
            aggregation_source=AggregationSource.EXTERNAL,
        )
        ts_event = millis_to_nanos(self.T)
        return BinanceBar(
            bar_type=bar_type,
            open=Price.from_str(self.o),
            high=Price.from_str(self.h),
            low=Price.from_str(self.l),
            close=Price.from_str(self.c),
            volume=Quantity.from_str(self.v),
            quote_volume=Decimal(self.q),
            count=self.n,
            taker_buy_base_volume=Decimal(self.V),
            taker_buy_quote_volume=Decimal(self.Q),
            ts_event=ts_event,
            ts_init=(ts_init or ts_event),
        )
class BinanceCandlestickData(msgspec.Struct, frozen=True):
    """
    WebSocket message 'inner struct'.
    """
    e: str
    E: int
    s: str
    k: BinanceCandlestick
class BinanceCandlestickMsg(msgspec.Struct, frozen=True):
    """
    WebSocket message for Binance Kline/Candlestick Streams.
    """
    stream: str
    data: BinanceCandlestickData
</document_content>
</document>
<document index="1740">
<source>nautilus_trader/adapters/binance/common/schemas/user.py</source>
<document_content>

import msgspec
################################################################################
# HTTP responses
################################################################################
class BinanceListenKey(msgspec.Struct):
    """
    HTTP response from creating a new Binance user listen key.
    """
    listenKey: str
</document_content>
</document>
<document index="1741">
<source>nautilus_trader/adapters/binance/common/symbol.py</source>
<document_content>

from __future__ import annotations
import json
################################################################################
# HTTP responses
################################################################################
class BinanceSymbol(str):
    """
    Binance compatible symbol.
    """
    def __new__(cls, symbol: str) -> BinanceSymbol:  # noqa: PYI034
        PyCondition.valid_string(symbol, "symbol")
        # Format the string on construction to be Binance compatible
        return super().__new__(
            cls,
            symbol.upper().replace(" ", "").replace("/", "").replace("-PERP", ""),
        )
    def parse_as_nautilus(self, account_type: BinanceAccountType) -> str:
        if account_type.is_spot_or_margin:
            return str(self)
        # Parse Futures symbol
        if self[-1].isdigit():
            return str(self)  # Deliverable
        if self.endswith("_PERP"):
            return str(self).replace("_", "-")
        else:
            return str(self) + "-PERP"
class BinanceSymbols(str):
    """
    Binance compatible list of symbols.
    """
    def __new__(cls, symbols: list[str]) -> BinanceSymbols:  # noqa: PYI034
        PyCondition.not_empty(symbols, "symbols")
        binance_symbols: list[BinanceSymbol] = [BinanceSymbol(symbol) for symbol in symbols]
        return super().__new__(cls, json.dumps(binance_symbols).replace(" ", ""))
    def parse_str_to_list(self) -> list[BinanceSymbol]:
        binance_symbols: list[BinanceSymbol] = json.loads(self)
        return binance_symbols
</document_content>
</document>
<document index="1742">
<source>nautilus_trader/adapters/binance/common/types.py</source>
<document_content>

from __future__ import annotations
from decimal import Decimal
from typing import Any
class BinanceBar(Bar):
    """
    Represents an aggregated Binance bar.
    This data type includes the raw data provided by Binance.
    Parameters
    ----------
    bar_type : BarType
        The bar type for this bar.
    open : Price
        The bars open price.
    high : Price
        The bars high price.
    low : Price
        The bars low price.
    close : Price
        The bars close price.
    volume : Quantity
        The bars volume.
    quote_volume : Decimal
        The bars quote asset volume.
    count : int
        The number of trades for the bar.
    taker_buy_base_volume : Decimal
        The liquidity taker volume on the buy side for the base asset.
    taker_buy_quote_volume : Decimal
        The liquidity taker volume on the buy side for the quote asset.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#kline-candlestick-data
    https://binance-docs.github.io/apidocs/futures/en/#kline-candlestick-data
    """
    def __init__(
        self,
        bar_type: BarType,
        open: Price,
        high: Price,
        low: Price,
        close: Price,
        volume: Quantity,
        quote_volume: Decimal,
        count: int,
        taker_buy_base_volume: Decimal,
        taker_buy_quote_volume: Decimal,
        ts_event: int,
        ts_init: int,
    ) -> None:
        super().__init__(
            bar_type=bar_type,
            open=open,
            high=high,
            low=low,
            close=close,
            volume=volume,
            ts_event=ts_event,
            ts_init=ts_init,
        )
        self.quote_volume = quote_volume
        self.count = count
        self.taker_buy_base_volume = taker_buy_base_volume
        self.taker_buy_quote_volume = taker_buy_quote_volume
        self.taker_sell_base_volume = self.volume - self.taker_buy_base_volume
        self.taker_sell_quote_volume = self.quote_volume - self.taker_buy_quote_volume
    def __getstate__(self):
        return (
            *super().__getstate__(),
            str(self.quote_volume),
            self.count,
            str(self.taker_buy_base_volume),
            str(self.taker_buy_quote_volume),
            str(self.taker_sell_base_volume),
            str(self.taker_sell_quote_volume),
        )
    def __setstate__(self, state):
        super().__setstate__(state[:14])
        self.quote_volume = Decimal(state[14])
        self.count = state[15]
        self.taker_buy_base_volume = Decimal(state[16])
        self.taker_buy_quote_volume = Decimal(state[17])
        self.taker_sell_base_volume = Decimal(state[18])
        self.taker_sell_quote_volume = Decimal(state[19])
    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"bar_type={self.bar_type}, "
            f"open={self.open}, "
            f"high={self.high}, "
            f"low={self.low}, "
            f"close={self.close}, "
            f"volume={self.volume}, "
            f"quote_volume={self.quote_volume}, "
            f"count={self.count}, "
            f"taker_buy_base_volume={self.taker_buy_base_volume}, "
            f"taker_buy_quote_volume={self.taker_buy_quote_volume}, "
            f"taker_sell_base_volume={self.taker_sell_base_volume}, "
            f"taker_sell_quote_volume={self.taker_sell_quote_volume}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )
    @staticmethod
    def from_dict(values: dict[str, Any]) -> BinanceBar:
        """
        Return a Binance bar parsed from the given values.
        Parameters
        ----------
        values : dict[str, Any]
            The values for initialization.
        Returns
        -------
        BinanceBar
        """
        return BinanceBar(
            bar_type=BarType.from_str(values["bar_type"]),
            open=Price.from_str(values["open"]),
            high=Price.from_str(values["high"]),
            low=Price.from_str(values["low"]),
            close=Price.from_str(values["close"]),
            volume=Quantity.from_str(values["volume"]),
            quote_volume=Decimal(values["quote_volume"]),
            count=values["count"],
            taker_buy_base_volume=Decimal(values["taker_buy_base_volume"]),
            taker_buy_quote_volume=Decimal(values["taker_buy_quote_volume"]),
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )
    @staticmethod
    def to_dict(obj: BinanceBar) -> dict[str, Any]:
        """
        Return a dictionary representation of this object.
        Returns
        -------
        dict[str, Any]
        """
        return {
            "type": type(obj).__name__,
            "bar_type": str(obj.bar_type),
            "open": str(obj.open),
            "high": str(obj.high),
            "low": str(obj.low),
            "close": str(obj.close),
            "volume": str(obj.volume),
            "quote_volume": str(obj.quote_volume),
            "count": obj.count,
            "taker_buy_base_volume": str(obj.taker_buy_base_volume),
            "taker_buy_quote_volume": str(obj.taker_buy_quote_volume),
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
        }
class BinanceTicker(Data):
    """
    Represents a Binance 24hr statistics ticker.
    This data type includes the raw data provided by Binance.
    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID.
    price_change : Decimal
        The price change.
    price_change_percent : Decimal
        The price change percent.
    weighted_avg_price : Decimal
        The weighted average price.
    prev_close_price : Decimal, optional
        The previous close price.
    last_price : Decimal
        The last price.
    last_qty : Decimal
        The last quantity.
    bid_price : Decimal, optional
        The bid price.
    bid_qty : Decimal, optional
        The bid quantity.
    ask_price : Decimal, optional
        The ask price.
    ask_qty : Decimal, optional
        The ask quantity.
    open_price : Decimal
        The open price.
    high_price : Decimal
        The high price.
    low_price : Decimal
        The low price.
    volume : Decimal
        The volume.
    quote_volume : Decimal
        The quote volume.
    open_time_ms : int
        UNIX timestamp (milliseconds) when the ticker opened.
    close_time_ms : int
        UNIX timestamp (milliseconds) when the ticker closed.
    first_id : int
        The first trade match ID (assigned by the venue) for the ticker.
    last_id : int
        The last trade match ID (assigned by the venue) for the ticker.
    count : int
        The count of trades over the tickers time range.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the ticker event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the object was initialized.
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#24hr-ticker-price-change-statistics
    https://binance-docs.github.io/apidocs/futures/en/#24hr-ticker-price-change-statistics
    """
    def __init__(
        self,
        instrument_id: InstrumentId,
        price_change: Decimal,
        price_change_percent: Decimal,
        weighted_avg_price: Decimal,
        last_price: Decimal,
        last_qty: Decimal,
        open_price: Decimal,
        high_price: Decimal,
        low_price: Decimal,
        volume: Decimal,
        quote_volume: Decimal,
        open_time_ms: int,
        close_time_ms: int,
        first_id: int,
        last_id: int,
        count: int,
        ts_event: int,
        ts_init: int,
        prev_close_price: Decimal | None = None,
        bid_price: Decimal | None = None,
        bid_qty: Decimal | None = None,
        ask_price: Decimal | None = None,
        ask_qty: Decimal | None = None,
    ) -> None:
        self.instrument_id = instrument_id
        self.price_change = price_change
        self.price_change_percent = price_change_percent
        self.weighted_avg_price = weighted_avg_price
        self.prev_close_price = prev_close_price
        self.last_price = last_price
        self.last_qty = last_qty
        self.bid_price = bid_price
        self.bid_qty = bid_qty
        self.ask_price = ask_price
        self.ask_qty = ask_qty
        self.open_price = open_price
        self.high_price = high_price
        self.low_price = low_price
        self.volume = volume
        self.quote_volume = quote_volume
        self.open_time_ms = open_time_ms
        self.close_time_ms = close_time_ms
        self.first_id = first_id
        self.last_id = last_id
        self.count = count
        self._ts_event = ts_event
        self._ts_init = ts_init
    def __eq__(self, other: object) -> bool:
        if not isinstance(other, BinanceTicker):
            return False
        return self.instrument_id == other.instrument_id
    def __hash__(self) -> int:
        return hash(self.instrument_id)
    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id.value}, "
            f"price_change={self.price_change}, "
            f"price_change_percent={self.price_change_percent}, "
            f"weighted_avg_price={self.weighted_avg_price}, "
            f"prev_close_price={self.prev_close_price}, "
            f"last_price={self.last_price}, "
            f"last_qty={self.last_qty}, "
            f"bid_price={self.bid_price}, "
            f"bid_qty={self.bid_qty}, "
            f"ask_price={self.ask_price}, "
            f"ask_qty={self.ask_qty}, "
            f"open_price={self.open_price}, "
            f"high_price={self.high_price}, "
            f"low_price={self.low_price}, "
            f"volume={self.volume}, "
            f"quote_volume={self.quote_volume}, "
            f"open_time_ms={self.open_time_ms}, "
            f"close_time_ms={self.close_time_ms}, "
            f"first_id={self.first_id}, "
            f"last_id={self.last_id}, "
            f"count={self.count}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )
    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the data event occurred.
        Returns
        -------
        int
        """
        return self._ts_event
    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.
        Returns
        -------
        int
        """
        return self._ts_init
    @staticmethod
    def from_dict(values: dict[str, Any]) -> BinanceTicker:
        """
        Return a Binance Spot/Margin ticker parsed from the given values.
        Parameters
        ----------
        values : dict[str, Any]
            The values for initialization.
        Returns
        -------
        BinanceTicker
        """
        prev_close_str: str | None = values.get("prev_close")
        bid_price_str: str | None = values.get("bid_price")
        bid_qty_str: str | None = values.get("bid_qty")
        ask_price_str: str | None = values.get("ask_price")
        ask_qty_str: str | None = values.get("ask_qty")
        return BinanceTicker(
            instrument_id=InstrumentId.from_str(values["instrument_id"]),
            price_change=Decimal(values["price_change"]),
            price_change_percent=Decimal(values["price_change_percent"]),
            weighted_avg_price=Decimal(values["weighted_avg_price"]),
            prev_close_price=Decimal(prev_close_str) if prev_close_str is not None else None,
            last_price=Decimal(values["last_price"]),
            last_qty=Decimal(values["last_qty"]),
            bid_price=Decimal(bid_price_str) if bid_price_str is not None else None,
            bid_qty=Decimal(bid_qty_str) if bid_qty_str is not None else None,
            ask_price=Decimal(ask_price_str) if ask_price_str is not None else None,
            ask_qty=Decimal(ask_qty_str) if ask_qty_str is not None else None,
            open_price=Decimal(values["open_price"]),
            high_price=Decimal(values["high_price"]),
            low_price=Decimal(values["low_price"]),
            volume=Decimal(values["volume"]),
            quote_volume=Decimal(values["quote_volume"]),
            open_time_ms=values["open_time_ms"],
            close_time_ms=values["close_time_ms"],
            first_id=values["first_id"],
            last_id=values["last_id"],
            count=values["count"],
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )
    @staticmethod
    def to_dict(obj: BinanceTicker) -> dict[str, Any]:
        """
        Return a dictionary representation of this object.
        Returns
        -------
        dict[str, Any]
        """
        return {
            "type": type(obj).__name__,
            "instrument_id": obj.instrument_id.value,
            "price_change": str(obj.price_change),
            "price_change_percent": str(obj.price_change_percent),
            "weighted_avg_price": str(obj.weighted_avg_price),
            "prev_close_price": (
                str(obj.prev_close_price) if obj.prev_close_price is not None else None
            ),
            "last_price": str(obj.last_price),
            "last_qty": str(obj.last_qty),
            "bid_price": str(obj.bid_price),
            "bid_qty": str(obj.bid_qty) if obj.bid_qty is not None else None,
            "ask_price": str(obj.ask_price),
            "ask_qty": str(obj.ask_qty) if obj.ask_qty is not None else None,
            "open_price": str(obj.open_price),
            "high_price": str(obj.high_price),
            "low_price": str(obj.low_price),
            "volume": str(obj.volume),
            "quote_volume": str(obj.quote_volume),
            "open_time_ms": obj.open_time_ms,
            "close_time_ms": obj.close_time_ms,
            "first_id": obj.first_id,
            "last_id": obj.last_id,
            "count": obj.count,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
        }
</document_content>
</document>
<document index="1743">
<source>nautilus_trader/adapters/binance/common/urls.py</source>
<document_content>

def get_http_base_url(account_type: BinanceAccountType, is_testnet: bool, is_us: bool) -> str:
    # Testnet base URLs
    if is_testnet:
        if account_type.is_spot_or_margin:
            return "https://testnet.binance.vision"
        elif (
            account_type == BinanceAccountType.USDT_FUTURES
            or account_type == BinanceAccountType.COIN_FUTURES
        ):
            return "https://testnet.binancefuture.com"
        else:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"invalid `BinanceAccountType`, was {account_type}",  # pragma: no cover
            )
    # Live base URLs
    top_level_domain: str = "us" if is_us else "com"
    if account_type.is_spot:
        return f"https://api.binance.{top_level_domain}"
    elif account_type.is_margin:
        return f"https://sapi.binance.{top_level_domain}"
    elif account_type == BinanceAccountType.USDT_FUTURES:
        return f"https://fapi.binance.{top_level_domain}"
    elif account_type == BinanceAccountType.COIN_FUTURES:
        return f"https://dapi.binance.{top_level_domain}"
    else:
        raise RuntimeError(  # pragma: no cover (design-time error)
            f"invalid `BinanceAccountType`, was {account_type}",  # pragma: no cover
        )
def get_ws_base_url(account_type: BinanceAccountType, is_testnet: bool, is_us: bool) -> str:
    # Testnet base URLs
    if is_testnet:
        if account_type.is_spot_or_margin:
            return "wss://stream.testnet.binance.vision"
        elif account_type == BinanceAccountType.USDT_FUTURES:
            return "wss://stream.binancefuture.com"
        elif account_type == BinanceAccountType.COIN_FUTURES:
            raise ValueError("no testnet for COIN-M futures")
        else:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"invalid `BinanceAccountType`, was {account_type}",  # pragma: no cover
            )
    # Live base URLs
    top_level_domain: str = "us" if is_us else "com"
    if account_type.is_spot_or_margin:
        return f"wss://stream.binance.{top_level_domain}:9443"
    elif account_type == BinanceAccountType.USDT_FUTURES:
        return f"wss://fstream.binance.{top_level_domain}"
    elif account_type == BinanceAccountType.COIN_FUTURES:
        return f"wss://dstream.binance.{top_level_domain}"
    else:
        raise RuntimeError(
            f"invalid `BinanceAccountType`, was {account_type}",
        )  # pragma: no cover (design-time error)
</document_content>
</document>
<document index="1744">
<source>nautilus_trader/adapters/binance/config.py</source>
<document_content>

class BinanceDataClientConfig(LiveDataClientConfig, frozen=True):
    """
    Configuration for ``BinanceDataClient`` instances.
    Parameters
    ----------
    venue : Venue, default BINANCE_VENUE
        The venue for the client.
    api_key : str, optional
        The Binance API public key.
        If ``None`` then will source the `BINANCE_API_KEY` or
        `BINANCE_TESTNET_API_KEY` environment variables.
    api_secret : str, optional
        The Binance API secret key.
        If ``None`` then will source the `BINANCE_API_SECRET` or
        `BINANCE_TESTNET_API_SECRET` environment variables.
    key_type : BinanceKeyType, default 'HMAC'
        The private key cryptographic algorithm type.
    account_type : BinanceAccountType, default BinanceAccountType.SPOT
        The account type for the client.
    base_url_http : str, optional
        The HTTP client custom endpoint override.
    base_url_ws : str, optional
        The WebSocket client custom endpoint override.
    proxy_url : str, optional
        The proxy URL for HTTP requests.
    us : bool, default False
        If client is connecting to Binance US.
    testnet : bool, default False
        If the client is connecting to a Binance testnet.
    update_instruments_interval_mins: PositiveInt or None, default 60
        The interval (minutes) between reloading instruments from the venue.
    use_agg_trade_ticks : bool, default False
        Whether to use aggregated trade tick endpoints instead of raw trades.
        TradeId of ticks will be the Aggregate tradeId returned by Binance.
    """
    venue: Venue = BINANCE_VENUE
    api_key: str | None = None
    api_secret: str | None = None
    key_type: BinanceKeyType = BinanceKeyType.HMAC
    account_type: BinanceAccountType = BinanceAccountType.SPOT
    base_url_http: str | None = None
    base_url_ws: str | None = None
    proxy_url: str | None = None
    us: bool = False
    testnet: bool = False
    update_instruments_interval_mins: PositiveInt | None = 60
    use_agg_trade_ticks: bool = False
class BinanceExecClientConfig(LiveExecClientConfig, frozen=True):
    """
    Configuration for ``BinanceExecutionClient`` instances.
    Parameters
    ----------
    venue : Venue, default BINANCE_VENUE
        The venue for the client.
    api_key : str, optional
        The Binance API public key.
        If ``None`` then will source the `BINANCE_API_KEY` or
        `BINANCE_TESTNET_API_KEY` environment variables.
    api_secret : str, optional
        The Binance API secret key.
        If ``None`` then will source the `BINANCE_API_SECRET` or
        `BINANCE_TESTNET_API_SECRET` environment variables.
    key_type : BinanceKeyType, default 'HMAC'
        The private key cryptographic algorithm type.
    account_type : BinanceAccountType, default BinanceAccountType.SPOT
        The account type for the client.
    base_url_http : str, optional
        The HTTP client custom endpoint override.
    base_url_ws : str, optional
        The WebSocket client custom endpoint override.
    proxy_url : str, optional
        The proxy URL for HTTP requests.
    us : bool, default False
        If client is connecting to Binance US.
    testnet : bool, default False
        If the client is connecting to a Binance testnet.
    use_gtd : bool, default True
        If GTD orders will use the Binance GTD TIF option.
        If False, then GTD time in force will be remapped to GTC (this is useful if managing GTD orders locally).
    use_reduce_only : bool, default True
        If the `reduce_only` execution instruction on orders is sent through to the exchange.
        If True, then will assign the value on orders sent to the exchange, otherwise will always be False.
    use_position_ids: bool, default True
        If Binance Futures hedging position IDs should be used.
        If False, then order event `position_id`(s) from the execution client will be `None`, which
        allows *virtual* positions with `OmsType.HEDGING`.
    use_trade_lite: bool, default False
        If TRADE_LITE events should be used.
        If True, commissions will be calculated based on the instrument's details.
    treat_expired_as_canceled : bool, default False
        If the `EXPIRED` execution type is semantically treated as `CANCELED`.
        Binance treats cancels with certain combinations of order type and time in force as expired
        events. This config option allows you to treat these uniformally as cancels.
    recv_window_ms : PositiveInt, default 5000
        The receive window (milliseconds) for Binance HTTP requests.
    max_retries : PositiveInt, optional
        The maximum number of times a submit, cancel or modify order request will be retried.
    retry_delay_initial_ms : PositiveInt, optional
        The initial delay (milliseconds) between retries. Short delays with frequent retries may result in account bans.
    retry_delay_max_ms : PositiveInt, optional
        The maximum delay (milliseconds) between retries.
    futures_leverages : dict[BinanceSymbol, PositiveInt], optional
        The initial leverage to be used for each symbol. It's applicable to futures only.
    futures_margin_types : dict[BinanceSymbol, BinanceFuturesMarginType], optional
        Margin type (isolated or cross) to be used for each symbol. It's applicable to futures only.
    listen_key_ping_max_failures : PositiveInt, default 3
        The maximum number of consecutive listen key ping failures before triggering recovery.
    log_rejected_due_post_only_as_warning : bool, default True
        If order rejected events where `due_post_only` is True should be logged as warnings.
    Warnings
    --------
    A short `retry_delay` with frequent retries may result in account bans.
    """
    venue: Venue = BINANCE_VENUE
    api_key: str | None = None
    api_secret: str | None = None
    key_type: BinanceKeyType = BinanceKeyType.HMAC
    account_type: BinanceAccountType = BinanceAccountType.SPOT
    base_url_http: str | None = None
    base_url_ws: str | None = None
    proxy_url: str | None = None
    us: bool = False
    testnet: bool = False
    use_gtd: bool = True
    use_reduce_only: bool = True
    use_position_ids: bool = True
    use_trade_lite: bool = False
    treat_expired_as_canceled: bool = False
    recv_window_ms: PositiveInt = 5_000
    max_retries: PositiveInt | None = None
    retry_delay_initial_ms: PositiveInt | None = None
    retry_delay_max_ms: PositiveInt | None = None
    futures_leverages: dict[BinanceSymbol, PositiveInt] | None = None
    futures_margin_types: dict[BinanceSymbol, BinanceFuturesMarginType] | None = None
    listen_key_ping_max_failures: PositiveInt = 3
    log_rejected_due_post_only_as_warning: bool = True
</document_content>
</document>
<document index="1745">
<source>nautilus_trader/adapters/binance/data.py</source>
<document_content>

import asyncio
import decimal
from decimal import Decimal
import msgspec
import pandas as pd
class BinanceCommonDataClient(LiveMarketDataClient):
    """
    Provides a data client of common methods for the Binance exchange.
    Parameters
    ----------
    loop : asyncio.AbstractEventLoop
        The event loop for the client.
    client : BinanceHttpClient
        The Binance HTTP client.
    market : BinanceMarketHttpAPI
        The Binance Market HTTP API.
    enum_parser : BinanceEnumParser
        The parser for Binance enums.
    msgbus : MessageBus
        The message bus for the client.
    cache : Cache
        The cache for the client.
    clock : LiveClock
        The clock for the client.
    instrument_provider : InstrumentProvider
        The instrument provider.
    account_type : BinanceAccountType
        The account type for the client.
    base_url_ws : str
        The base url for the WebSocket client.
    name : str, optional
        The custom client ID.
    config : BinanceDataClientConfig
        The configuration for the client.
    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """
    def __init__(
        self,
        loop: asyncio.AbstractEventLoop,
        client: BinanceHttpClient,
        market: BinanceMarketHttpAPI,
        enum_parser: BinanceEnumParser,
        msgbus: MessageBus,
        cache: Cache,
        clock: LiveClock,
        instrument_provider: InstrumentProvider,
        account_type: BinanceAccountType,
        base_url_ws: str,
        name: str | None,
        config: BinanceDataClientConfig,
    ) -> None:
        super().__init__(
            loop=loop,
            client_id=ClientId(name or config.venue.value),
            venue=config.venue,
            msgbus=msgbus,
            cache=cache,
            clock=clock,
            instrument_provider=instrument_provider,
        )
        # Configuration
        self._binance_account_type = account_type
        self._use_agg_trade_ticks = config.use_agg_trade_ticks
        self._log.info(f"Key type: {config.key_type.value}", LogColor.BLUE)
        self._log.info(f"Account type: {self._binance_account_type.value}", LogColor.BLUE)
        self._log.info(f"{config.update_instruments_interval_mins=}", LogColor.BLUE)
        self._log.info(f"{config.use_agg_trade_ticks=}", LogColor.BLUE)
        self._update_instruments_interval_mins: int | None = config.update_instruments_interval_mins
        self._update_instruments_task: asyncio.Task | None = None
        self._connect_websockets_delay: float = 0.0  # Delay for bulk subscriptions to come in
        self._connect_websockets_task: asyncio.Task | None = None
        self._subscribe_allow_no_instrument_id = [
            BinanceFuturesMarkPriceUpdate,
        ]
        # HTTP API
        self._http_client = client
        self._http_market = market
        # Enum parser
        self._enum_parser = enum_parser
        # WebSocket API
        self._ws_client = BinanceWebSocketClient(
            clock=clock,
            handler=self._handle_ws_message,
            handler_reconnect=self._reconnect,
            base_url=base_url_ws,
            loop=self._loop,
        )
        # Hot caches
        self._instrument_ids: dict[str, InstrumentId] = {}
        self._book_depths: dict[InstrumentId, int | None] = {}
        self._book_buffer: dict[
            InstrumentId,
            list[OrderBookDelta | OrderBookDeltas],
        ] = {}
        self._log.info(f"Base url HTTP {self._http_client.base_url}", LogColor.BLUE)
        self._log.info(f"Base url WebSocket {base_url_ws}", LogColor.BLUE)
        # Register common WebSocket message handlers
        self._ws_handlers = {
            "@bookTicker": self._handle_book_ticker,
            "@ticker": self._handle_ticker,
            "@kline": self._handle_kline,
            "@trade": self._handle_trade,
            "@aggTrade": self._handle_agg_trade,
            "@depth@": self._handle_book_diff_update,
            "@depth5": self._handle_book_partial_update,
            "@depth10": self._handle_book_partial_update,
            "@depth20": self._handle_book_partial_update,
        }
        # WebSocket msgspec decoders
        self._decoder_data_msg_wrapper = msgspec.json.Decoder(BinanceDataMsgWrapper)
        self._decoder_order_book_msg = msgspec.json.Decoder(BinanceOrderBookMsg)
        self._decoder_quote_msg = msgspec.json.Decoder(BinanceQuoteMsg)
        self._decoder_ticker_msg = msgspec.json.Decoder(BinanceTickerMsg)
        self._decoder_candlestick_msg = msgspec.json.Decoder(BinanceCandlestickMsg)
        self._decoder_agg_trade_msg = msgspec.json.Decoder(BinanceAggregatedTradeMsg)
        # Retry logic (hardcoded for now)
        self._max_retries: int = 3
        self._retry_delay: float = 1.0
        self._retry_errors: set[BinanceErrorCode] = {
            BinanceErrorCode.DISCONNECTED,
            BinanceErrorCode.TOO_MANY_REQUESTS,  # Short retry delays may result in bans
            BinanceErrorCode.TIMEOUT,
            BinanceErrorCode.INVALID_TIMESTAMP,
            BinanceErrorCode.ME_RECVWINDOW_REJECT,
        }
    async def _connect(self) -> None:
        await self._instrument_provider.initialize()
        self._send_all_instruments_to_data_engine()
        if self._update_instruments_interval_mins:
            self._update_instruments_task = self.create_task(
                self._update_instruments(self._update_instruments_interval_mins),
            )
    async def _update_instruments(self, interval_mins: int) -> None:
        while True:
            retries = 0
            while True:
                try:
                    self._log.debug(
                        f"Scheduled task 'update_instruments' to run in {interval_mins} minutes",
                    )
                    await asyncio.sleep(interval_mins * 60)
                    await self._instrument_provider.initialize(reload=True)
                    self._send_all_instruments_to_data_engine()
                    break
                except BinanceError as e:
                    error_code = BinanceErrorCode(int(e.message["code"]))
                    retries += 1
                    if not self._should_retry(error_code, retries):
                        self._log.error(f"Error updating instruments: {e}")
                        break
                    self._log.warning(
                        f"{error_code.name}: retrying update instruments "
                        f"{retries}/{self._max_retries} in {self._retry_delay}s",
                    )
                    await asyncio.sleep(self._retry_delay)
                except asyncio.CancelledError:
                    self._log.debug("Canceled task 'update_instruments'")
                    return
    async def _reconnect(self) -> None:
        coros = []
        for instrument_id in self._book_depths:
            coros.append(self._order_book_snapshot_then_deltas(instrument_id))
        await asyncio.gather(*coros)
    async def _disconnect(self) -> None:
        # Cancel update instruments task
        if self._update_instruments_task:
            self._log.debug("Canceling task 'update_instruments'")
            self._update_instruments_task.cancel()
            self._update_instruments_task = None
        await self._ws_client.disconnect()
    def _should_retry(self, error_code: BinanceErrorCode, retries: int) -> bool:
        return not (error_code not in self._retry_errors or not self._max_retries or retries > self._max_retries)
    # -- SUBSCRIPTIONS ----------------------------------------------------------------------------
    async def _subscribe(self, command: SubscribeData) -> None:
        instrument_id: InstrumentId | None = command.data_type.metadata.get("instrument_id")
        if (
            instrument_id is None
            and command.data_type.type not in self._subscribe_allow_no_instrument_id
        ):
            self._log.error(
                f"Cannot subscribe to `{command.data_type.type}` no instrument ID in `data_type` metadata",
            )
            return
        if command.data_type.type == BinanceTicker:
            await self._ws_client.subscribe_ticker(instrument_id.symbol.value)
        elif command.data_type.type == BinanceFuturesMarkPriceUpdate:
            if not self._binance_account_type.is_futures:
                self._log.error(
                    "Cannot subscribe to `BinanceFuturesMarkPriceUpdate` "
                    f"for {self._binance_account_type.value} account types",
                )
                return
            mark_price_symbol = instrument_id.symbol.value if instrument_id else None
            await self._ws_client.subscribe_mark_price(mark_price_symbol, speed=1000)
        else:
            self._log.error(
                f"Cannot subscribe to {command.data_type.type} (not implemented)",
            )
    async def _unsubscribe(self, command: UnsubscribeData) -> None:
        instrument_id: InstrumentId | None = command.data_type.metadata.get("instrument_id")
        if (
            instrument_id is None
            and command.data_type.type not in self._subscribe_allow_no_instrument_id
        ):
            self._log.error(
                "Cannot unsubscribe to `BinanceFuturesMarkPriceUpdate` no instrument ID in `data_type` metadata",
            )
            return
        if command.data_type.type == BinanceTicker:
            await self._ws_client.unsubscribe_ticker(instrument_id.symbol.value)
        elif command.data_type.type == BinanceFuturesMarkPriceUpdate:
            if not self._binance_account_type.is_futures:
                self._log.error(
                    "Cannot unsubscribe from `BinanceFuturesMarkPriceUpdate` "
                    f"for {self._binance_account_type.value} account types",
                )
                return
        else:
            self._log.error(
                f"Cannot unsubscribe from {command.data_type.type} (not implemented)",
            )
    async def _subscribe_instruments(self, command: SubscribeInstruments) -> None:
        pass  # Do nothing further
    async def _subscribe_instrument(self, command: SubscribeInstrument) -> None:
        pass  # Do nothing further
    async def _subscribe_order_book_deltas(self, command: SubscribeOrderBook) -> None:
        await self._subscribe_order_book(command)
    async def _subscribe_order_book_snapshots(self, command: SubscribeOrderBook) -> None:
        await self._subscribe_order_book(command)
    async def _subscribe_order_book(self, command: SubscribeOrderBook) -> None:
        update_speed: int | None = command.params.get("update_speed")
        if command.book_type == BookType.L3_MBO:
            self._log.error(
                "Cannot subscribe to order book deltas: "
                "L3_MBO data is not published by Binance. "
                "Valid book types are L1_MBP, L2_MBP",
            )
            return
        valid_speeds = [100, 1000]
        if self._binance_account_type.is_futures:
            if update_speed is None:
                update_speed = 0  # Default 0 ms for futures
            valid_speeds = [0, 100, 250, 500]  # 0ms option for futures exists but not documented?
        elif update_speed is None:
            update_speed = 100  # Default 100ms for spot
        if update_speed not in valid_speeds:
            self._log.error(
                "Cannot subscribe to order book:"
                f"invalid `update_speed`, was {update_speed}. "
                f"Valid update speeds are {valid_speeds} ms",
            )
            return
        # Use the depth requested on the command, otherwise fall back to the
        # Binance maximum (1000). Note that a depth of ``0`` means *full book*
        # in NautilusTrader semantics, which we translate to 1000; the maximum
        # value accepted by the Binance partial book snapshot endpoint.
        depth: int = command.depth if command.depth else 1000
        if 0 < depth <= 20:
            if depth not in (5, 10, 20):
                self._log.error(
                    "Cannot subscribe to order book snapshots: "
                    f"invalid `depth`, was {depth}. "
                    "Valid depths are 5, 10, or 20",
                )
                return
            await self._ws_client.subscribe_partial_book_depth(
                symbol=command.instrument_id.symbol.value,
                depth=depth,
                speed=update_speed,
            )
        else:
            await self._ws_client.subscribe_diff_book_depth(
                symbol=command.instrument_id.symbol.value,
                speed=update_speed,
            )
        self._book_depths[command.instrument_id] = depth
        await self._order_book_snapshot_then_deltas(command.instrument_id)
    async def _order_book_snapshot_then_deltas(self, instrument_id: InstrumentId) -> None:
        # Add delta feed buffer
        self._book_buffer[instrument_id] = []
        depth = self._book_depths[instrument_id]
        self._log.info(
            f"OrderBook snapshot rebuild for {instrument_id} @ depth {depth} starting",
            LogColor.BLUE,
        )
        snapshot: OrderBookDeltas = await self._http_market.request_order_book_snapshot(
            instrument_id=instrument_id,
            limit=depth,
            ts_init=self._clock.timestamp_ns(),
        )
        self._handle_data(snapshot)
        book_buffer = self._book_buffer.pop(instrument_id, [])
        for deltas in book_buffer:
            if snapshot and deltas.sequence <= snapshot.sequence:
                continue
            self._handle_data(deltas)
        self._log.info(
            f"OrderBook snapshot rebuild for {instrument_id} completed",
            LogColor.BLUE,
        )
    async def _subscribe_mark_prices(self, command: SubscribeMarkPrices) -> None:
        await self._ws_client.subscribe_mark_price(command.instrument_id.symbol.value, speed=1000)
    async def _subscribe_quote_ticks(self, command: SubscribeQuoteTicks) -> None:
        await self._ws_client.subscribe_book_ticker(command.instrument_id.symbol.value)
    async def _subscribe_trade_ticks(self, command: SubscribeTradeTicks) -> None:
        if self._use_agg_trade_ticks:
            await self._ws_client.subscribe_agg_trades(command.instrument_id.symbol.value)
        else:
            await self._ws_client.subscribe_trades(command.instrument_id.symbol.value)
    async def _subscribe_bars(self, command: SubscribeBars) -> None:
        PyCondition.is_true(
            command.bar_type.is_externally_aggregated(),
            "aggregation_source is not EXTERNAL",
        )
        if not command.bar_type.spec.is_time_aggregated():
            self._log.error(
                f"Cannot subscribe to {command.bar_type}: only time bars are aggregated by Binance",
            )
            return
        resolution = self._enum_parser.parse_nautilus_bar_aggregation(
            command.bar_type.spec.aggregation,
        )
        if self._binance_account_type.is_futures and resolution == "s":
            self._log.error(
                f"Cannot subscribe to {command.bar_type}. "
                "Second interval bars are not aggregated by Binance Futures",
            )
        try:
            interval = BinanceKlineInterval(f"{command.bar_type.spec.step}{resolution}")
        except ValueError:
            self._log.error(
                f"Bar interval {command.bar_type.spec.step}{resolution} not supported by Binance",
            )
            return
        await self._ws_client.subscribe_bars(
            symbol=command.bar_type.instrument_id.symbol.value,
            interval=interval.value,
        )
    async def _unsubscribe_instruments(self, command: UnsubscribeInstruments) -> None:
        pass  # Do nothing further
    async def _unsubscribe_instrument(self, command: UnsubscribeInstrument) -> None:
        pass  # Do nothing further
    async def _unsubscribe_order_book_deltas(self, command: UnsubscribeOrderBook) -> None:
        pass  # TODO: Unsubscribe from Binance if no other subscriptions
    async def _unsubscribe_order_book_snapshots(self, command: UnsubscribeOrderBook) -> None:
        pass  # TODO: Unsubscribe from Binance if no other subscriptions
    async def _unsubscribe_quote_ticks(self, command: UnsubscribeQuoteTicks) -> None:
        await self._ws_client.unsubscribe_book_ticker(command.instrument_id.symbol.value)
    async def _unsubscribe_trade_ticks(self, command: UnsubscribeTradeTicks) -> None:
        if self._use_agg_trade_ticks:
            await self._ws_client.unsubscribe_agg_trades(command.instrument_id.symbol.value)
        else:
            await self._ws_client.unsubscribe_trades(command.instrument_id.symbol.value)
    async def _unsubscribe_bars(self, command: UnsubscribeBars) -> None:
        if not command.bar_type.spec.is_time_aggregated():
            self._log.error(
                f"Cannot unsubscribe from {command.bar_type}: only time bars are aggregated by Binance",
            )
            return
        resolution = self._enum_parser.parse_nautilus_bar_aggregation(
            command.bar_type.spec.aggregation,
        )
        if self._binance_account_type.is_futures and resolution == "s":
            self._log.error(
                f"Cannot unsubscribe from {command.bar_type}. "
                "Second interval bars are not aggregated by Binance Futures",
            )
        try:
            interval = BinanceKlineInterval(f"{command.bar_type.spec.step}{resolution}")
        except ValueError:
            self._log.error(
                f"Bar interval {command.bar_type.spec.step}{resolution} not supported by Binance",
            )
            return
        await self._ws_client.unsubscribe_bars(
            symbol=command.bar_type.instrument_id.symbol.value,
            interval=interval.value,
        )
    # -- REQUESTS ---------------------------------------------------------------------------------
    async def _request_instrument(self, request: RequestInstrument) -> None:
        if request.start is not None:
            self._log.warning(
                f"Requesting instrument {request.instrument_id} with specified `start` which has no effect",
            )
        if request.end is not None:
            self._log.warning(
                f"Requesting instrument {request.instrument_id} with specified `end` which has no effect",
            )
        instrument: Instrument | None = self._instrument_provider.find(request.instrument_id)
        if instrument is None:
            self._log.error(f"Cannot find instrument for {request.instrument_id}")
            return
        self._handle_instrument(instrument, request.id, request.start, request.end, request.params)
    async def _request_quote_ticks(self, request: RequestQuoteTicks) -> None:
        self._log.error(
            "Cannot request historical quotes: not published by Binance",
        )
    async def _request_trade_ticks(self, request: RequestTradeTicks) -> None:
        limit = request.limit
        if limit == 0 or limit > 1000:
            limit = 1000
        if not self._use_agg_trade_ticks:
            self._log.warning(
                "Trades have been requested with a from/to time range, "
                f"however the request will be for the most recent {limit}: "
                "consider using aggregated trades (`use_agg_trade_ticks`)",
            )
            ticks = await self._http_market.request_trade_ticks(
                instrument_id=request.instrument_id,
                limit=limit,
            )
        else:
            # Convert from timestamps to milliseconds
            start_time_ms = secs_to_millis(request.start.timestamp())
            end_time_ms = secs_to_millis(request.end.timestamp())
            ticks = await self._http_market.request_agg_trade_ticks(
                instrument_id=request.instrument_id,
                limit=limit,
                start_time=start_time_ms,
                end_time=end_time_ms,
            )
        self._handle_trade_ticks(
            request.instrument_id,
            ticks,
            request.id,
            request.start,
            request.end,
            request.params,
        )
    async def _request_bars(self, request: RequestBars) -> None:
        if request.bar_type.spec.price_type != PriceType.LAST:
            self._log.error(
                f"Cannot request {request.bar_type} bars: "
                f"only historical bars for LAST price type available from Binance",
            )
            return
        start_time_ms = secs_to_millis(request.start.timestamp())
        end_time_ms = secs_to_millis(request.end.timestamp())
        if (
            request.bar_type.is_externally_aggregated()
            or request.bar_type.spec.is_time_aggregated()
        ):
            if not request.bar_type.spec.is_time_aggregated():
                self._log.error(
                    f"Cannot request {request.bar_type} bars: only time bars are aggregated by Binance",
                )
                return
            resolution = self._enum_parser.parse_nautilus_bar_aggregation(
                request.bar_type.spec.aggregation,
            )
            if not self._binance_account_type.is_spot_or_margin and resolution == "s":
                self._log.error(
                    f"Cannot request {request.bar_type} bars: "
                    "second interval bars are not aggregated by Binance Futures",
                )
            try:
                interval = BinanceKlineInterval(f"{request.bar_type.spec.step}{resolution}")
            except ValueError:
                self._log.error(
                    f"Cannot create Binance Kline interval. {request.bar_type.spec.step}{resolution} "
                    "not supported",
                )
                return
            bars = await self._http_market.request_binance_bars(
                bar_type=request.bar_type,
                interval=interval,
                start_time=start_time_ms,
                end_time=end_time_ms,
                limit=request.limit if request.limit > 0 else None,
            )
            if request.bar_type.is_internally_aggregated():
                self._log.info(
                    "Inferred INTERNAL time bars from EXTERNAL time bars",
                    LogColor.BLUE,
                )
        elif request.start and request.start < self._clock.utc_now() - pd.Timedelta(days=1):
            bars = await self._aggregate_internal_from_minute_bars(
                bar_type=request.bar_type,
                start_time_ms=start_time_ms,
                end_time_ms=end_time_ms,
                limit=request.limit if request.limit > 0 else None,
            )
        else:
            bars = await self._aggregate_internal_from_agg_trade_ticks(
                bar_type=request.bar_type,
                start_time_ms=start_time_ms,
                end_time_ms=end_time_ms,
                limit=request.limit if request.limit > 0 else None,
            )
        if not bars:
            self._log.warning(
                f"No bars returned for {request.bar_type} between "
                f"{request.start} and {request.end}",
            )
            return
        # Filter out incomplete bars where close_time >= current_time
        # Binance may return the current forming bar which should be excluded from historical data
        current_time_ns = self._clock.timestamp_ns()
        complete_bars = [bar for bar in bars if bar.ts_event < current_time_ns]
        if not complete_bars:
            self._log.warning(
                f"No complete bars available for {request.bar_type} (all bars were incomplete)",
            )
            return
        self._handle_bars(
            request.bar_type,
            complete_bars,
            request.id,
            request.start,
            request.end,
            request.params,
        )
    async def _request_order_book_snapshot(self, request: RequestOrderBookSnapshot) -> None:
        if request.limit not in [5, 10, 20, 50, 100, 500, 1000]:
            self._log.error(
                "Cannot get order book snapshots: "
                f"invalid `limit`, was {request.limit}. "
                "Valid limits are 5, 10, 20, 50, 100, 500 or 1000",
            )
            return
        else:
            snapshot: OrderBookDeltas = await self._http_market.request_order_book_snapshot(
                instrument_id=request.instrument_id,
                limit=request.limit,
                ts_init=self._clock.timestamp_ns(),
            )
            data_type = DataType(
                OrderBookDeltas,
                metadata=({"instrument_id": request.instrument_id}),
            )
            self._handle_data_response(
                data_type=data_type,
                data=snapshot,
                correlation_id=request.id,
                start=None,
                end=None,
                params=request.params,
            )
    async def _aggregate_internal_from_minute_bars(
        self,
        bar_type: BarType,
        start_time_ms: int | None,
        end_time_ms: int | None,
        limit: int | None,
    ) -> list[Bar]:
        instrument = self._instrument_provider.find(bar_type.instrument_id)
        if instrument is None:
            self._log.error(
                f"Cannot aggregate internal bars: instrument {bar_type.instrument_id} not found",
            )
            return []
        self._log.info("Requesting 1-MINUTE Binance bars to infer INTERNAL bars...", LogColor.BLUE)
        binance_bars = await self._http_market.request_binance_bars(
            bar_type=BarType(
                bar_type.instrument_id,
                BarSpecification(1, BarAggregation.MINUTE, PriceType.LAST),
                AggregationSource.EXTERNAL,
            ),
            interval=BinanceKlineInterval.MINUTE_1,
            start_time=start_time_ms,
            end_time=end_time_ms,
            limit=limit,
        )
        quantize_value = Decimal(f"1e-{instrument.size_precision}")
        bars: list[Bar] = []
        if bar_type.spec.aggregation == BarAggregation.TICK:
            aggregator = TickBarAggregator(
                instrument=instrument,
                bar_type=bar_type,
                handler=bars.append,
            )
        elif bar_type.spec.aggregation == BarAggregation.VOLUME:
            aggregator = VolumeBarAggregator(
                instrument=instrument,
                bar_type=bar_type,
                handler=bars.append,
            )
        elif bar_type.spec.aggregation == BarAggregation.VALUE:
            aggregator = ValueBarAggregator(
                instrument=instrument,
                bar_type=bar_type,
                handler=bars.append,
            )
        else:
            msg = bar_aggregation_not_implemented_message(bar_type.spec.aggregation)
            raise NotImplementedError(f"Inferring bars from Binance klines failed: {msg}")
        for binance_bar in binance_bars:
            if binance_bar.count == 0:
                continue
            self._aggregate_bar_to_trade_ticks(
                instrument=instrument,
                aggregator=aggregator,
                binance_bar=binance_bar,
                quantize_value=quantize_value,
            )
        self._log.info(
            f"Inferred {len(bars)} {bar_type} bars aggregated from {len(binance_bars)} 1-MINUTE Binance bars",
            LogColor.BLUE,
        )
        if limit:
            bars = bars[:limit]
        return bars
    def _aggregate_bar_to_trade_ticks(
        self,
        instrument: Instrument,
        aggregator: BarAggregator,
        binance_bar: BinanceBar,
        quantize_value: Decimal,
    ) -> None:
        volume = binance_bar.volume.as_decimal()
        size_part: Decimal = (volume / (4 * binance_bar.count)).quantize(
            quantize_value,
            rounding=decimal.ROUND_DOWN,
        )
        remainder: Decimal = volume - (size_part * 4 * binance_bar.count)
        size = Quantity(size_part, instrument.size_precision)
        for i in range(binance_bar.count):
            open = TradeTick(
                instrument_id=instrument.id,
                price=binance_bar.open,
                size=size,
                aggressor_side=AggressorSide.NO_AGGRESSOR,
                trade_id=TradeId("NULL"),  # N/A
                ts_event=binance_bar.ts_event,
                ts_init=binance_bar.ts_event,
            )
            high = TradeTick(
                instrument_id=instrument.id,
                price=binance_bar.high,
                size=size,
                aggressor_side=AggressorSide.NO_AGGRESSOR,
                trade_id=TradeId("NULL"),  # N/A
                ts_event=binance_bar.ts_event,
                ts_init=binance_bar.ts_event,
            )
            low = TradeTick(
                instrument_id=instrument.id,
                price=binance_bar.low,
                size=size,
                aggressor_side=AggressorSide.NO_AGGRESSOR,
                trade_id=TradeId("NULL"),  # N/A
                ts_event=binance_bar.ts_event,
                ts_init=binance_bar.ts_event,
            )
            close_size = size
            if i == binance_bar.count - 1:
                close_size = Quantity(size_part + remainder, instrument.size_precision)
            close = TradeTick(
                instrument_id=instrument.id,
                price=binance_bar.close,
                size=close_size,
                aggressor_side=AggressorSide.NO_AGGRESSOR,
                trade_id=TradeId("NULL"),  # N/A
                ts_event=binance_bar.ts_event,
                ts_init=binance_bar.ts_event,
            )
            aggregator.handle_trade_tick(open)
            aggregator.handle_trade_tick(high)
            aggregator.handle_trade_tick(low)
            aggregator.handle_trade_tick(close)
    async def _aggregate_internal_from_agg_trade_ticks(
        self,
        bar_type: BarType,
        start_time_ms: int | None,
        end_time_ms: int | None,
        limit: int | None,
    ) -> list[Bar]:
        instrument = self._instrument_provider.find(bar_type.instrument_id)
        if instrument is None:
            self._log.error(
                f"Cannot aggregate internal bars: instrument {bar_type.instrument_id} not found",
            )
            return []
        self._log.info("Requesting aggregated trades to infer INTERNAL bars...", LogColor.BLUE)
        ticks = await self._http_market.request_agg_trade_ticks(
            instrument_id=instrument.id,
            start_time=start_time_ms,
            end_time=end_time_ms,
            limit=limit,
        )
        bars: list[Bar] = []
        if bar_type.spec.aggregation == BarAggregation.TICK:
            aggregator = TickBarAggregator(
                instrument=instrument,
                bar_type=bar_type,
                handler=bars.append,
            )
        elif bar_type.spec.aggregation == BarAggregation.VOLUME:
            aggregator = VolumeBarAggregator(
                instrument=instrument,
                bar_type=bar_type,
                handler=bars.append,
            )
        elif bar_type.spec.aggregation == BarAggregation.VALUE:
            aggregator = ValueBarAggregator(
                instrument=instrument,
                bar_type=bar_type,
                handler=bars.append,
            )
        else:
            msg = bar_aggregation_not_implemented_message(bar_type.spec.aggregation)
            raise NotImplementedError(
                f"Inferring bars from Binance aggregated trades failed: {msg}",
            )
        for tick in ticks:
            aggregator.handle_trade_tick(tick)
        self._log.info(
            f"Inferred {len(bars)} {bar_type} bars aggregated from {len(ticks)} trades",
            LogColor.BLUE,
        )
        if limit:
            bars = bars[:limit]
        return bars
    def _send_all_instruments_to_data_engine(self) -> None:
        for instrument in self._instrument_provider.get_all().values():
            self._handle_data(instrument)
        for currency in self._instrument_provider.currencies().values():
            self._cache.add_currency(currency)
    def _get_cached_instrument_id(self, symbol: str) -> InstrumentId:
        # Parse instrument ID
        binance_symbol = BinanceSymbol(symbol)
        nautilus_symbol: str = binance_symbol.parse_as_nautilus(
            self._binance_account_type,
        )
        instrument_id: InstrumentId | None = self._instrument_ids.get(nautilus_symbol)
        if not instrument_id:
            instrument_id = InstrumentId(Symbol(nautilus_symbol), self.venue)
            self._instrument_ids[nautilus_symbol] = instrument_id
        return instrument_id
    # -- WEBSOCKET HANDLERS ---------------------------------------------------------------------------------
    def _handle_ws_message(self, raw: bytes) -> None:
        try:
            wrapper = self._decoder_data_msg_wrapper.decode(raw)
            if not wrapper.stream:
                return  # Control message response
            handled = False
            for handler in self._ws_handlers:
                if handler in wrapper.stream:
                    self._ws_handlers[handler](raw)
                    handled = True
            if not handled:
                self._log.error(
                    f"Unrecognized websocket message type: {wrapper.stream}",
                )
        except Exception as e:
            self._log.exception(f"Error handling websocket message {raw!r}", e)
    def _handle_book_diff_update(self, raw: bytes) -> None:
        msg = self._decoder_order_book_msg.decode(raw)
        instrument_id: InstrumentId = self._get_cached_instrument_id(msg.data.s)
        book_deltas: OrderBookDeltas = msg.data.parse_to_order_book_deltas(
            instrument_id=instrument_id,
            ts_init=self._clock.timestamp_ns(),
        )
        book_buffer: list[OrderBookDelta | OrderBookDeltas] | None = self._book_buffer.get(
            instrument_id,
        )
        if book_buffer is not None:
            book_buffer.append(book_deltas)
            return
        self._handle_data(book_deltas)
    def _handle_book_ticker(self, raw: bytes) -> None:
        msg = self._decoder_quote_msg.decode(raw)
        instrument_id: InstrumentId = self._get_cached_instrument_id(msg.data.s)
        quote_tick: QuoteTick = msg.data.parse_to_quote_tick(
            instrument_id=instrument_id,
            ts_init=self._clock.timestamp_ns(),
        )
        self._handle_data(quote_tick)
    def _handle_ticker(self, raw: bytes) -> None:
        msg = self._decoder_ticker_msg.decode(raw)
        instrument_id: InstrumentId = self._get_cached_instrument_id(msg.data.s)
        ticker: BinanceTicker = msg.data.parse_to_binance_ticker(
            instrument_id=instrument_id,
            ts_init=self._clock.timestamp_ns(),
        )
        data_type = DataType(
            BinanceTicker,
            metadata={"instrument_id": instrument_id},
        )
        custom = CustomData(data_type=data_type, data=ticker)
        self._handle_data(custom)
    def _handle_kline(self, raw: bytes) -> None:
        msg = self._decoder_candlestick_msg.decode(raw)
        if not msg.data.k.x:
            return  # Not closed yet
        instrument_id = self._get_cached_instrument_id(msg.data.s)
        bar: BinanceBar = msg.data.k.parse_to_binance_bar(
            instrument_id=instrument_id,
            enum_parser=self._enum_parser,
            ts_init=self._clock.timestamp_ns(),
        )
        self._handle_data(bar)
    def _handle_book_partial_update(self, raw: bytes) -> None:
        raise NotImplementedError("Please implement book partial update handling in child class.")
    def _handle_trade(self, raw: bytes) -> None:
        raise NotImplementedError("Please implement trade handling in child class.")
    def _handle_agg_trade(self, raw: bytes) -> None:
        msg = self._decoder_agg_trade_msg.decode(raw)
        instrument_id: InstrumentId = self._get_cached_instrument_id(msg.data.s)
        trade_tick: TradeTick = msg.data.parse_to_trade_tick(
            instrument_id=instrument_id,
            ts_init=self._clock.timestamp_ns(),
        )
        self._handle_data(trade_tick)
</document_content>
</document>
<document index="1746">
<source>nautilus_trader/adapters/binance/factories.py</source>
<document_content>

import asyncio
from functools import lru_cache
@lru_cache(1)
def get_cached_binance_http_client(
    clock: LiveClock,
    account_type: BinanceAccountType,
    api_key: str | None = None,
    api_secret: str | None = None,
    key_type: BinanceKeyType = BinanceKeyType.HMAC,
    base_url: str | None = None,
    is_testnet: bool = False,
    is_us: bool = False,
    proxy_url: str | None = None,
) -> BinanceHttpClient:
    """
    Cache and return a Binance HTTP client with the given key and secret.
    If a cached client with matching parameters already exists, the cached client will be returned.
    Parameters
    ----------
    clock : LiveClock
        The clock for the client.
    account_type : BinanceAccountType
        The account type for the client.
    api_key : str, optional
        The API key for the client.
    api_secret : str, optional
        The API secret for the client.
    key_type : BinanceKeyType, default 'HMAC'
        The private key cryptographic algorithm type.
    base_url : str, optional
        The base URL for the API endpoints.
    is_testnet : bool, default False
        If the client is connecting to the testnet API.
    is_us : bool, default False
        If the client is connecting to Binance US.
    proxy_url : str, optional
        The proxy URL for HTTP requests.
    Returns
    -------
    BinanceHttpClient
    """
    api_key = api_key or get_api_key(account_type, is_testnet)
    api_secret = api_secret or get_api_secret(account_type, is_testnet)
    default_http_base_url = get_http_base_url(account_type, is_testnet, is_us)
    match key_type:
        case BinanceKeyType.HMAC:
            rsa_private_key = None
            ed25519_private_key = None
        case BinanceKeyType.RSA:
            rsa_private_key = api_secret
            ed25519_private_key = None
        case BinanceKeyType.ED25519:
            rsa_private_key = None
            ed25519_private_key = api_secret
        case _:
            # Theoretically unreachable but retained to keep the match exhaustive
            raise ValueError(f"invalid `key_type`, was {key_type}")
    # Set up rate limit quotas
    global_key = "binance:global"
    if account_type.is_spot:
        # Spot
        global_quota = Quota.rate_per_minute(6000)
        ratelimiter_default_quota = global_quota
        ratelimiter_quotas: list[tuple[str, Quota]] = [
            (global_key, global_quota),
            ("binance:api/v3/order", Quota.rate_per_minute(3000)),
            ("binance:api/v3/allOrders", Quota.rate_per_minute(int(3000 / 20))),
            ("binance:api/v3/klines", Quota.rate_per_minute(600)),
        ]
    else:
        # Futures
        global_quota = Quota.rate_per_minute(2400)
        ratelimiter_default_quota = global_quota
        ratelimiter_quotas = [
            (global_key, global_quota),
            ("binance:fapi/v1/order", Quota.rate_per_minute(1200)),
            ("binance:fapi/v1/allOrders", Quota.rate_per_minute(int(1200 / 20))),
            ("binance:fapi/v1/klines", Quota.rate_per_minute(600)),
        ]
    return BinanceHttpClient(
        clock=clock,
        api_key=api_key,
        api_secret=api_secret,
        key_type=key_type,
        rsa_private_key=rsa_private_key,
        ed25519_private_key=ed25519_private_key,
        base_url=base_url or default_http_base_url,
        ratelimiter_quotas=ratelimiter_quotas,
        ratelimiter_default_quota=ratelimiter_default_quota,
        proxy_url=proxy_url,
    )
@lru_cache(1)
def get_cached_binance_spot_instrument_provider(
    client: BinanceHttpClient,
    clock: LiveClock,
    account_type: BinanceAccountType,
    is_testnet: bool,
    config: InstrumentProviderConfig,
    venue: Venue,
) -> BinanceSpotInstrumentProvider:
    """
    Cache and return an instrument provider for the Binance Spot/Margin exchange.
    If a cached provider already exists, then that provider will be returned.
    Parameters
    ----------
    client : BinanceHttpClient
        The client for the instrument provider.
    clock : LiveClock
        The clock for the instrument provider.
    account_type : BinanceAccountType
        The Binance account type for the instrument provider.
    is_testnet : bool, default False
        If the provider is for the Spot testnet.
    config : InstrumentProviderConfig
        The configuration for the instrument provider.
    venue : Venue
        The venue for the instrument provider.
    Returns
    -------
    BinanceSpotInstrumentProvider
    """
    return BinanceSpotInstrumentProvider(
        client=client,
        clock=clock,
        account_type=account_type,
        is_testnet=is_testnet,
        config=config,
        venue=venue,
    )
@lru_cache(1)
def get_cached_binance_futures_instrument_provider(
    client: BinanceHttpClient,
    clock: LiveClock,
    account_type: BinanceAccountType,
    config: InstrumentProviderConfig,
    venue: Venue,
) -> BinanceFuturesInstrumentProvider:
    """
    Cache and return an instrument provider for the Binance Futures exchange.
    If a cached provider already exists, then that provider will be returned.
    Parameters
    ----------
    client : BinanceHttpClient
        The client for the instrument provider.
    clock : LiveClock
        The clock for the instrument provider.
    account_type : BinanceAccountType
        The Binance account type for the instrument provider.
    config : InstrumentProviderConfig
        The configuration for the instrument provider.
    venue : Venue
        The venue for the instrument provider.
    Returns
    -------
    BinanceFuturesInstrumentProvider
    """
    return BinanceFuturesInstrumentProvider(
        client=client,
        clock=clock,
        account_type=account_type,
        config=config,
        venue=venue,
    )
class BinanceLiveDataClientFactory(LiveDataClientFactory):
    """
    Provides a Binance live data client factory.
    """
    @staticmethod
    def create(  # type: ignore
        loop: asyncio.AbstractEventLoop,
        name: str,
        config: BinanceDataClientConfig,
        msgbus: MessageBus,
        cache: Cache,
        clock: LiveClock,
    ) -> BinanceSpotDataClient | BinanceFuturesDataClient:
        """
        Create a new Binance data client.
        Parameters
        ----------
        loop : asyncio.AbstractEventLoop
            The event loop for the client.
        name : str
            The custom client ID.
        config : BinanceDataClientConfig
            The client configuration.
        msgbus : MessageBus
            The message bus for the client.
        cache : Cache
            The cache for the client.
        clock : LiveClock
            The clock for the client.
        Returns
        -------
        BinanceSpotDataClient or BinanceFuturesDataClient
        Raises
        ------
        ValueError
            If `config.account_type` is not a valid `BinanceAccountType`.
        """
        # Get HTTP client singleton
        client: BinanceHttpClient = get_cached_binance_http_client(
            clock=clock,
            account_type=config.account_type,
            api_key=config.api_key,
            api_secret=config.api_secret,
            key_type=config.key_type,
            base_url=config.base_url_http,
            is_testnet=config.testnet,
            is_us=config.us,
            proxy_url=config.proxy_url,
        )
        default_base_url_ws: str = get_ws_base_url(
            account_type=config.account_type,
            is_testnet=config.testnet,
            is_us=config.us,
        )
        provider: BinanceSpotInstrumentProvider | BinanceFuturesInstrumentProvider
        if config.account_type.is_spot_or_margin:
            # Get instrument provider singleton
            provider = get_cached_binance_spot_instrument_provider(
                client=client,
                clock=clock,
                account_type=config.account_type,
                is_testnet=config.testnet,
                config=config.instrument_provider,
                venue=config.venue,
            )
            return BinanceSpotDataClient(
                loop=loop,
                client=client,
                msgbus=msgbus,
                cache=cache,
                clock=clock,
                instrument_provider=provider,
                account_type=config.account_type,
                base_url_ws=config.base_url_ws or default_base_url_ws,
                name=name,
                config=config,
            )
        else:
            # Get instrument provider singleton
            provider = get_cached_binance_futures_instrument_provider(
                client=client,
                clock=clock,
                account_type=config.account_type,
                config=config.instrument_provider,
                venue=config.venue,
            )
            return BinanceFuturesDataClient(
                loop=loop,
                client=client,
                msgbus=msgbus,
                cache=cache,
                clock=clock,
                instrument_provider=provider,
                account_type=config.account_type,
                base_url_ws=config.base_url_ws or default_base_url_ws,
                name=name,
                config=config,
            )
class BinanceLiveExecClientFactory(LiveExecClientFactory):
    """
    Provides a Binance live execution client factory.
    """
    @staticmethod
    def create(  # type: ignore
        loop: asyncio.AbstractEventLoop,
        name: str,
        config: BinanceExecClientConfig,
        msgbus: MessageBus,
        cache: Cache,
        clock: LiveClock,
    ) -> BinanceSpotExecutionClient | BinanceFuturesExecutionClient:
        """
        Create a new Binance execution client.
        Parameters
        ----------
        loop : asyncio.AbstractEventLoop
            The event loop for the client.
        name : str
            The custom client ID.
        config : BinanceExecClientConfig
            The configuration for the client.
        msgbus : MessageBus
            The message bus for the client.
        cache : Cache
            The cache for the client.
        clock : LiveClock
            The clock for the client.
        Returns
        -------
        BinanceExecutionClient
        Raises
        ------
        ValueError
            If `config.account_type` is not a valid `BinanceAccountType`.
        """
        # Get HTTP client singleton
        client: BinanceHttpClient = get_cached_binance_http_client(
            clock=clock,
            account_type=config.account_type,
            api_key=config.api_key,
            api_secret=config.api_secret,
            key_type=config.key_type,
            base_url=config.base_url_http,
            is_testnet=config.testnet,
            is_us=config.us,
            proxy_url=config.proxy_url,
        )
        default_base_url_ws: str = get_ws_base_url(
            account_type=config.account_type,
            is_testnet=config.testnet,
            is_us=config.us,
        )
        provider: BinanceSpotInstrumentProvider | BinanceFuturesInstrumentProvider
        if config.account_type.is_spot or config.account_type.is_margin:
            # Get instrument provider singleton
            provider = get_cached_binance_spot_instrument_provider(
                client=client,
                clock=clock,
                account_type=config.account_type,
                is_testnet=config.testnet,
                config=config.instrument_provider,
                venue=config.venue,
            )
            return BinanceSpotExecutionClient(
                loop=loop,
                client=client,
                msgbus=msgbus,
                cache=cache,
                clock=clock,
                instrument_provider=provider,
                base_url_ws=config.base_url_ws or default_base_url_ws,
                account_type=config.account_type,
                name=name,
                config=config,
            )
        else:
            # Get instrument provider singleton
            provider = get_cached_binance_futures_instrument_provider(
                client=client,
                clock=clock,
                account_type=config.account_type,
                config=config.instrument_provider,
                venue=config.venue,
            )
            return BinanceFuturesExecutionClient(
                loop=loop,
                client=client,
                msgbus=msgbus,
                cache=cache,
                clock=clock,
                instrument_provider=provider,
                base_url_ws=config.base_url_ws or default_base_url_ws,
                account_type=config.account_type,
                name=name,
                config=config,
            )
</document_content>
</document>
<document index="1747">
<source>nautilus_trader/adapters/binance/futures/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="1748">
<source>nautilus_trader/adapters/binance/futures/data.py</source>
<document_content>

import asyncio
import msgspec
class BinanceFuturesDataClient(BinanceCommonDataClient):
    """
    Provides a data client for the Binance Futures exchange.
    Parameters
    ----------
    loop : asyncio.AbstractEventLoop
        The event loop for the client.
    client : BinanceHttpClient
        The Binance HTTP client.
    msgbus : MessageBus
        The message bus for the client.
    cache : Cache
        The cache for the client.
    clock : LiveClock
        The clock for the client.
    instrument_provider : InstrumentProvider
        The instrument provider.
    base_url_ws : str
        The base URL for the WebSocket client.
    config : BinanceDataClientConfig
        The configuration for the client.
    account_type : BinanceAccountType, default 'USDT_FUTURES'
        The account type for the client.
    name : str, optional
        The custom client ID.
    """
    def __init__(
        self,
        loop: asyncio.AbstractEventLoop,
        client: BinanceHttpClient,
        msgbus: MessageBus,
        cache: Cache,
        clock: LiveClock,
        instrument_provider: InstrumentProvider,
        base_url_ws: str,
        config: BinanceDataClientConfig,
        account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURES,
        name: str | None = None,
    ) -> None:
        PyCondition.is_true(
            account_type.is_futures,
            "account_type was not USDT_FUTURES or COIN_FUTURES",
        )
        # Futures HTTP API
        self._futures_http_market = BinanceFuturesMarketHttpAPI(client, account_type)
        # Futures enum parser
        self._futures_enum_parser = BinanceFuturesEnumParser()
        # Instantiate common base class
        super().__init__(
            loop=loop,
            client=client,
            market=self._futures_http_market,
            enum_parser=self._futures_enum_parser,
            msgbus=msgbus,
            cache=cache,
            clock=clock,
            instrument_provider=instrument_provider,
            account_type=account_type,
            base_url_ws=base_url_ws,
            name=name,
            config=config,
        )
        # Register additional futures websocket handlers
        self._ws_handlers["@markPrice"] = self._handle_mark_price
        self._ws_handlers["!markPrice@arr"] = self._handle_mark_price_all
        # Websocket msgspec decoders
        self._decoder_futures_trade_msg = msgspec.json.Decoder(BinanceFuturesTradeMsg)
        self._decoder_futures_mark_price_msg = msgspec.json.Decoder(BinanceFuturesMarkPriceMsg)
        self._decoder_futures_mark_price_all_msg = msgspec.json.Decoder(
            BinanceFuturesMarkPriceAllMsg,
        )
    # -- WEBSOCKET HANDLERS ---------------------------------------------------------------------------------
    def _handle_book_partial_update(self, raw: bytes) -> None:
        msg = self._decoder_order_book_msg.decode(raw)
        instrument_id: InstrumentId = self._get_cached_instrument_id(msg.data.s)
        book_snapshot: OrderBookDeltas = msg.data.parse_to_order_book_deltas(
            instrument_id=instrument_id,
            ts_init=self._clock.timestamp_ns(),
            snapshot=True,
        )
        # Check if book buffer active
        book_buffer: list[OrderBookDelta | OrderBookDeltas] | None = self._book_buffer.get(
            instrument_id,
        )
        if book_buffer is not None:
            book_buffer.append(book_snapshot)
        else:
            self._handle_data(book_snapshot)
    def _handle_trade(self, raw: bytes) -> None:
        # NOTE @trade is an undocumented endpoint for Futures exchanges
        msg = self._decoder_futures_trade_msg.decode(raw)
        instrument_id: InstrumentId = self._get_cached_instrument_id(msg.data.s)
        try:
            trade_tick: TradeTick = msg.data.parse_to_trade_tick(
                instrument_id=instrument_id,
                ts_init=self._clock.timestamp_ns(),
            )
        except ValueError as e:
            self._log.debug(f"Error handling trade tick message {raw!r}, {e}")
        else:
            self._handle_data(trade_tick)
    def _handle_mark_price_data(self, data: BinanceFuturesMarkPriceData) -> None:
        instrument_id: InstrumentId = self._get_cached_instrument_id(data.s)
        data = data.parse_to_binance_futures_mark_price_update(
            instrument_id=instrument_id,
            ts_init=self._clock.timestamp_ns(),
        )
        data_type = DataType(
            BinanceFuturesMarkPriceUpdate,
            metadata={"instrument_id": instrument_id},
        )
        generic = CustomData(data_type=data_type, data=data)
        self._handle_data(generic)
        self._handle_data(
            MarkPriceUpdate(
                data.instrument_id,
                data.mark,
                data.ts_event,
                data.ts_init,
            ),
        )
    def _handle_mark_price(self, raw: bytes) -> None:
        msg = self._decoder_futures_mark_price_msg.decode(raw)
        self._handle_mark_price_data(msg.data)
    def _handle_mark_price_all(self, raw: bytes) -> None:
        msg = self._decoder_futures_mark_price_all_msg.decode(raw)
        for data in msg.data:
            self._handle_mark_price_data(data)
</document_content>
</document>
<document index="1749">
<source>nautilus_trader/adapters/binance/futures/enums.py</source>
<document_content>

"""
Defines Binance Futures specific enums.
References
----------
https://binance-docs.github.io/apidocs/futures/en/#public-endpoints-info
"""
from decimal import Decimal
from enum import Enum
from enum import unique
@unique
class BinanceFuturesContractType(Enum):
    """
    Represents a Binance Futures derivatives contract type.
    """
    PERPETUAL = "PERPETUAL"
    CURRENT_MONTH = "CURRENT_MONTH"
    NEXT_MONTH = "NEXT_MONTH"
    CURRENT_QUARTER = "CURRENT_QUARTER"
    NEXT_QUARTER = "NEXT_QUARTER"
    PERPETUAL_DELIVERING = "PERPETUAL_DELIVERING"
    CURRENT_QUARTER_DELIVERING = "CURRENT_QUARTER DELIVERING"  # Underscore omission intentional
@unique
class BinanceFuturesContractStatus(Enum):
    """
    Represents a Binance Futures contract status.
    """
    PENDING_TRADING = "PENDING_TRADING"
    TRADING = "TRADING"
    PRE_DELIVERING = "PRE_DELIVERING"
    DELIVERING = "DELIVERING"
    DELIVERED = "DELIVERED"
    PRE_SETTLE = "PRE_SETTLE"
    SETTLING = "SETTLING"
    CLOSE = "CLOSE"
@unique
class BinanceFuturesWorkingType(Enum):
    """
    Represents a Binance Futures working type.
    """
    MARK_PRICE = "MARK_PRICE"
    CONTRACT_PRICE = "CONTRACT_PRICE"
@unique
class BinanceFuturesMarginType(Enum):
    """
    Represents a Binance Futures margin type.
    """
    ISOLATED = "ISOLATED"
    CROSS = "CROSSED"
@unique
class BinanceFuturesPositionUpdateReason(Enum):
    """
    Represents a Binance Futures position and balance update reason.
    """
    DEPOSIT = "DEPOSIT"
    WITHDRAW = "WITHDRAW"
    ORDER = "ORDER"
    FUNDING_FEE = "FUNDING_FEE"
    WITHDRAW_REJECT = "WITHDRAW_REJECT"
    ADJUSTMENT = "ADJUSTMENT"
    INSURANCE_CLEAR = "INSURANCE_CLEAR"
    ADMIN_DEPOSIT = "ADMIN_DEPOSIT"
    ADMIN_WITHDRAW = "ADMIN_WITHDRAW"
    MARGIN_TRANSFER = "MARGIN_TRANSFER"
    MARGIN_TYPE_CHANGE = "MARGIN_TYPE_CHANGE"
    ASSET_TRANSFER = "ASSET_TRANSFER"
    OPTIONS_PREMIUM_FEE = "OPTIONS_PREMIUM_FEE"
    OPTIONS_SETTLE_PROFIT = "OPTIONS_SETTLE_PROFIT"
    AUTO_EXCHANGE = "AUTO_EXCHANGE"
    COIN_SWAP_DEPOSIT = "COIN_SWAP_DEPOSIT"
    COIN_SWAP_WITHDRAW = "COIN_SWAP_WITHDRAW"
@unique
class BinanceFuturesEventType(Enum):
    """
    Represents a Binance Futures event type.
    """
    LISTEN_KEY_EXPIRED = "listenKeyExpired"
    MARGIN_CALL = "MARGIN_CALL"
    ACCOUNT_UPDATE = "ACCOUNT_UPDATE"
    ORDER_TRADE_UPDATE = "ORDER_TRADE_UPDATE"
    ACCOUNT_CONFIG_UPDATE = "ACCOUNT_CONFIG_UPDATE"
    TRADE_LITE = "TRADE_LITE"
    STRATEGY_UPDATE = "STRATEGY_UPDATE"
    GRID_UPDATE = "GRID_UPDATE"
    CONDITIONAL_ORDER_TRIGGER_REJECT = "CONDITIONAL_ORDER_TRIGGER_REJECT"
class BinanceFuturesEnumParser(BinanceEnumParser):
    """
    Provides parsing methods for enums used by the 'Binance Futures' exchange.
    """
    def __init__(self) -> None:
        super().__init__()
        self.futures_ext_to_int_order_type = {
            BinanceOrderType.LIMIT: OrderType.LIMIT,
            BinanceOrderType.MARKET: OrderType.MARKET,
            BinanceOrderType.STOP: OrderType.STOP_LIMIT,
            BinanceOrderType.STOP_MARKET: OrderType.STOP_MARKET,
            BinanceOrderType.TAKE_PROFIT: OrderType.LIMIT_IF_TOUCHED,
            BinanceOrderType.TAKE_PROFIT_MARKET: OrderType.MARKET_IF_TOUCHED,
            BinanceOrderType.TRAILING_STOP_MARKET: OrderType.TRAILING_STOP_MARKET,
        }
        self.futures_int_to_ext_order_type = {
            b: a for a, b in self.futures_ext_to_int_order_type.items()
        }
        self.futures_valid_time_in_force = {
            TimeInForce.GTC,
            TimeInForce.GTD,
            TimeInForce.FOK,
            TimeInForce.IOC,
        }
        self.futures_valid_order_types = {
            OrderType.MARKET,
            OrderType.LIMIT,
            OrderType.STOP_MARKET,
            OrderType.STOP_LIMIT,
            OrderType.MARKET_IF_TOUCHED,
            OrderType.LIMIT_IF_TOUCHED,
            OrderType.TRAILING_STOP_MARKET,
        }
    def parse_binance_order_type(self, order_type: BinanceOrderType) -> OrderType:
        try:
            return self.futures_ext_to_int_order_type[order_type]
        except KeyError:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"unrecognized Binance Futures order type, was {order_type}",  # pragma: no cover
            )
    def parse_internal_order_type(self, order: Order) -> BinanceOrderType:
        try:
            return self.futures_int_to_ext_order_type[order.order_type]
        except KeyError:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"unrecognized or unsupported internal order type, was {order.order_type}",  # pragma: no cover
            )
    def parse_binance_trigger_type(self, trigger_type: str) -> TriggerType:
        if trigger_type == BinanceFuturesWorkingType.CONTRACT_PRICE.value:
            return TriggerType.LAST_PRICE
        elif trigger_type == BinanceFuturesWorkingType.MARK_PRICE.value:
            return TriggerType.MARK_PRICE
        else:
            return None
    def parse_futures_position_side(
        self,
        net_size: Decimal,
    ) -> PositionSide:
        if net_size > 0:
            return PositionSide.LONG
        elif net_size < 0:
            return PositionSide.SHORT
        else:
            return PositionSide.FLAT
</document_content>
</document>
<document index="1750">
<source>nautilus_trader/adapters/binance/futures/execution.py</source>
<document_content>

import asyncio
from asyncio import TaskGroup
from decimal import Decimal
import msgspec
class BinanceFuturesExecutionClient(BinanceCommonExecutionClient):
    """
    Provides an execution client for the Binance Futures exchange.
    Parameters
    ----------
    loop : asyncio.AbstractEventLoop
        The event loop for the client.
    client : BinanceHttpClient
        The Binance HTTP client.
    msgbus : MessageBus
        The message bus for the client.
    cache : Cache
        The cache for the client.
    clock : LiveClock
        The clock for the client.
    instrument_provider : BinanceFuturesInstrumentProvider
        The instrument provider.
    base_url_ws : str
        The base URL for the WebSocket client.
    config : BinanceExecClientConfig
        The configuration for the client.
    account_type : BinanceAccountType, default 'USDT_FUTURES'
        The account type for the client.
    name : str, optional
        The custom client ID.
    """
    def __init__(
        self,
        loop: asyncio.AbstractEventLoop,
        client: BinanceHttpClient,
        msgbus: MessageBus,
        cache: Cache,
        clock: LiveClock,
        instrument_provider: BinanceFuturesInstrumentProvider,
        base_url_ws: str,
        config: BinanceExecClientConfig,
        account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURES,
        name: str | None = None,
    ) -> None:
        PyCondition.is_true(
            account_type.is_futures,
            "account_type was not USDT_FUTURES or COIN_FUTURES",
        )
        # Futures HTTP API
        self._futures_http_account = BinanceFuturesAccountHttpAPI(client, clock, account_type)
        self._futures_http_market = BinanceFuturesMarketHttpAPI(client, account_type)
        self._futures_http_user = BinanceFuturesUserDataHttpAPI(client, account_type)
        # Futures enum parser
        self._futures_enum_parser = BinanceFuturesEnumParser()
        # Instantiate common base class
        super().__init__(
            loop=loop,
            client=client,
            account=self._futures_http_account,
            market=self._futures_http_market,
            user=self._futures_http_user,
            enum_parser=self._futures_enum_parser,
            msgbus=msgbus,
            cache=cache,
            clock=clock,
            instrument_provider=instrument_provider,
            account_type=account_type,
            base_url_ws=base_url_ws,
            name=name,
            config=config,
        )
        # Register additional futures websocket user data event handlers
        self._futures_user_ws_handlers = {
            BinanceFuturesEventType.ACCOUNT_UPDATE: self._handle_account_update,
            BinanceFuturesEventType.ORDER_TRADE_UPDATE: self._handle_order_trade_update,
            BinanceFuturesEventType.MARGIN_CALL: self._handle_margin_call,
            BinanceFuturesEventType.ACCOUNT_CONFIG_UPDATE: self._handle_account_config_update,
            BinanceFuturesEventType.LISTEN_KEY_EXPIRED: self._handle_listen_key_expired,
            BinanceFuturesEventType.TRADE_LITE: self._handle_trade_lite,
        }
        self._use_trade_lite = config.use_trade_lite
        if self._use_trade_lite:
            self._log.info("TRADE_LITE events will be used", LogColor.BLUE)
        self._leverages = config.futures_leverages
        self._margin_types = config.futures_margin_types
        # WebSocket futures schema decoders
        self._decoder_futures_user_msg_wrapper = msgspec.json.Decoder(BinanceFuturesUserMsgWrapper)
        self._decoder_futures_order_update_wrapper = msgspec.json.Decoder(
            BinanceFuturesOrderUpdateWrapper,
        )
        self._decoder_futures_account_update_wrapper = msgspec.json.Decoder(
            BinanceFuturesAccountUpdateWrapper,
        )
        self._decoder_futures_trade_lite_wrapper = msgspec.json.Decoder(
            BinanceFuturesTradeLiteWrapper,
        )
    async def _update_account_state(self) -> None:
        account_info: BinanceFuturesAccountInfo = (
            await self._futures_http_account.query_futures_account_info(recv_window=str(5000))
        )
        if account_info.canTrade:
            self._log.info("Binance API key authenticated", LogColor.GREEN)
            self._log.info(f"API key {self._http_client.api_key} has trading permissions")
        else:
            self._log.error("Binance API key does not have trading permissions")
        self.generate_account_state(
            balances=account_info.parse_to_account_balances(),
            margins=account_info.parse_to_margin_balances(),
            reported=True,
            ts_event=millis_to_nanos(account_info.updateTime),
        )
        await self._await_account_registered(log_registered=False)
        if self._leverages:
            async with TaskGroup() as tg:
                leverage_tasks = [
                    tg.create_task(self._futures_http_account.set_leverage(symbol, leverage))
                    for symbol, leverage in self._leverages.items()
                ]
            for task in leverage_tasks:
                res: BinanceFuturesLeverage = task.result()
                self._log.info(f"Set default leverage {res.symbol} {res.leverage}X")
        if self._margin_types:
            async with TaskGroup() as tg:
                margin_tasks = [
                    (
                        tg.create_task(self._futures_http_account.set_margin_type(symbol, type_)),
                        symbol,
                        type_,
                    )
                    for symbol, type_ in self._margin_types.items()
                ]
            for _, symbol, type_ in margin_tasks:
                self._log.info(f"Set {symbol} margin type to {type_.value}")
        # Initialize leverage for all symbols using symbolConfig endpoint
        # This ensures leverage is set correctly even for symbols without active positions
        account: MarginAccount = self.get_account()
        symbol_configs = await self._futures_http_account.query_futures_symbol_config()
        for config in symbol_configs:
            try:
                instrument_id: InstrumentId = self._get_cached_instrument_id(config.symbol)
                leverage = Decimal(config.leverage)
                account.set_leverage(instrument_id, leverage)
                self._log.debug(f"Set leverage {config.symbol} {leverage}X")
            except KeyError:
                # Symbol not loaded in instrument provider, skip
                continue
    async def _init_dual_side_position(self) -> None:
        binance_futures_dual_side_position: BinanceFuturesDualSidePosition = (
            await self._futures_http_account.query_futures_hedge_mode()
        )
        # "true": Hedge Mode; "false": One-way Mode
        self._is_dual_side_position = binance_futures_dual_side_position.dualSidePosition
        if self._is_dual_side_position:
            PyCondition.is_false(
                self._use_reduce_only,
                "Cannot use `reduce_only` with Binance Hedge Mode",
            )
        self._log.info(f"Dual side position: {self._is_dual_side_position}", LogColor.BLUE)
    # -- EXECUTION REPORTS ------------------------------------------------------------------------
    async def _get_binance_position_status_reports(
        self,
        symbol: str | None = None,
    ) -> list[PositionStatusReport]:
        reports: list[PositionStatusReport] = []
        # Check Binance for all active positions
        binance_positions: list[BinanceFuturesPositionRisk]
        binance_positions = await self._futures_http_account.query_futures_position_risk(symbol)
        for position in binance_positions:
            if Decimal(position.positionAmt) == 0:
                continue  # Flat position
            report = position.parse_to_position_status_report(
                account_id=self.account_id,
                instrument_id=self._get_cached_instrument_id(position.symbol),
                report_id=UUID4(),
                enum_parser=self._futures_enum_parser,
                ts_init=self._clock.timestamp_ns(),
            )
            self._log.debug(f"Received {report}")
            reports.append(report)
        return reports
    async def _get_binance_active_position_symbols(
        self,
        symbol: str | None = None,
    ) -> set[str]:
        # Check Binance for all active positions
        active_symbols: set[str] = set()
        binance_positions: list[BinanceFuturesPositionRisk]
        binance_positions = await self._futures_http_account.query_futures_position_risk(symbol)
        for position in binance_positions:
            if Decimal(position.positionAmt) == 0:
                continue  # Flat position
            # Add active symbol
            active_symbols.add(position.symbol)
        return active_symbols
    # -- COMMAND HANDLERS -------------------------------------------------------------------------
    def _check_order_validity(self, order: Order) -> str | None:
        # Check order type valid
        if order.order_type not in self._futures_enum_parser.futures_valid_order_types:
            valid_types = [
                order_type_to_str(t) for t in self._futures_enum_parser.futures_valid_order_types
            ]
            return (
                f"UNSUPPORTED_ORDER_TYPE: {order_type_to_str(order.order_type)} "
                f"not supported for FUTURES accounts (valid: {valid_types})"
            )
        # Check time in force valid
        if order.time_in_force not in self._futures_enum_parser.futures_valid_time_in_force:
            valid_tifs = [
                time_in_force_to_str(t)
                for t in self._futures_enum_parser.futures_valid_time_in_force
            ]
            return (
                f"UNSUPPORTED_TIME_IN_FORCE: {time_in_force_to_str(order.time_in_force)} "
                f"not supported for FUTURES accounts (valid: {valid_tifs})"
            )
        # Check post-only
        if order.is_post_only and order.order_type != OrderType.LIMIT:
            return (
                f"UNSUPPORTED_POST_ONLY: {order_type_to_str(order.order_type)} post_only order "
                "not supported (only LIMIT post_only orders supported for FUTURES accounts)"
            )
        return None
    async def _batch_cancel_orders(self, command: BatchCancelOrders) -> None:
        valid_cancels = self._filter_valid_cancels(command.cancels)
        if not valid_cancels:
            self._log.info("No valid orders to cancel in batch")
            return
        successful_cancels, failed_cancels = await self._process_cancel_batches(
            valid_cancels,
            command.instrument_id.symbol.value,
        )
        self._log.info(
            f"Batch cancel completed: {len(successful_cancels)} successful, "
            f"{len(failed_cancels)} failed out of {len(valid_cancels)} valid orders",
        )
    def _filter_valid_cancels(self, cancels: list[CancelOrder]) -> list[CancelOrder]:
        # Filter out orders that are already closed or not found
        valid_cancels = []
        for cancel in cancels:
            order = self._cache.order(cancel.client_order_id)
            if order is None:
                # Note: Following single cancel behavior - log error but don't emit cancel rejected event
                # for orders not found in cache (may have been cancelled/filled via other means)
                self._log.error(f"{cancel.client_order_id!r} not found to cancel")
                continue
            if order.is_closed:
                self._log.warning(
                    f"BatchCancelOrders command for {cancel.client_order_id!r} when order already {order.status_string()} "
                    "(will not send to exchange)",
                )
                continue
            valid_cancels.append(cancel)
        return valid_cancels
    async def _process_cancel_batches(
        self,
        valid_cancels: list[CancelOrder],
        symbol: str,
    ) -> tuple[list[CancelOrder], list[CancelOrder]]:
        # Process cancel orders in batches of 10 (Binance API limit)
        batch_size = 10
        batches = [
            valid_cancels[i : i + batch_size] for i in range(0, len(valid_cancels), batch_size)
        ]
        # Process all batches concurrently for better latency
        batch_results = await asyncio.gather(
            *[self._cancel_order_batch(batch, symbol) for batch in batches],
            return_exceptions=True,
        )
        successful_cancels: list[CancelOrder] = []
        failed_cancels: list[CancelOrder] = []
        for result in batch_results:
            if isinstance(result, Exception):
                # If a batch failed with an exception, treat all orders in that batch as failed
                # This shouldn't normally happen as exceptions are handled in _cancel_order_batch
                self._log.error(f"Unexpected batch processing exception: {result}")
                continue
            success, failure = result  # type: ignore[misc]
            successful_cancels.extend(success)
            failed_cancels.extend(failure)
        return successful_cancels, failed_cancels
    async def _cancel_order_batch(
        self,
        batch: list[CancelOrder],
        symbol: str,
    ) -> tuple[list[CancelOrder], list[CancelOrder]]:
        batch_client_order_ids = [c.client_order_id.value for c in batch]
        self._log.debug(
            f"Attempting to cancel batch of {len(batch)} orders: {batch_client_order_ids}",
        )
        retry_manager = await self._retry_manager_pool.acquire()
        try:
            await retry_manager.run(
                "cancel_multiple_orders",
                batch_client_order_ids,
                self._futures_http_account.cancel_multiple_orders,
                symbol=symbol,
                client_order_ids=batch_client_order_ids,
            )
            if retry_manager.result:
                self._log.debug(f"Successfully cancelled batch: {batch_client_order_ids}")
                return batch, []
            else:
                self._log.error(
                    f"Failed to cancel batch: {batch_client_order_ids}, reason: {retry_manager.message}",
                )
                self._generate_cancel_rejected_events(batch, retry_manager.message)
                return [], batch
        except BinanceError as e:
            error_code = BinanceErrorCode(int(e.message["code"]))
            if error_code == BinanceErrorCode.CANCEL_REJECTED:
                self._log.warning(f"Cancel batch rejected: {e.message}")
            else:
                self._log.exception(f"Cannot cancel batch of orders: {e.message}", e)
            self._generate_cancel_rejected_events(batch, f"Batch cancel failed: {e.message}")
            return [], batch
        finally:
            await self._retry_manager_pool.release(retry_manager)
    def _generate_cancel_rejected_events(self, cancels: list[CancelOrder], reason: str) -> None:
        for cancel in cancels:
            self.generate_order_cancel_rejected(
                cancel.strategy_id,
                cancel.instrument_id,
                cancel.client_order_id,
                cancel.venue_order_id,
                reason,
                self._clock.timestamp_ns(),
            )
    # -- WEBSOCKET EVENT HANDLERS --------------------------------------------------------------------
    def _handle_user_ws_message(self, raw: bytes) -> None:
        try:
            wrapper = self._decoder_futures_user_msg_wrapper.decode(raw)
            if not wrapper.stream or not wrapper.data:
                return  # Control message response
            self._futures_user_ws_handlers[wrapper.data.e](raw)
        except Exception as e:
            self._log.exception(f"Error on handling {raw!r}", e)
    def _handle_account_update(self, raw: bytes) -> None:
        account_update = self._decoder_futures_account_update_wrapper.decode(raw)
        account_update.data.handle_account_update(self)
    def _handle_order_trade_update(self, raw: bytes) -> None:
        order_update = self._decoder_futures_order_update_wrapper.decode(raw)
        if not (self._use_trade_lite and order_update.data.o.x == BinanceExecutionType.TRADE):
            order_update.data.o.handle_order_trade_update(self)
    def _handle_margin_call(self, raw: bytes) -> None:
        self._log.warning("MARGIN CALL received")  # Implement
    def _handle_account_config_update(self, raw: bytes) -> None:
        self._log.info("Account config updated", LogColor.BLUE)  # Implement
    def _handle_listen_key_expired(self, raw: bytes) -> None:
        self._log.warning("Listen key expired")  # Implement
    def _handle_trade_lite(self, raw: bytes) -> None:
        trade_lite = self._decoder_futures_trade_lite_wrapper.decode(raw)
        if not self._use_trade_lite:
            self._log.debug(
                "TradeLite event received but not enabled in config",
            )
            return
        order_data = trade_lite.data.to_order_data()
        order_data.handle_order_trade_update(self)
</document_content>
</document>
<document index="1751">
<source>nautilus_trader/adapters/binance/futures/http/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="1752">
<source>nautilus_trader/adapters/binance/futures/http/account.py</source>
<document_content>

from typing import Any
import msgspec
class BinanceFuturesPositionModeHttp(BinanceHttpEndpoint):
    """
    Endpoint of user's position mode for every FUTURES symbol.
    `GET /fapi/v1/positionSide/dual`
    `GET /dapi/v1/positionSide/dual`
    `POST /fapi/v1/positionSide/dual`
    `POST /dapi/v1/positionSide/dual`
    References
    ----------
    https://binance-docs.github.io/apidocs/futures/en/#change-position-mode-trade
    https://binance-docs.github.io/apidocs/delivery/en/#change-position-mode-trade
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.USER_DATA,
            HttpMethod.POST: BinanceSecurityType.TRADE,
        }
        url_path = base_endpoint + "positionSide/dual"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_resp_decoder = msgspec.json.Decoder(BinanceFuturesDualSidePosition)
        self._post_resp_decoder = msgspec.json.Decoder(BinanceStatusCode)
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Parameters of positionSide/dual GET request.
        Parameters
        ----------
        timestamp : str
            The millisecond timestamp of the request.
        recvWindow : str, optional
            The response receive window for the request (cannot be greater than 60000).
        """
        timestamp: str
        recvWindow: str | None = None
    class PostParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Parameters of positionSide/dual POST request.
        Parameters
        ----------
        timestamp : str
            The millisecond timestamp of the request.
        dualSidePosition : str ('true', 'false')
            The dual side position mode to set...
            `true`: Hedge Mode, `false`: One-way mode.
        recvWindow : str, optional
            The response receive window for the request (cannot be greater than 60000).
        """
        timestamp: str
        dualSidePosition: str
        recvWindow: str | None = None
    async def get(self, params: GetParameters) -> BinanceFuturesDualSidePosition:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._get_resp_decoder.decode(raw)
    async def post(self, params: PostParameters) -> BinanceStatusCode:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._post_resp_decoder.decode(raw)
class BinanceFuturesAllOpenOrdersHttp(BinanceHttpEndpoint):
    """
    Endpoint of all open FUTURES orders.
    `DELETE /fapi/v1/allOpenOrders`
    `DELETE /dapi/v1/allOpenOrders`
    References
    ----------
    https://binance-docs.github.io/apidocs/futures/en/#cancel-all-open-orders-trade
    https://binance-docs.github.io/apidocs/delivery/en/#cancel-all-open-orders-trade
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.DELETE: BinanceSecurityType.TRADE,
        }
        url_path = base_endpoint + "allOpenOrders"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._delete_resp_decoder = msgspec.json.Decoder(BinanceStatusCode)
    class DeleteParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Parameters of allOpenOrders DELETE request.
        Parameters
        ----------
        timestamp : str
            The millisecond timestamp of the request.
        symbol : BinanceSymbol
            The symbol of the request
        recvWindow : str, optional
            The response receive window for the request (cannot be greater than 60000).
        """
        timestamp: str
        symbol: BinanceSymbol
        recvWindow: str | None = None
    async def delete(self, params: DeleteParameters) -> BinanceStatusCode:
        method_type = HttpMethod.DELETE
        raw = await self._method(method_type, params)
        return self._delete_resp_decoder.decode(raw)
class BinanceFuturesCancelMultipleOrdersHttp(BinanceHttpEndpoint):
    """
    Endpoint of cancel multiple FUTURES orders.
    `DELETE /fapi/v1/batchOrders`
    `DELETE /dapi/v1/batchOrders`
    References
    ----------
    https://binance-docs.github.io/apidocs/futures/en/#cancel-multiple-orders-trade
    https://binance-docs.github.io/apidocs/delivery/en/#cancel-multiple-orders-trade
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.DELETE: BinanceSecurityType.TRADE,
        }
        url_path = base_endpoint + "batchOrders"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._delete_resp_decoder = msgspec.json.Decoder(
            list[BinanceOrder] | dict[str, Any],
            strict=False,
        )
    class DeleteParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Parameters of batchOrders DELETE request.
        Parameters
        ----------
        timestamp : str
            The millisecond timestamp of the request.
        symbol : BinanceSymbol
            The symbol of the request
        recvWindow : str, optional
            The response receive window for the request (cannot be greater than 60000).
        """
        timestamp: str
        symbol: BinanceSymbol
        orderIdList: str | None = None
        origClientOrderIdList: str | None = None
        recvWindow: str | None = None
    async def delete(self, params: DeleteParameters) -> list[BinanceOrder]:
        method_type = HttpMethod.DELETE
        raw = await self._method(method_type, params)
        return self._delete_resp_decoder.decode(raw)
class BinanceFuturesAccountHttp(BinanceHttpEndpoint):
    """
    Endpoint of current FUTURES account information.
    `GET /fapi/v2/account`
    `GET /dapi/v1/account`
    References
    ----------
    https://binance-docs.github.io/apidocs/futures/en/#account-information-v2-user_data
    https://binance-docs.github.io/apidocs/delivery/en/#account-information-user_data
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.USER_DATA,
        }
        url_path = base_endpoint + "account"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._resp_decoder = msgspec.json.Decoder(BinanceFuturesAccountInfo)
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Parameters of account GET request.
        Parameters
        ----------
        timestamp : str
            The millisecond timestamp of the request.
        recvWindow : str, optional
            The response receive window for the request (cannot be greater than 60000).
        """
        timestamp: str
        recvWindow: str | None = None
    async def get(self, params: GetParameters) -> BinanceFuturesAccountInfo:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._resp_decoder.decode(raw)
class BinanceFuturesPositionRiskHttp(BinanceHttpEndpoint):
    """
    Endpoint of information of all FUTURES positions.
    `GET /fapi/v3/positionRisk`
    `GET /dapi/v1/positionRisk`
    References
    ----------
    https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V3
    https://binance-docs.github.io/apidocs/delivery/en/#position-information-user_data
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.USER_DATA,
        }
        url_path = base_endpoint + "positionRisk"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_resp_decoder = msgspec.json.Decoder(list[BinanceFuturesPositionRisk])
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Parameters of positionRisk GET request.
        Parameters
        ----------
        timestamp : str
            The millisecond timestamp of the request.
        symbol : BinanceSymbol, optional
            The symbol of the request.
        recvWindow : str, optional
            The response receive window for the request (cannot be greater than 60000).
        """
        timestamp: str
        symbol: BinanceSymbol | None = None
        recvWindow: str | None = None
    async def get(self, params: GetParameters) -> list[BinanceFuturesPositionRisk]:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._get_resp_decoder.decode(raw)
class BinanceFuturesSymbolConfigHttp(BinanceHttpEndpoint):
    """
    Endpoint for symbol configuration.
    `GET /fapi/v1/symbolConfig`
    References
    ----------
    https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Symbol-Config
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.USER_DATA,
        }
        url_path = base_endpoint + "symbolConfig"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_resp_decoder = msgspec.json.Decoder(list[BinanceFuturesSymbolConfig])
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Parameters of symbolConfig GET request.
        Parameters
        ----------
        timestamp : str
            The millisecond timestamp of the request.
        symbol : BinanceSymbol, optional
            The symbol of the request.
        recvWindow : str, optional
            The response receive window for the request (cannot be greater than 60000).
        """
        timestamp: str
        symbol: BinanceSymbol | None = None
        recvWindow: str | None = None
    async def get(self, params: GetParameters) -> list[BinanceFuturesSymbolConfig]:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._get_resp_decoder.decode(raw)
class BinanceFuturesLeverageHttp(BinanceHttpEndpoint):
    """
    Initial leverage.
    `POST /fapi/v1/leverage`
    References
    ----------
    https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Initial-Leverage
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.POST: BinanceSecurityType.TRADE,
        }
        url_path = base_endpoint + "leverage"
        super().__init__(client, methods, url_path)
        self._resp_decoder = msgspec.json.Decoder(BinanceFuturesLeverage)
    class PostParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Initial leverage POST endpoint parameters.
        Parameters
        ----------
        symbol : BinanceSymbol
        leverage : PositiveInt
            Target initial leverage: int from 1 to 125
        timestamp : str
            The millisecond timestamp of the request.
        recvWindow : str, optional
            The response receive window in milliseconds for the request.
        """
        symbol: BinanceSymbol
        leverage: PositiveInt
        timestamp: str
        recvWindow: str | None = None
    async def post(
        self,
        params: PostParameters,
    ) -> BinanceFuturesLeverage:
        method_type = HttpMethod.POST
        raw = await self._method(method_type, params)
        return self._resp_decoder.decode(raw)
class BinanceFuturesMarginTypeHttp(BinanceHttpEndpoint):
    """
    Margin type.
    `POST /fapi/v1/marginType`
    References
    ----------
    https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Margin-Type
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.POST: BinanceSecurityType.TRADE,
        }
        url_path = base_endpoint + "marginType"
        super().__init__(client, methods, url_path)
        self._resp_decoder = msgspec.json.Decoder(BinanceFuturesMarginTypeResponse)
    class PostParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Margin type POST endpoint parameters.
        Parameters
        ----------
        symbol : BinanceSymbol
        marginType : str
            ISOLATED or CROSSED
        timestamp : str
            The millisecond timestamp of the request.
        recvWindow : str, optional
            The response receive window in milliseconds for the request.
        """
        symbol: BinanceSymbol
        marginType: str
        timestamp: str
        recvWindow: str | None = None
    async def post(
        self,
        params: PostParameters,
    ) -> BinanceFuturesMarginTypeResponse:
        try:
            raw = await self._method(HttpMethod.POST, params)
        except BinanceClientError as e:
            if e.message["msg"] == "No need to change margin type.":
                return BinanceFuturesMarginTypeResponse(code=200, msg="success")
            raise
        return self._resp_decoder.decode(raw)
class BinanceFuturesAccountHttpAPI(BinanceAccountHttpAPI):
    """
    Provides access to the Binance Futures Account/Trade HTTP REST API.
    Parameters
    ----------
    client : BinanceHttpClient
        The Binance REST API client.
    account_type : BinanceAccountType
        The Binance account type.
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        clock: LiveClock,
        account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURES,
    ):
        super().__init__(
            client=client,
            clock=clock,
            account_type=account_type,
        )
        if not account_type.is_futures:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"`BinanceAccountType` not USDT_FUTURES or COIN_FUTURES, was {account_type}",  # pragma: no cover
            )
        v2_endpoint_base = self.base_endpoint
        v3_endpoint_base = self.base_endpoint
        if account_type == BinanceAccountType.USDT_FUTURES:
            v2_endpoint_base = "/fapi/v2/"
            v3_endpoint_base = "/fapi/v3/"
        # Create endpoints
        self._endpoint_futures_position_mode = BinanceFuturesPositionModeHttp(
            client,
            self.base_endpoint,
        )
        self._endpoint_futures_all_open_orders = BinanceFuturesAllOpenOrdersHttp(
            client,
            self.base_endpoint,
        )
        self._endpoint_futures_cancel_multiple_orders = BinanceFuturesCancelMultipleOrdersHttp(
            client,
            self.base_endpoint,
        )
        self._endpoint_futures_account = BinanceFuturesAccountHttp(client, v2_endpoint_base)
        self._endpoint_futures_position_risk = BinanceFuturesPositionRiskHttp(
            client,
            v3_endpoint_base,
        )
        self._endpoint_futures_leverage = BinanceFuturesLeverageHttp(client, self.base_endpoint)
        self._endpoint_futures_margin_type = BinanceFuturesMarginTypeHttp(
            client,
            self.base_endpoint,
        )
        self._endpoint_futures_symbol_config = BinanceFuturesSymbolConfigHttp(
            client,
            self.base_endpoint,
        )
    async def query_futures_hedge_mode(
        self,
        recv_window: str | None = None,
    ) -> BinanceFuturesDualSidePosition:
        """
        Check Binance Futures hedge mode (dualSidePosition).
        """
        return await self._endpoint_futures_position_mode.get(
            params=self._endpoint_futures_position_mode.GetParameters(
                timestamp=self._timestamp(),
                recvWindow=recv_window,
            ),
        )
    async def set_leverage(
        self,
        symbol: BinanceSymbol,
        leverage: PositiveInt,
        recv_window: str | None = None,
    ) -> BinanceFuturesLeverage:
        """
        Set Binance Futures initial leverage.
        """
        return await self._endpoint_futures_leverage.post(
            self._endpoint_futures_leverage.PostParameters(
                symbol=symbol,
                leverage=leverage,
                timestamp=self._timestamp(),
                recvWindow=recv_window,
            ),
        )
    async def set_margin_type(
        self,
        symbol: BinanceSymbol,
        margin_type: BinanceFuturesMarginType,
        recv_window: str | None = None,
    ) -> BinanceFuturesMarginTypeResponse:
        """
        Change symbol level margin type.
        :param symbol : BinanceSymbol
        :param margin_type : BinanceFuturesMarginType
        :param recv_window : str, optional
        :return: BinanceFuturesMarginTypeResponse
        """
        return await self._endpoint_futures_margin_type.post(
            self._endpoint_futures_margin_type.PostParameters(
                symbol=symbol,
                marginType=margin_type.value,
                timestamp=self._timestamp(),
                recvWindow=recv_window,
            ),
        )
    async def set_futures_hedge_mode(
        self,
        dual_side_position: bool,
        recv_window: str | None = None,
    ) -> BinanceStatusCode:
        """
        Set Binance Futures hedge mode (dualSidePosition).
        """
        return await self._endpoint_futures_position_mode.post(
            params=self._endpoint_futures_position_mode.PostParameters(
                timestamp=self._timestamp(),
                dualSidePosition=str(dual_side_position).lower(),
                recvWindow=recv_window,
            ),
        )
    async def cancel_all_open_orders(
        self,
        symbol: str,
        recv_window: str | None = None,
    ) -> bool:
        """
        Delete all Futures open orders.
        Returns whether successful.
        """
        response = await self._endpoint_futures_all_open_orders.delete(
            params=self._endpoint_futures_all_open_orders.DeleteParameters(
                timestamp=self._timestamp(),
                symbol=BinanceSymbol(symbol),
                recvWindow=recv_window,
            ),
        )
        return response.code == 200
    async def cancel_multiple_orders(
        self,
        symbol: str,
        client_order_ids: list[str],
        recv_window: str | None = None,
    ) -> bool:
        """
        Delete multiple Futures orders.
        Returns whether successful.
        """
        stringified_client_order_ids = str(client_order_ids).replace(" ", "").replace("'", '"')
        await self._endpoint_futures_cancel_multiple_orders.delete(
            params=self._endpoint_futures_cancel_multiple_orders.DeleteParameters(
                timestamp=self._timestamp(),
                symbol=BinanceSymbol(symbol),
                origClientOrderIdList=stringified_client_order_ids,
                recvWindow=recv_window,
            ),
        )
        return True
    async def query_futures_account_info(
        self,
        recv_window: str | None = None,
    ) -> BinanceFuturesAccountInfo:
        """
        Check Binance Futures account information.
        """
        return await self._endpoint_futures_account.get(
            params=self._endpoint_futures_account.GetParameters(
                timestamp=self._timestamp(),
                recvWindow=recv_window,
            ),
        )
    async def query_futures_position_risk(
        self,
        symbol: str | None = None,
        recv_window: str | None = None,
    ) -> list[BinanceFuturesPositionRisk]:
        """
        Check all Futures position's info for a symbol.
        """
        return await self._endpoint_futures_position_risk.get(
            params=self._endpoint_futures_position_risk.GetParameters(
                timestamp=self._timestamp(),
                symbol=BinanceSymbol(symbol) if symbol else None,
                recvWindow=recv_window,
            ),
        )
    async def query_futures_symbol_config(
        self,
        symbol: str | None = None,
        recv_window: str | None = None,
    ) -> list[BinanceFuturesSymbolConfig]:
        """
        Check Futures symbol configuration including leverage settings.
        """
        return await self._endpoint_futures_symbol_config.get(
            params=self._endpoint_futures_symbol_config.GetParameters(
                timestamp=self._timestamp(),
                symbol=BinanceSymbol(symbol) if symbol else None,
                recvWindow=recv_window,
            ),
        )
</document_content>
</document>
<document index="1753">
<source>nautilus_trader/adapters/binance/futures/http/market.py</source>
<document_content>

import msgspec
class BinanceFuturesExchangeInfoHttp(BinanceHttpEndpoint):
    """
    Endpoint of FUTURES exchange trading rules and symbol information.
    `GET /fapi/v1/exchangeInfo`
    `GET /dapi/v1/exchangeInfo`
    References
    ----------
    https://binance-docs.github.io/apidocs/futures/en/#exchange-information
    https://binance-docs.github.io/apidocs/delivery/en/#exchange-information
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.NONE,
        }
        url_path = base_endpoint + "exchangeInfo"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_resp_decoder = msgspec.json.Decoder(BinanceFuturesExchangeInfo)
    async def get(self) -> BinanceFuturesExchangeInfo:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, None)
        return self._get_resp_decoder.decode(raw)
class BinanceFuturesMarketHttpAPI(BinanceMarketHttpAPI):
    """
    Provides access to the Binance Futures HTTP REST API.
    Parameters
    ----------
    client : BinanceHttpClient
        The Binance REST API client.
    account_type : BinanceAccountType
        The Binance account type, used to select the endpoint.
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURES,
    ):
        super().__init__(
            client=client,
            account_type=account_type,
        )
        if not account_type.is_futures:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"`BinanceAccountType` not USDT_FUTURES or COIN_FUTURES, was {account_type}",  # pragma: no cover
            )
        self._endpoint_futures_exchange_info = BinanceFuturesExchangeInfoHttp(
            client,
            self.base_endpoint,
        )
    async def query_futures_exchange_info(self) -> BinanceFuturesExchangeInfo:
        """
        Retrieve Binance Futures exchange information.
        """
        return await self._endpoint_futures_exchange_info.get()
</document_content>
</document>
<document index="1754">
<source>nautilus_trader/adapters/binance/futures/http/user.py</source>
<document_content>

class BinanceFuturesUserDataHttpAPI(BinanceUserDataHttpAPI):
    """
    Provides access to the Binance Futures User Data HTTP REST API.
    Parameters
    ----------
    client : BinanceHttpClient
        The Binance REST API client.
    account_type : BinanceAccountType
        The Binance account type, used to select the endpoint.
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURES,
    ):
        super().__init__(
            client=client,
            account_type=account_type,
        )
        if not account_type.is_futures:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"`BinanceAccountType` not USDT_FUTURES or COIN_FUTURES, was {account_type}",  # pragma: no cover (design-time error)
            )
</document_content>
</document>
<document index="1755">
<source>nautilus_trader/adapters/binance/futures/http/wallet.py</source>
<document_content>

import msgspec
class BinanceFuturesCommissionRateHttp(BinanceHttpEndpoint):
    """
    Endpoint of maker/taker commission rate information.
    `GET /fapi/v1/commissionRate`
    `GET /dapi/v1/commissionRate`
    References
    ----------
    https://binance-docs.github.io/apidocs/futures/en/#user-commission-rate-user_data
    https://binance-docs.github.io/apidocs/delivery/en/#user-commission-rate-user_data
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.USER_DATA,
        }
        super().__init__(
            client,
            methods,
            base_endpoint + "commissionRate",
        )
        self._get_resp_decoder = msgspec.json.Decoder(BinanceFuturesCommissionRate)
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        GET parameters for fetching commission rate.
        Parameters
        ----------
        symbol : BinanceSymbol
            Receive commission rate of the provided symbol.
        timestamp : str
            Millisecond timestamp of the request.
        recvWindow : str, optional
            The number of milliseconds after timestamp the request is valid.
        """
        timestamp: str
        symbol: BinanceSymbol
        recvWindow: str | None = None
    async def get(self, params: GetParameters) -> BinanceFuturesCommissionRate:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._get_resp_decoder.decode(raw)
class BinanceFuturesWalletHttpAPI:
    """
    Provides access to the Binance Futures Wallet HTTP REST API.
    Parameters
    ----------
    client : BinanceHttpClient
        The Binance REST API client.
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        clock: LiveClock,
        account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURES,
    ):
        self.client = client
        self._clock = clock
        if account_type == BinanceAccountType.USDT_FUTURES:
            self.base_endpoint = "/fapi/v1/"
        elif account_type == BinanceAccountType.COIN_FUTURES:
            self.base_endpoint = "/dapi/v1/"
        if not account_type.is_futures:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"`BinanceAccountType` not USDT_FUTURES or COIN_FUTURES, was {account_type}",  # pragma: no cover
            )
        self._endpoint_futures_commission_rate = BinanceFuturesCommissionRateHttp(
            client,
            self.base_endpoint,
        )
    def _timestamp(self) -> str:
        """
        Create Binance timestamp from internal clock.
        """
        return str(self._clock.timestamp_ms())
    async def query_futures_commission_rate(
        self,
        symbol: str,
        recv_window: str | None = None,
    ) -> BinanceFuturesCommissionRate:
        """
        Get Futures commission rates for a given symbol.
        """
        rate = await self._endpoint_futures_commission_rate.get(
            params=self._endpoint_futures_commission_rate.GetParameters(
                timestamp=self._timestamp(),
                symbol=BinanceSymbol(symbol),
                recvWindow=recv_window,
            ),
        )
        return rate
</document_content>
</document>
<document index="1756">
<source>nautilus_trader/adapters/binance/futures/providers.py</source>
<document_content>

from decimal import Decimal
from enum import Enum
from typing import Any
import msgspec
def _symbol_info_to_dict(symbol_info: BinanceFuturesSymbolInfo) -> dict:
    """
    Convert symbol info to dict with all enums and nested structs converted to
    primitives.
    This ensures the info dict contains only JSON-serializable primitives.
    """
    def _convert_value(value: Any) -> Any:
        # Recursively convert enums and structs to primitives
        if isinstance(value, Enum):
            return value.value
        elif hasattr(value, "__struct_fields__"):
            return _convert_dict(msgspec.structs.asdict(value))
        elif isinstance(value, list):
            return [_convert_value(item) for item in value]
        elif isinstance(value, dict):
            return _convert_dict(value)
        return value
    def _convert_dict(d: dict) -> dict:
        return {key: _convert_value(val) for key, val in d.items()}
    return _convert_dict(msgspec.structs.asdict(symbol_info))
class BinanceFuturesInstrumentProvider(InstrumentProvider):
    """
    Provides a means of loading instruments from the Binance Futures exchange.
    Parameters
    ----------
    client : APIClient
        The client for the provider.
    config : InstrumentProviderConfig, optional
        The configuration for the provider.
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        clock: LiveClock,
        account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURES,
        config: InstrumentProviderConfig | None = None,
        venue: Venue = BINANCE_VENUE,
    ) -> None:
        super().__init__(config=config)
        self._clock = clock
        self._client = client
        self._account_type = account_type
        self._venue = venue
        self._http_account = BinanceFuturesAccountHttpAPI(
            self._client,
            clock=self._clock,
            account_type=account_type,
        )
        self._http_wallet = BinanceFuturesWalletHttpAPI(
            self._client,
            clock=self._clock,
            account_type=account_type,
        )
        self._http_market = BinanceFuturesMarketHttpAPI(self._client, account_type=account_type)
        self._log_warnings = config.log_warnings if config else True
        self._decoder = msgspec.json.Decoder()
        self._encoder = msgspec.json.Encoder()
        # This fee rates map is only applicable for backtesting, as live trading will utilise
        # real-time account update messages provided by Binance.
        # These fee rates assume USD-M Futures Trading without the 10% off for using BNB or BUSD.
        # The next step is to enable users to pass their own fee rates map via the config.
        # In the future, we aim to represent this fee model with greater accuracy for backtesting.
        # https://www.binance.com/en/fee/futureFee
        self._fee_rates = {
            0: BinanceFuturesFeeRates(feeTier=0, maker="0.000200", taker="0.000500"),
            1: BinanceFuturesFeeRates(feeTier=1, maker="0.000160", taker="0.000400"),
            2: BinanceFuturesFeeRates(feeTier=2, maker="0.000140", taker="0.000350"),
            3: BinanceFuturesFeeRates(feeTier=3, maker="0.000120", taker="0.000320"),
            4: BinanceFuturesFeeRates(feeTier=4, maker="0.000100", taker="0.000300"),
            5: BinanceFuturesFeeRates(feeTier=5, maker="0.000080", taker="0.000270"),
            6: BinanceFuturesFeeRates(feeTier=6, maker="0.000060", taker="0.000250"),
            7: BinanceFuturesFeeRates(feeTier=7, maker="0.000040", taker="0.000220"),
            8: BinanceFuturesFeeRates(feeTier=8, maker="0.000020", taker="0.000200"),
            9: BinanceFuturesFeeRates(feeTier=9, maker="0.000000", taker="0.000170"),
        }
    async def load_all_async(self, filters: dict | None = None) -> None:
        filters_str = "..." if not filters else f" with filters {filters}..."
        self._log.info(f"Loading all instruments{filters_str}")
        # Get exchange info for all assets
        exchange_info = await self._http_market.query_futures_exchange_info()
        account_info = await self._http_account.query_futures_account_info(recv_window=str(5000))
        fee_rates = self._fee_rates[account_info.feeTier]
        for symbol_info in exchange_info.symbols:
            fee = BinanceFuturesCommissionRate(
                symbol=symbol_info.symbol,
                makerCommissionRate=fee_rates.maker,
                takerCommissionRate=fee_rates.taker,
            )
            self._parse_instrument(
                symbol_info=symbol_info,
                fee=fee,
                ts_event=millis_to_nanos(exchange_info.serverTime),
            )
    async def load_ids_async(
        self,
        instrument_ids: list[InstrumentId],
        filters: dict | None = None,
    ) -> None:
        if not instrument_ids:
            self._log.warning("No instrument IDs given for loading.")
            return
        # Check all instrument IDs
        for instrument_id in instrument_ids:
            PyCondition.equal(instrument_id.venue, self._venue, "instrument_id.venue", "BINANCE")
        # Extract all symbol strings
        symbols = [
            str(BinanceSymbol(instrument_id.symbol.value)) for instrument_id in instrument_ids
        ]
        # Get exchange info for all assets
        exchange_info = await self._http_market.query_futures_exchange_info()
        symbol_info_dict: dict[str, BinanceFuturesSymbolInfo] = {
            info.symbol: info for info in exchange_info.symbols
        }
        account_info = await self._http_account.query_futures_account_info(recv_window=str(5000))
        fee_rates = self._fee_rates[account_info.feeTier]
        position_risk_resp = await self._http_account.query_futures_position_risk()
        position_risk = {risk.symbol: risk for risk in position_risk_resp}
        for symbol in symbols:
            fee = BinanceFuturesCommissionRate(
                symbol=symbol,
                makerCommissionRate=fee_rates.maker,
                takerCommissionRate=fee_rates.taker,
            )
            self._parse_instrument(
                symbol_info=symbol_info_dict[symbol],
                fee=fee,
                ts_event=millis_to_nanos(exchange_info.serverTime),
                position_risk=position_risk.get(symbol),
            )
    async def load_async(self, instrument_id: InstrumentId, filters: dict | None = None) -> None:
        PyCondition.not_none(instrument_id, "instrument_id")
        PyCondition.equal(instrument_id.venue, self._venue, "instrument_id.venue", "BINANCE")
        filters_str = "..." if not filters else f" with filters {filters}..."
        self._log.debug(f"Loading instrument {instrument_id}{filters_str}.")
        symbol = str(BinanceSymbol(instrument_id.symbol.value))
        # Get exchange info for all assets
        exchange_info = await self._http_market.query_futures_exchange_info()
        symbol_info_dict: dict[str, BinanceFuturesSymbolInfo] = {
            info.symbol: info for info in exchange_info.symbols
        }
        account_info = await self._http_account.query_futures_account_info(recv_window=str(5000))
        fee_rates = self._fee_rates[account_info.feeTier]
        fee = BinanceFuturesCommissionRate(
            symbol=symbol,
            makerCommissionRate=fee_rates.maker,
            takerCommissionRate=fee_rates.taker,
        )
        self._parse_instrument(
            symbol_info=symbol_info_dict[symbol],
            ts_event=millis_to_nanos(exchange_info.serverTime),
            fee=fee,
        )
    def _parse_instrument(
        self,
        symbol_info: BinanceFuturesSymbolInfo,
        ts_event: int,
        position_risk: BinanceFuturesPositionRisk | None = None,
        fee: BinanceFuturesCommissionRate | None = None,
    ) -> None:
        contract_type_str = symbol_info.contractType
        if (
            contract_type_str == ""
            or symbol_info.status == BinanceFuturesContractStatus.PENDING_TRADING
        ):
            self._log.debug(f"Instrument not yet defined: {symbol_info.symbol}")
            return  # Not yet defined
        ts_init = self._clock.timestamp_ns()
        try:
            # Create quote and base assets
            base_currency = symbol_info.parse_to_base_currency()
            quote_currency = symbol_info.parse_to_quote_currency()
            raw_symbol = Symbol(symbol_info.symbol)
            parsed_symbol = BinanceSymbol(raw_symbol.value).parse_as_nautilus(
                self._account_type,
            )
            nautilus_symbol = Symbol(parsed_symbol)
            instrument_id = InstrumentId(symbol=nautilus_symbol, venue=self._venue)
            # Parse instrument filters
            filters: dict[BinanceSymbolFilterType, BinanceSymbolFilter] = {
                f.filterType: f for f in symbol_info.filters
            }
            price_filter: BinanceSymbolFilter = filters.get(BinanceSymbolFilterType.PRICE_FILTER)
            lot_size_filter: BinanceSymbolFilter = filters.get(BinanceSymbolFilterType.LOT_SIZE)
            min_notional_filter: BinanceSymbolFilter = filters.get(
                BinanceSymbolFilterType.MIN_NOTIONAL,
            )
            tick_size = price_filter.tickSize
            step_size = lot_size_filter.stepSize
            PyCondition.in_range(float(tick_size), PRICE_MIN, PRICE_MAX, "tick_size")
            PyCondition.in_range(float(step_size), QUANTITY_MIN, QUANTITY_MAX, "step_size")
            price_precision = abs(int(Decimal(tick_size).as_tuple().exponent))
            size_precision = abs(int(Decimal(step_size).as_tuple().exponent))
            price_increment = Price.from_str(tick_size)
            size_increment = Quantity.from_str(step_size)
            max_quantity = Quantity(float(lot_size_filter.maxQty), precision=size_precision)
            min_quantity = Quantity(float(lot_size_filter.minQty), precision=size_precision)
            min_notional = None
            if filters.get(BinanceSymbolFilterType.MIN_NOTIONAL):
                min_notional = Money(min_notional_filter.notional, currency=quote_currency)
            max_notional = (
                Money(position_risk.maxNotionalValue, currency=quote_currency)
                if position_risk and position_risk.maxNotionalValue is not None
                else None
            )
            max_price = Price(float(price_filter.maxPrice), precision=price_precision)
            min_price = Price(float(price_filter.minPrice), precision=price_precision)
            # Futures commissions
            maker_fee = Decimal(0)
            taker_fee = Decimal(0)
            if fee:
                maker_fee = Decimal(fee.makerCommissionRate)
                taker_fee = Decimal(fee.takerCommissionRate)
            if symbol_info.marginAsset == symbol_info.baseAsset:
                settlement_currency = base_currency
            elif symbol_info.marginAsset == symbol_info.quoteAsset:
                settlement_currency = quote_currency
            else:
                raise ValueError(f"Unrecognized margin asset {symbol_info.marginAsset}")
            contract_type = BinanceFuturesContractType(contract_type_str)
            if contract_type == BinanceFuturesContractType.PERPETUAL:
                instrument = CryptoPerpetual(
                    instrument_id=instrument_id,
                    raw_symbol=raw_symbol,
                    base_currency=base_currency,
                    quote_currency=quote_currency,
                    settlement_currency=settlement_currency,
                    is_inverse=False,  # No inverse instruments trade on Binance
                    price_precision=price_precision,
                    size_precision=size_precision,
                    price_increment=price_increment,
                    size_increment=size_increment,
                    max_quantity=max_quantity,
                    min_quantity=min_quantity,
                    max_notional=max_notional,
                    min_notional=min_notional,
                    max_price=max_price,
                    min_price=min_price,
                    margin_init=Decimal(symbol_info.requiredMarginPercent) / 100,
                    margin_maint=Decimal(symbol_info.maintMarginPercent) / 100,
                    maker_fee=maker_fee,
                    taker_fee=taker_fee,
                    ts_event=ts_event,
                    ts_init=ts_init,
                    info=_symbol_info_to_dict(symbol_info),
                )
                self.add_currency(currency=instrument.base_currency)
            elif contract_type in (
                BinanceFuturesContractType.CURRENT_MONTH,
                BinanceFuturesContractType.CURRENT_QUARTER,
                BinanceFuturesContractType.CURRENT_QUARTER_DELIVERING,
                BinanceFuturesContractType.NEXT_MONTH,
                BinanceFuturesContractType.NEXT_QUARTER,
            ):
                instrument = CryptoFuture(
                    instrument_id=instrument_id,
                    raw_symbol=raw_symbol,
                    underlying=base_currency,
                    quote_currency=quote_currency,
                    settlement_currency=settlement_currency,
                    is_inverse=False,  # No inverse instruments trade on Binance
                    activation_ns=millis_to_nanos(symbol_info.onboardDate),
                    expiration_ns=millis_to_nanos(symbol_info.deliveryDate),
                    price_precision=price_precision,
                    size_precision=size_precision,
                    price_increment=price_increment,
                    size_increment=size_increment,
                    max_quantity=max_quantity,
                    min_quantity=min_quantity,
                    max_notional=None,
                    min_notional=min_notional,
                    max_price=max_price,
                    min_price=min_price,
                    margin_init=Decimal(symbol_info.requiredMarginPercent) / 100,
                    margin_maint=Decimal(symbol_info.maintMarginPercent) / 100,
                    maker_fee=maker_fee,
                    taker_fee=taker_fee,
                    ts_event=ts_event,
                    ts_init=ts_init,
                    info=_symbol_info_to_dict(symbol_info),
                )
                self.add_currency(currency=instrument.underlying)
            else:
                raise RuntimeError(  # pragma: no cover (design-time error)
                    f"invalid `BinanceFuturesContractType`, was {contract_type}",  # pragma: no cover
                )
            self.add_currency(currency=instrument.quote_currency)
            self.add(instrument=instrument)
            self._log.debug(f"Added instrument {instrument.id}.")
        except ValueError as e:
            if self._log_warnings:
                self._log.warning(f"Unable to parse instrument {symbol_info.symbol}: {e}.")
</document_content>
</document>
<document index="1757">
<source>nautilus_trader/adapters/binance/futures/schemas/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="1758">
<source>nautilus_trader/adapters/binance/futures/schemas/account.py</source>
<document_content>

from decimal import Decimal
import msgspec
################################################################################
# HTTP responses
################################################################################
class BinanceFuturesBalanceInfo(msgspec.Struct, frozen=True):
    """
    HTTP response 'inner struct' from Binance Futures GET /fapi/v2/account (HMAC
    SHA256).
    """
    asset: str  # asset name
    walletBalance: str  # wallet balance
    unrealizedProfit: str  # unrealized profit
    marginBalance: str  # margin balance
    maintMargin: str  # maintenance margin required
    initialMargin: str  # total initial margin required with current mark price
    positionInitialMargin: str  # initial margin required for positions with current mark price
    openOrderInitialMargin: str  # initial margin required for open orders with current mark price
    crossWalletBalance: str  # crossed wallet balance
    crossUnPnl: str  # unrealized profit of crossed positions
    availableBalance: str  # available balance
    maxWithdrawAmount: str  # maximum amount for transfer out
    # whether the asset can be used as margin in Multi - Assets mode
    marginAvailable: bool | None = None
    updateTime: int | None = None  # last update time
    def parse_to_account_balance(self) -> AccountBalance:
        currency = Currency.from_str(self.asset)
        # This calculation is currently mixing wallet cash balance and the available balance after
        # considering margin collateral. As a temporary measure we're taking the `min` to
        # disregard free amounts above the cash balance, but still considering where not all
        # balance is available (so locked in some way, i.e. allocated as collateral).
        total = Decimal(self.walletBalance)
        free = min(Decimal(self.availableBalance), total)
        locked = total - free
        return AccountBalance(
            total=Money(total, currency),
            locked=Money(locked, currency),
            free=Money(free, currency),
        )
    def parse_to_margin_balance(self) -> MarginBalance:
        currency: Currency = Currency.from_str(self.asset)
        return MarginBalance(
            initial=Money(Decimal(self.initialMargin), currency),
            maintenance=Money(Decimal(self.maintMargin), currency),
        )
class BinanceFuturesAccountInfo(msgspec.Struct, kw_only=True, frozen=True):
    """
    HTTP response from Binance Futures GET /fapi/v2/account (HMAC SHA256).
    """
    feeTier: int  # account commission tier
    canTrade: bool  # if can trade
    canDeposit: bool  # if can transfer in asset
    canWithdraw: bool  # if can transfer out asset
    updateTime: int
    totalInitialMargin: str | None = (
        None  # total initial margin required with current mark price (useless with isolated positions), only for USDT
    )
    totalMaintMargin: str | None = None  # total maintenance margin required, only for USDT asset
    totalWalletBalance: str | None = None  # total wallet balance, only for USDT asset
    totalUnrealizedProfit: str | None = None  # total unrealized profit, only for USDT asset
    totalMarginBalance: str | None = None  # total margin balance, only for USDT asset
    # initial margin required for positions with current mark price, only for USDT asset
    totalPositionInitialMargin: str | None = None
    # initial margin required for open orders with current mark price, only for USDT asset
    totalOpenOrderInitialMargin: str | None = None
    totalCrossWalletBalance: str | None = None  # crossed wallet balance, only for USDT asset
    # unrealized profit of crossed positions, only for USDT asset
    totalCrossUnPnl: str | None = None
    availableBalance: str | None = None  # available balance, only for USDT asset
    maxWithdrawAmount: str | None = None  # maximum amount for transfer out, only for USDT asset
    assets: list[BinanceFuturesBalanceInfo]
    def parse_to_account_balances(self) -> list[AccountBalance]:
        return [asset.parse_to_account_balance() for asset in self.assets]
    def parse_to_margin_balances(self) -> list[MarginBalance]:
        return [asset.parse_to_margin_balance() for asset in self.assets]
class BinanceFuturesPositionRisk(msgspec.Struct, kw_only=True, frozen=True):
    """
    HTTP response from Binance Futures GET /fapi/v3/positionRisk (HMAC SHA256).
    Supports both v2 and v3 schemas. v2 fields (marginType, isAutoAddMargin,
    leverage, maxNotionalValue) are optional for backward compatibility.
    v3 adds: breakEvenPrice, notional, marginAsset, isolatedWallet, initialMargin,
    maintMargin, positionInitialMargin, openOrderInitialMargin, adl, bidNotional,
    askNotional.
    """
    # Core fields (present in both v2 and v3)
    symbol: str
    positionSide: BinanceFuturesPositionSide
    positionAmt: str
    entryPrice: str
    markPrice: str
    unRealizedProfit: str
    liquidationPrice: str
    isolatedMargin: str
    updateTime: int
    # v2 fields (may not be present in v3)
    marginType: str | None = None
    isAutoAddMargin: str | None = None
    leverage: str | None = None
    maxNotionalValue: str | None = None
    # v3-specific fields
    breakEvenPrice: str | None = None
    notional: str | None = None
    marginAsset: str | None = None
    isolatedWallet: str | None = None
    initialMargin: str | None = None
    maintMargin: str | None = None
    positionInitialMargin: str | None = None
    openOrderInitialMargin: str | None = None
    adl: int | None = None
    bidNotional: str | None = None
    askNotional: str | None = None
    def parse_to_position_status_report(
        self,
        account_id: AccountId,
        instrument_id: InstrumentId,
        enum_parser: BinanceFuturesEnumParser,
        report_id: UUID4,
        ts_init: int,
    ) -> PositionStatusReport:
        net_size = Decimal(self.positionAmt)
        venue_position_id: PositionId | None = None
        if self.positionSide in (
            BinanceFuturesPositionSide.LONG,
            BinanceFuturesPositionSide.SHORT,
        ):
            position_side = (
                PositionSide.LONG
                if self.positionSide == BinanceFuturesPositionSide.LONG
                else PositionSide.SHORT
            )
            venue_position_id = PositionId(f"{instrument_id}-{self.positionSide.value}")
        else:
            position_side = enum_parser.parse_futures_position_side(net_size)
        avg_px_open = Decimal(self.entryPrice) if self.entryPrice else None
        return PositionStatusReport(
            account_id=account_id,
            instrument_id=instrument_id,
            position_side=position_side,
            quantity=Quantity.from_str(str(abs(net_size))),
            report_id=report_id,
            ts_last=ts_init,
            ts_init=ts_init,
            venue_position_id=venue_position_id,
            avg_px_open=avg_px_open,
        )
class BinanceFuturesDualSidePosition(msgspec.Struct, frozen=True):
    """
    HTTP response from Binance Futures GET /fapi/v1/positionSide/dual (HMAC SHA256).
    """
    dualSidePosition: bool
class BinanceFuturesFeeRates(msgspec.Struct, frozen=True):
    """
    Represents a Binance Futures fee tier.
    https://www.binance.com/en/fee/futureFee
    """
    feeTier: int
    maker: str
    taker: str
class BinanceFuturesLeverage(msgspec.Struct, frozen=True):
    """
    HTTP response from Binance Futures POST /fapi/v1/leverage.
    """
    leverage: int
    maxNotionalValue: str
    symbol: str
class BinanceFuturesSymbolConfig(msgspec.Struct, frozen=True):
    """
    HTTP response from Binance Futures GET /fapi/v1/symbolConfig.
    References
    ----------
    https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Symbol-Config
    """
    symbol: str
    marginType: str
    isAutoAddMargin: bool
    leverage: int
    maxNotionalValue: str
class BinanceFuturesMarginTypeResponse(msgspec.Struct, frozen=True):
    """
    HTTP response from Binance Futures `POST /fapi/v1/marginType`.
    """
    code: int
    msg: str
</document_content>
</document>
<document index="1759">
<source>nautilus_trader/adapters/binance/futures/schemas/market.py</source>
<document_content>

from decimal import Decimal
import msgspec
################################################################################
# HTTP responses
################################################################################
class BinanceFuturesAsset(msgspec.Struct, frozen=True):
    """
    HTTP response 'inner struct' from Binance Futures GET /fapi/v1/exchangeInfo.
    """
    asset: str
    marginAvailable: bool
    autoAssetExchange: str
class BinanceFuturesSymbolInfo(msgspec.Struct, kw_only=True, frozen=True):
    """
    HTTP response 'inner struct' from Binance Futures GET /fapi/v1/exchangeInfo.
    """
    symbol: str
    pair: str
    contractType: str  # Can be '' empty string
    deliveryDate: int
    onboardDate: int
    status: BinanceFuturesContractStatus | None = None
    maintMarginPercent: str
    requiredMarginPercent: str
    baseAsset: str
    quoteAsset: str
    marginAsset: str
    pricePrecision: int
    quantityPrecision: int
    baseAssetPrecision: int
    quotePrecision: int
    underlyingType: str
    underlyingSubType: list[str]
    settlePlan: int | None = None
    triggerProtect: str
    liquidationFee: str
    marketTakeBound: str
    filters: list[BinanceSymbolFilter]
    orderTypes: list[BinanceOrderType]
    timeInForce: list[BinanceTimeInForce]
    def parse_to_base_currency(self):
        return Currency(
            code=self.baseAsset,
            precision=self.baseAssetPrecision,
            iso4217=0,  # Currently unspecified for crypto assets
            name=self.baseAsset,
            currency_type=CurrencyType.CRYPTO,
        )
    def parse_to_quote_currency(self):
        return Currency(
            code=self.quoteAsset,
            precision=self.quotePrecision,
            iso4217=0,  # Currently unspecified for crypto assets
            name=self.quoteAsset,
            currency_type=CurrencyType.CRYPTO,
        )
class BinanceFuturesExchangeInfo(msgspec.Struct, kw_only=True, frozen=True):
    """
    HTTP response from Binance Futures GET /fapi/v1/exchangeInfo.
    """
    timezone: str
    serverTime: int
    rateLimits: list[BinanceRateLimit]
    exchangeFilters: list[BinanceExchangeFilter]
    assets: list[BinanceFuturesAsset] | None = None
    symbols: list[BinanceFuturesSymbolInfo]
class BinanceFuturesMarkFunding(msgspec.Struct, frozen=True):
    """
    HTTP response from Binance Futures GET /fapi/v1/premiumIndex.
    """
    symbol: str
    markPrice: str  # Mark price
    indexPrice: str  # Index price
    estimatedSettlePrice: (
        str  # Estimated Settle Price (only useful in the last hour before the settlement starts)
    )
    lastFundingRate: str  # This is the lasted funding rate
    nextFundingTime: int
    interestRate: str
    time: int
class BinanceFuturesFundRate(msgspec.Struct, frozen=True):
    """
    HTTP response from Binance Futures GET /fapi/v1/fundingRate.
    """
    symbol: str
    fundingRate: str
    fundingTime: str
################################################################################
# WebSocket messages
################################################################################
class BinanceFuturesTradeData(msgspec.Struct, frozen=True):
    """
    WebSocket message 'inner struct' for Binance Futures Trade Streams.
    Fields
    ------
    - e: Event type
    - E: Event time
    - s: Symbol
    - t: Trade ID
    - p: Price
    - q: Quantity
    - b: Buyer order ID
    - a: Seller order ID
    - T: Trade time
    - m: Is the buyer the market maker?
    """
    e: str  # Event type
    E: int  # Event time
    s: str  # Symbol
    t: int  # Trade ID
    p: str  # Price
    q: str  # Quantity
    T: int  # Trade time
    m: bool  # Is the buyer the market maker?
    def parse_to_trade_tick(
        self,
        instrument_id: InstrumentId,
        ts_init: int,
    ) -> TradeTick:
        """
        Parameters
        ----------
        instrument_id : InstrumentId
            The trade instrument ID.
        ts_init : uint64_t
            UNIX timestamp (nanoseconds) when the data object was initialized.
        Raises
        ------
        ValueError
            If trade tick data are incorrect
        """
        return TradeTick(
            instrument_id=instrument_id,
            price=Price.from_str(self.p),
            size=Quantity.from_str(self.q),
            aggressor_side=AggressorSide.SELLER if self.m else AggressorSide.BUYER,
            trade_id=TradeId(str(self.t)),
            ts_event=millis_to_nanos(self.T),
            ts_init=ts_init,
        )
class BinanceFuturesTradeMsg(msgspec.Struct, frozen=True):
    """
    WebSocket message from Binance Futures Trade Streams.
    """
    stream: str
    data: BinanceFuturesTradeData
class BinanceFuturesMarkPriceData(msgspec.Struct, frozen=True):
    """
    WebSocket message 'inner struct' for Binance Futures Mark Price Update events.
    """
    e: str  # Event type
    E: int  # Event time
    s: str  # Symbol
    p: str  # Mark price
    i: str  # Index price
    P: str  # Estimated Settle Price, only useful in the last hour before the settlement starts
    r: str  # Funding rate
    T: int  # Next funding time
    def parse_to_binance_futures_mark_price_update(
        self,
        instrument_id: InstrumentId,
        ts_init: int,
    ) -> BinanceFuturesMarkPriceUpdate:
        return BinanceFuturesMarkPriceUpdate(
            instrument_id=instrument_id,
            mark=Price.from_str(self.p),
            index=Price.from_str(self.i),
            estimated_settle=Price.from_str(self.P),
            funding_rate=Decimal(self.r),
            next_funding_ns=millis_to_nanos(self.T),
            ts_event=millis_to_nanos(self.E),
            ts_init=ts_init,
        )
class BinanceFuturesMarkPriceMsg(msgspec.Struct, frozen=True):
    """
    WebSocket message from Binance Futures Mark Price Update events.
    """
    stream: str
    data: BinanceFuturesMarkPriceData
class BinanceFuturesMarkPriceAllMsg(msgspec.Struct, frozen=True):
    """
    WebSocket message from Binance Futures All Mark Price Update events.
    """
    stream: str
    data: list[BinanceFuturesMarkPriceData]
</document_content>
</document>
<document index="1760">
<source>nautilus_trader/adapters/binance/futures/schemas/user.py</source>
<document_content>

from decimal import Decimal
import msgspec
################################################################################
# WebSocket messages
################################################################################
class BinanceFuturesUserMsgData(msgspec.Struct, frozen=True):
    """
    Inner struct for execution WebSocket messages from Binance.
    """
    e: BinanceFuturesEventType
class BinanceFuturesUserMsgWrapper(msgspec.Struct, frozen=True):
    """
    Provides a wrapper for execution WebSocket messages from Binance.
    """
    data: BinanceFuturesUserMsgData | None = None
    stream: str | None = None
class MarginCallPosition(msgspec.Struct, frozen=True):
    """
    Inner struct position for Binance Futures Margin Call events.
    """
    s: str  # Symbol
    ps: BinanceFuturesPositionSide  # Position Side
    pa: str  # Position  Amount
    mt: str  # Margin Type
    iw: str  # Isolated Wallet(if isolated position)
    mp: str  # MarkPrice
    up: str  # Unrealized PnL
    mm: str  # Maintenance Margin Required
class BinanceFuturesMarginCallMsg(msgspec.Struct, frozen=True):
    """
    WebSocket message for Binance Futures Margin Call events.
    """
    e: str  # Event Type
    E: int  # Event Time
    cw: float  # Cross Wallet Balance. Only pushed with crossed position margin call
    p: list[MarginCallPosition]
class BinanceFuturesBalance(msgspec.Struct, frozen=True):
    """
    Inner struct balance for Binance Futures Balance and Position update event.
    """
    a: str  # Asset
    wb: str  # Wallet Balance
    cw: str  # Cross Wallet Balance
    bc: str  # Balance Change except PnL and Commission
    def parse_to_account_balance(self) -> AccountBalance:
        currency = Currency.from_str(self.a)
        free = Decimal(self.wb)
        locked = Decimal(0)  # TODO: Pending refactoring of accounting
        total: Decimal = free + locked
        return AccountBalance(
            total=Money(total, currency),
            locked=Money(locked, currency),
            free=Money(free, currency),
        )
class BinanceFuturesPosition(msgspec.Struct, frozen=True):
    """
    Inner struct position for Binance Futures Balance and Position update event.
    """
    s: str  # Symbol
    pa: str  # Position amount
    ep: str  # Entry price
    cr: str  # (Pre-free) Accumulated Realized
    up: str  # Unrealized PnL
    mt: str  # Margin type
    iw: str  # Isolated wallet
    ps: BinanceFuturesPositionSide
class BinanceFuturesAccountUpdateData(msgspec.Struct, frozen=True):
    """
    WebSocket message for Binance Futures Balance and Position Update events.
    """
    m: BinanceFuturesPositionUpdateReason
    B: list[BinanceFuturesBalance]
    P: list[BinanceFuturesPosition]
    def parse_to_account_balances(self) -> list[AccountBalance]:
        return [balance.parse_to_account_balance() for balance in self.B]
class BinanceFuturesAccountUpdateMsg(msgspec.Struct, frozen=True):
    """
    WebSocket message for Binance Futures Balance and Position Update events.
    """
    e: str  # Event Type
    E: int  # Event Time
    T: int  # Transaction Time
    a: BinanceFuturesAccountUpdateData
    def handle_account_update(self, exec_client: BinanceCommonExecutionClient):
        """
        Handle BinanceFuturesAccountUpdateMsg as payload of ACCOUNT_UPDATE.
        """
        exec_client.generate_account_state(
            balances=self.a.parse_to_account_balances(),
            margins=[],
            reported=True,
            ts_event=millis_to_nanos(self.T),
        )
class BinanceFuturesAccountUpdateWrapper(msgspec.Struct, frozen=True):
    """
    WebSocket message wrapper for Binance Futures Balance and Position Update events.
    """
    stream: str
    data: BinanceFuturesAccountUpdateMsg
class BinanceFuturesOrderData(msgspec.Struct, kw_only=True, frozen=True):
    """
    WebSocket message 'inner struct' for Binance Futures Order Update events.
    Client Order ID 'c':
     - starts with "autoclose-": liquidation order/
     - starts with "adl_autoclose": ADL auto close order/
    """
    s: str  # Symbol
    c: str  # Client Order ID
    S: BinanceOrderSide
    o: BinanceOrderType
    f: BinanceTimeInForce
    q: str  # Original Quantity
    p: str  # Original Price
    ap: str  # Average Price
    sp: str | None = None  # Stop Price. Ignore with TRAILING_STOP_MARKET order
    x: BinanceExecutionType
    X: BinanceOrderStatus
    i: int  # Order ID
    l: str  # Order Last Filled Quantity
    z: str  # Order Filled Accumulated Quantity
    L: str  # Last Filled Price
    N: str | None = None  # Commission Asset, will not push if no commission
    n: str | None = None  # Commission, will not push if no commission
    T: int  # Order Trade Time
    t: int  # Trade ID
    b: str  # Bids Notional
    a: str  # Ask Notional
    m: bool  # Is trade the maker side
    R: bool  # Is reduce only
    wt: BinanceFuturesWorkingType
    ot: BinanceOrderType
    ps: BinanceFuturesPositionSide
    cp: bool | None = None  # If Close-All, pushed with conditional order
    AP: str | None = None  # Activation Price, only pushed with TRAILING_STOP_MARKET order
    cr: str | None = None  # Callback Rate, only pushed with TRAILING_STOP_MARKET order
    pP: bool  # ignore
    si: int  # ignore
    ss: int  # ignore
    rp: str  # Realized Profit of the trade
    gtd: int  # TIF GTD order auto cancel time
    W: int | None = None  # Working Time (when order was added to the book)
    V: str | None = None  # Self-Trade Prevention Mode
    def parse_to_order_status_report(
        self,
        account_id: AccountId,
        instrument_id: InstrumentId,
        client_order_id: ClientOrderId,
        venue_order_id: VenueOrderId,
        ts_event: int,
        ts_init: int,
        enum_parser: BinanceEnumParser,
    ) -> OrderStatusReport:
        price = Price.from_str(self.p) if self.p is not None else None
        trigger_price = Price.from_str(self.sp) if self.sp is not None else None
        trailing_offset = Decimal(self.cr) * 100 if self.cr is not None else None
        order_side = OrderSide.BUY if self.S == BinanceOrderSide.BUY else OrderSide.SELL
        post_only = self.f == BinanceTimeInForce.GTX
        expire_time = unix_nanos_to_dt(millis_to_nanos(self.gtd)) if self.gtd else None
        return OrderStatusReport(
            account_id=account_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            order_side=order_side,
            order_type=enum_parser.parse_binance_order_type(self.o),
            time_in_force=enum_parser.parse_binance_time_in_force(self.f),
            order_status=enum_parser.parse_binance_order_status(self.X),
            expire_time=expire_time,
            price=price,
            trigger_price=trigger_price,
            trigger_type=enum_parser.parse_binance_trigger_type(self.wt.value),
            trailing_offset=trailing_offset,
            trailing_offset_type=TrailingOffsetType.BASIS_POINTS,
            quantity=Quantity.from_str(self.q),
            filled_qty=Quantity.from_str(self.z),
            avg_px=None,
            post_only=post_only,
            reduce_only=self.R,
            report_id=UUID4(),
            ts_accepted=ts_event,
            ts_last=ts_event,
            ts_init=ts_init,
        )
    def handle_order_trade_update(  # noqa: C901 (too complex)
        self,
        exec_client: BinanceCommonExecutionClient,
    ) -> None:
        """
        Handle BinanceFuturesOrderData as payload of ORDER_TRADE_UPDATE event.
        """
        client_order_id = ClientOrderId(self.c) if self.c != "" else None
        ts_event = millis_to_nanos(self.T)
        venue_order_id = VenueOrderId(str(self.i))
        instrument_id = exec_client._get_cached_instrument_id(self.s)
        strategy_id = None
        # Check for exchange-generated liquidation/ADL orders
        is_liquidation = self.c.startswith("autoclose-") if self.c else False
        is_adl = self.c.startswith("adl_autoclose") if self.c else False
        is_settlement = self.c.startswith("settlement_autoclose-") if self.c else False
        if client_order_id:
            strategy_id = exec_client._cache.strategy_id_for_order(client_order_id)
        # Log exchange-generated liquidation/ADL/settlement orders
        if is_liquidation:
            exec_client._log.warning(
                f"Received liquidation order: {self.c}, "
                f"symbol={self.s}, side={self.S.value}, "
                f"exec_type={self.x.value}, status={self.X.value}",
            )
        elif is_adl:
            exec_client._log.warning(
                f"Received ADL order: {self.c}, "
                f"symbol={self.s}, side={self.S.value}, "
                f"exec_type={self.x.value}, status={self.X.value}",
            )
        elif is_settlement:
            exec_client._log.warning(
                f"Received settlement order: {self.c}, "
                f"symbol={self.s}, side={self.S.value}, "
                f"exec_type={self.x.value}, status={self.X.value}",
            )
        # For exchange-generated orders without strategy, still need to process fills
        if strategy_id is None and not (is_liquidation or is_adl or is_settlement):
            report = self.parse_to_order_status_report(
                account_id=exec_client.account_id,
                instrument_id=instrument_id,
                client_order_id=client_order_id,
                venue_order_id=venue_order_id,
                ts_event=ts_event,
                ts_init=exec_client._clock.timestamp_ns(),
                enum_parser=exec_client._enum_parser,
            )
            exec_client._send_order_status_report(report)
            return
        instrument = exec_client._instrument_provider.find(instrument_id=instrument_id)
        if instrument is None:
            raise ValueError(
                f"Cannot process event for {instrument_id}: instrument not found in cache",
            )
        price_precision = instrument.price_precision
        size_precision = instrument.size_precision
        # Handle exchange-generated liquidation/ADL/settlement orders that may not be in cache
        # Check for CALCULATED execution type (liquidation fills) OR special client order IDs
        # Binance sends liquidation/ADL fills with x=CALCULATED and X=FILLED
        if (is_liquidation or is_adl or is_settlement) and (
            self.x == BinanceExecutionType.CALCULATED
            or self.X == BinanceOrderStatus.NEW_ADL
            or self.X == BinanceOrderStatus.NEW_INSURANCE
        ):
            # These are special exchange-generated fills without a pre-existing order
            if Decimal(self.l) == 0:
                exec_client._log.warning(
                    f"Received {self.X.value} status with l=0 for "
                    f"{'liquidation' if is_liquidation else 'ADL' if is_adl else 'settlement'} "
                    f"order {venue_order_id}, skipping",
                )
                return
            # Send OrderStatusReport first to seed the cache
            order_report = self.parse_to_order_status_report(
                account_id=exec_client.account_id,
                instrument_id=instrument_id,
                client_order_id=client_order_id,
                venue_order_id=venue_order_id,
                ts_event=ts_event,
                ts_init=exec_client._clock.timestamp_ns(),
                enum_parser=exec_client._enum_parser,
            )
            exec_client._send_order_status_report(order_report)
            # Generate fill report directly for exchange-generated liquidation/ADL
            liq_commission_asset: str | None = self.N
            liq_commission_amount: str | float | None = self.n
            liq_last_qty = Quantity(float(self.l), size_precision)
            liq_last_px = Price(float(self.L), price_precision)
            if liq_commission_asset is not None:
                liq_commission = Money.from_str(f"{liq_commission_amount} {liq_commission_asset}")
            else:
                # Liquidations and ADL are always taker
                liq_fee = instrument.taker_fee
                liq_commission_asset = instrument.quote_currency
                liq_commission_amount = float(liq_last_qty * liq_last_px * liq_fee)
                liq_commission = Money(liq_commission_amount, liq_commission_asset)
            liq_venue_position_id: PositionId | None = None
            if exec_client.use_position_ids:
                liq_venue_position_id = PositionId(f"{instrument_id}-{self.ps.value}")
            # Note: We cannot use generate_order_filled without strategy_id and cached order
            # Send FillReport directly for exchange-generated liquidation/ADL orders
            fill_report = FillReport(
                account_id=exec_client.account_id,
                instrument_id=instrument_id,
                venue_order_id=venue_order_id,
                trade_id=TradeId(str(self.t)),
                order_side=exec_client._enum_parser.parse_binance_order_side(self.S),
                last_qty=liq_last_qty,
                last_px=liq_last_px,
                commission=liq_commission,
                liquidity_side=LiquiditySide.TAKER,  # Liquidations/ADL are always taker
                report_id=UUID4(),
                ts_event=ts_event,
                ts_init=exec_client._clock.timestamp_ns(),
                venue_position_id=liq_venue_position_id,
                client_order_id=client_order_id,
            )
            exec_client._send_fill_report(fill_report)
            return
        order = exec_client._cache.order(client_order_id)
        if not order:
            # For non-special exchange orders, we need the order in cache
            if is_liquidation or is_adl or is_settlement:
                exec_client._log.warning(
                    f"Cannot find order for "
                    f"{'liquidation' if is_liquidation else 'ADL' if is_adl else 'settlement'} "
                    f"{client_order_id!r}, status={self.X.value}",
                )
            else:
                exec_client._log.error(f"Cannot find order {client_order_id!r}")
            return
        if self.x == BinanceExecutionType.NEW:
            if order.order_type == OrderType.TRAILING_STOP_MARKET and order.is_open:
                return  # Already accepted: this is an update
            exec_client.generate_order_accepted(
                strategy_id=strategy_id,
                instrument_id=instrument_id,
                client_order_id=client_order_id,
                venue_order_id=venue_order_id,
                ts_event=ts_event,
            )
            # Check if price changed (for price_match orders)
            if order.has_price:
                binance_price = Price(float(self.p), price_precision)
                if binance_price != order.price:
                    # Preserve trigger price for stop orders (priceMatch only affects limit price)
                    trigger_price = order.trigger_price if order.has_trigger_price else None
                    exec_client.generate_order_updated(
                        strategy_id=strategy_id,
                        instrument_id=instrument_id,
                        client_order_id=client_order_id,
                        venue_order_id=venue_order_id,
                        quantity=order.quantity,
                        price=binance_price,
                        trigger_price=trigger_price,
                        ts_event=ts_event,
                        venue_order_id_modified=True,  # Setting true to avoid spurious warning log
                    )
        elif self.x == BinanceExecutionType.TRADE or self.x == BinanceExecutionType.CALCULATED:
            if self.x == BinanceExecutionType.CALCULATED:
                exec_client._log.info(
                    f"Received CALCULATED (liquidation) execution for order {venue_order_id}, "
                    f"generating OrderFilled event",
                )
            if Decimal(self.L) == 0:
                exec_client._log.warning(
                    f"Received {self.x.value} execution with L=0 for order {venue_order_id}, "
                    f"order status={self.X.value}",
                )
                # Route based on order status to ensure terminal events are generated
                if self.X == BinanceOrderStatus.EXPIRED:
                    if order.order_type == OrderType.TRAILING_STOP_MARKET:
                        exec_client.generate_order_updated(
                            strategy_id=strategy_id,
                            instrument_id=instrument_id,
                            client_order_id=client_order_id,
                            venue_order_id=venue_order_id,
                            quantity=Quantity(float(self.q), size_precision),
                            price=Price(float(self.p), price_precision),
                            trigger_price=(
                                Price(float(self.sp), price_precision) if self.sp else None
                            ),
                            ts_event=ts_event,
                        )
                    else:
                        exec_client.generate_order_expired(
                            strategy_id=strategy_id,
                            instrument_id=instrument_id,
                            client_order_id=client_order_id,
                            venue_order_id=venue_order_id,
                            ts_event=ts_event,
                        )
                    return
                elif self.X == BinanceOrderStatus.CANCELED or (
                    exec_client.treat_expired_as_canceled and self.x == BinanceExecutionType.EXPIRED
                ):
                    exec_client.generate_order_canceled(
                        strategy_id=strategy_id,
                        instrument_id=instrument_id,
                        client_order_id=client_order_id,
                        venue_order_id=venue_order_id,
                        ts_event=ts_event,
                    )
                    return
                elif self.X in (BinanceOrderStatus.FILLED, BinanceOrderStatus.PARTIALLY_FILLED):
                    # Continue to generate fill with L=0 to close order
                    # Better to have bad price data than stuck order
                    exec_client._log.warning(
                        f"Generating OrderFilled with L=0 for terminal state {self.X.value} "
                        f"to prevent order from being stuck",
                    )
                else:
                    # Non-terminal status with L=0, skip fill generation
                    return
            # Determine commission
            commission_asset: str | None = self.N
            commission_amount: str | float | None = self.n
            last_qty = Quantity(float(self.l), size_precision)
            last_px = Price(float(self.L), price_precision)
            if commission_asset is not None:
                commission = Money.from_str(f"{commission_amount} {commission_asset}")
            else:
                fee = instrument.maker_fee if self.m else instrument.taker_fee
                commission_asset = instrument.quote_currency
                commission_amount = float(last_qty * last_px * fee)
                commission = Money(commission_amount, commission_asset)
            venue_position_id: PositionId | None = None
            if exec_client.use_position_ids:
                venue_position_id = PositionId(f"{instrument_id}-{self.ps.value}")
            # Liquidations are always taker, regular trades use the 'm' field
            liquidity_side = (
                LiquiditySide.TAKER
                if self.x == BinanceExecutionType.CALCULATED
                else (LiquiditySide.MAKER if self.m else LiquiditySide.TAKER)
            )
            exec_client.generate_order_filled(
                strategy_id=strategy_id,
                instrument_id=instrument_id,
                client_order_id=client_order_id,
                venue_order_id=venue_order_id,
                venue_position_id=venue_position_id,
                trade_id=TradeId(str(self.t)),  # Trade ID
                order_side=exec_client._enum_parser.parse_binance_order_side(self.S),
                order_type=exec_client._enum_parser.parse_binance_order_type(self.o),
                last_qty=last_qty,
                last_px=last_px,
                quote_currency=instrument.quote_currency,
                commission=commission,
                liquidity_side=liquidity_side,
                ts_event=ts_event,
            )
        elif self.x == BinanceExecutionType.CANCELED or (
            exec_client.treat_expired_as_canceled and self.x == BinanceExecutionType.EXPIRED
        ):
            exec_client.generate_order_canceled(
                strategy_id=strategy_id,
                instrument_id=instrument_id,
                client_order_id=client_order_id,
                venue_order_id=venue_order_id,
                ts_event=ts_event,
            )
        elif self.x == BinanceExecutionType.AMENDMENT:
            exec_client.generate_order_updated(
                strategy_id=strategy_id,
                instrument_id=instrument_id,
                client_order_id=client_order_id,
                venue_order_id=venue_order_id,
                quantity=Quantity(float(self.q), size_precision),
                price=Price(float(self.p), price_precision),
                trigger_price=None,
                ts_event=ts_event,
            )
        elif self.x == BinanceExecutionType.EXPIRED:
            if order.order_type == OrderType.TRAILING_STOP_MARKET:
                exec_client.generate_order_updated(
                    strategy_id=strategy_id,
                    instrument_id=instrument_id,
                    client_order_id=client_order_id,
                    venue_order_id=venue_order_id,
                    quantity=Quantity(float(self.q), size_precision),
                    price=Price(float(self.p), price_precision),
                    trigger_price=(Price(float(self.sp), price_precision) if self.sp else None),
                    ts_event=ts_event,
                )
            else:
                exec_client.generate_order_expired(
                    strategy_id=strategy_id,
                    instrument_id=instrument_id,
                    client_order_id=client_order_id,
                    venue_order_id=venue_order_id,
                    ts_event=ts_event,
                )
        elif self.x == BinanceExecutionType.REJECTED:
            due_post_only = self.f == BinanceTimeInForce.GTX
            exec_client.generate_order_rejected(
                strategy_id=strategy_id,
                instrument_id=instrument_id,
                client_order_id=client_order_id,
                reason="REJECTED",  # Reason string not provided by futures WS
                ts_event=ts_event,
                due_post_only=due_post_only,
            )
        elif self.x == BinanceExecutionType.TRADE_PREVENTION:
            exec_client._log.info(
                f"Self-trade prevention triggered for order {venue_order_id}, "
                f"prevented qty={self.l} at price={self.L}",
            )
        else:
            # Event not handled
            exec_client._log.warning(f"Received unhandled {self}")
class BinanceFuturesOrderUpdateMsg(msgspec.Struct, frozen=True):
    """
    WebSocket message for Binance Futures Order Update events.
    """
    e: str  # Event Type
    E: int  # Event Time
    T: int  # Transaction Time
    o: BinanceFuturesOrderData
class BinanceFuturesOrderUpdateWrapper(msgspec.Struct, frozen=True):
    """
    WebSocket message wrapper for Binance Futures Order Update events.
    """
    stream: str
    data: BinanceFuturesOrderUpdateMsg
class BinanceFuturesTradeLiteMsg(msgspec.Struct, frozen=True):
    """
    WebSocket message for Binance Futures Trade Lite events.
    """
    e: str  # Event Type
    E: int  # Event Time
    T: int  # Transaction Time
    s: str  # Symbol
    c: str  # Client Order ID
    S: BinanceOrderSide
    q: str  # Original Quantity
    p: str  # Original Price
    i: int  # Order ID
    l: str  # Order Last Filled Quantity
    L: str  # Last Filled Price
    t: int  # Trade ID
    m: bool  # Is trade the maker side
    def to_order_data(self) -> BinanceFuturesOrderData:
        """
        Convert TradeLite message to OrderData format.
        """
        return BinanceFuturesOrderData(
            s=self.s,
            c=self.c,
            S=self.S,
            o=BinanceOrderType.LIMIT,
            f=BinanceTimeInForce.GTC,
            q=self.q,
            p=self.p,
            ap="0",
            x=BinanceExecutionType.TRADE,
            X=BinanceOrderStatus.FILLED,
            i=self.i,
            l=self.l,
            z=self.l,
            L=self.L,
            N=None,
            n=None,
            T=self.T,
            t=self.t,
            b="0",
            a="0",
            m=self.m,
            R=False,
            wt=BinanceFuturesWorkingType.CONTRACT_PRICE,
            ot=BinanceOrderType.LIMIT,
            ps=BinanceFuturesPositionSide.BOTH,
            rp="0",
            gtd=0,
            pP=False,
            si=0,
            ss=0,
        )
class BinanceFuturesTradeLiteWrapper(msgspec.Struct, frozen=True):
    """
    WebSocket message wrapper for Binance Futures Trade Lite events.
    """
    stream: str
    data: BinanceFuturesTradeLiteMsg
</document_content>
</document>
<document index="1761">
<source>nautilus_trader/adapters/binance/futures/schemas/wallet.py</source>
<document_content>

import msgspec
################################################################################
# HTTP responses
################################################################################
class BinanceFuturesCommissionRate(msgspec.Struct, frozen=True):
    """
    Schema of a single Binance Futures commissionRate.
    """
    symbol: str
    makerCommissionRate: str
    takerCommissionRate: str
</document_content>
</document>
<document index="1762">
<source>nautilus_trader/adapters/binance/futures/types.py</source>
<document_content>

from __future__ import annotations
from decimal import Decimal
from typing import Any
class BinanceFuturesMarkPriceUpdate(Data):
    """
    Represents a Binance Futures mark price and funding rate update.
    Parameters
    ----------
    instrument_id : InstrumentId
        The instrument ID for the update.
    mark : Price
        The mark price for the instrument.
    index : Price
        The index price for the instrument.
    estimated_settle : Price
        The estimated settle price for the instrument
        (only useful in the last hour before the settlement starts).
    funding_rate : Decimal
        The current funding rate for the instrument.
    next_funding_ns : uint64_t
        UNIX timestamp (nanoseconds) when next funding will occur.
    ts_event : uint64_t
        UNIX timestamp (nanoseconds) when the data event occurred.
    ts_init : uint64_t
        UNIX timestamp (nanoseconds) when the data object was initialized.
    References
    ----------
    https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Mark-Price-Stream
    """
    def __init__(
        self,
        instrument_id: InstrumentId,
        mark: Price,
        index: Price,
        estimated_settle: Price,
        funding_rate: Decimal,
        next_funding_ns: int,
        ts_event: int,
        ts_init: int,
    ):
        self.instrument_id = instrument_id
        self.mark = mark
        self.index = index
        self.estimated_settle = estimated_settle
        self.funding_rate = funding_rate
        self.next_funding_ns = next_funding_ns
        self._ts_event = ts_event
        self._ts_init = ts_init
    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}("
            f"instrument_id={self.instrument_id}, "
            f"mark={self.mark}, "
            f"index={self.index}, "
            f"estimated_settle={self.estimated_settle}, "
            f"funding_rate={self.funding_rate}, "
            f"next_funding_ns={self.next_funding_ns}, "
            f"ts_event={self.ts_event}, "
            f"ts_init={self.ts_init})"
        )
    @property
    def ts_event(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the data event occurred.
        Returns
        -------
        int
        """
        return self._ts_event
    @property
    def ts_init(self) -> int:
        """
        UNIX timestamp (nanoseconds) when the object was initialized.
        Returns
        -------
        int
        """
        return self._ts_init
    @staticmethod
    def from_dict(values: dict[str, Any]) -> BinanceFuturesMarkPriceUpdate:
        """
        Return a Binance Futures mark price update parsed from the given values.
        Parameters
        ----------
        values : dict[str, Any]
            The values for initialization.
        Returns
        -------
        BinanceFuturesMarkPriceUpdate
        """
        return BinanceFuturesMarkPriceUpdate(
            instrument_id=InstrumentId.from_str(values["instrument_id"]),
            mark=Price.from_str(values["mark"]),
            index=Price.from_str(values["index"]),
            estimated_settle=Price.from_str(values["estimated_settle"]),
            funding_rate=Decimal(values["funding_rate"]),
            next_funding_ns=values["next_funding_ns"],
            ts_event=values["ts_event"],
            ts_init=values["ts_init"],
        )
    @staticmethod
    def to_dict(obj: BinanceFuturesMarkPriceUpdate) -> dict[str, Any]:
        """
        Return a dictionary representation of this object.
        Returns
        -------
        dict[str, Any]
        """
        return {
            "type": type(obj).__name__,
            "instrument_id": str(obj.instrument_id),
            "mark": str(obj.mark),
            "index": str(obj.index),
            "estimated_settle": str(obj.estimated_settle),
            "funding_rate": str(obj.funding_rate),
            "next_funding_ns": obj.next_funding_ns,
            "ts_event": obj.ts_event,
            "ts_init": obj.ts_init,
        }
</document_content>
</document>
<document index="1763">
<source>nautilus_trader/adapters/binance/http/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="1764">
<source>nautilus_trader/adapters/binance/http/account.py</source>
<document_content>

import msgspec
class BinanceOrderHttp(BinanceHttpEndpoint):
    """
    Endpoint for managing orders.
    `GET /api/v3/order`
    `GET /api/v3/order/test`
    `GET /fapi/v1/order`
    `GET /dapi/v1/order`
    `POST /api/v3/order`
    `POST /fapi/v1/order`
    `POST /dapi/v1/order`
    `DELETE /api/v3/order`
    `DELETE /fapi/v1/order`
    `DELETE /dapi/v1/order`
    `PUT /fapi/v1/order`
    `PUT /dapi/v1/order`
    Notes
    -----
    `PUT` method is not available for Spot/Margin.
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#new-order-trade
    https://binance-docs.github.io/apidocs/futures/en/#new-order-trade
    https://binance-docs.github.io/apidocs/delivery/en/#new-order-trade
    https://binance-docs.github.io/apidocs/futures/en/#modify-order-trade
    https://binance-docs.github.io/apidocs/delivery/en/#modify-order-trade
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
        testing_endpoint: bool | None = False,
    ) -> None:
        methods = {
            HttpMethod.GET: BinanceSecurityType.USER_DATA,
            HttpMethod.POST: BinanceSecurityType.TRADE,
            HttpMethod.DELETE: BinanceSecurityType.TRADE,
            HttpMethod.PUT: BinanceSecurityType.TRADE,
        }
        url_path = base_endpoint + "order"
        if testing_endpoint:
            url_path = url_path + "/test"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._resp_decoder = msgspec.json.Decoder(BinanceOrder)
    class GetDeleteParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Order management GET & DELETE endpoint parameters.
        Parameters
        ----------
        symbol : BinanceSymbol
            The symbol of the order
        timestamp : str
            The millisecond timestamp of the request
        orderId : int, optional
            The order identifier.
        origClientOrderId : str, optional
            The client specified order identifier.
        recvWindow : str, optional
            The millisecond timeout window.
        Warnings
        --------
        Either orderId or origClientOrderId must be sent.
        """
        symbol: BinanceSymbol
        timestamp: str
        orderId: int | None = None
        origClientOrderId: str | None = None
        recvWindow: str | None = None
    class PostParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Order creation POST endpoint parameters.
        Parameters
        ----------
        symbol : BinanceSymbol
            The symbol of the order
        timestamp : str
            The millisecond timestamp of the request
        side : BinanceOrderSide
            The market side of the order (BUY, SELL)
        type : BinanceOrderType
            The type of the order (LIMIT, STOP_LOSS..)
        timeInForce : BinanceTimeInForce, optional
            Mandatory for LIMIT, STOP_LOSS_LIMIT, TAKE_PROFIT_LIMIT orders.
            The time in force of the order (GTC, IOC..)
        positionSide : BinanceFuturesPositionSide, optional
            Only for FUTURES orders.
            Must be sent in Hedge Mode and the position side must be one of LONG and SHORT.
        quantity : str, optional
            Mandatory for all order types, except STOP_MARKET/TAKE_PROFIT_MARKET
            and TRAILING_STOP_MARKET orders
            The order quantity in base asset units for the request
        quoteOrderQty : str, optional
            Only for SPOT/MARGIN orders.
            Can be used alternatively to `quantity` for MARKET orders
            The order quantity in quote asset units for the request
        price : str, optional
            Mandatory for LIMIT, STOP_LOSS_LIMIT, TAKE_PROFIT_LIMIT, LIMIT_MAKER,
            STOP, TAKE_PROFIT orders.
            The order price for the request.
        priceMatch : str, optional
            Only for FUTURES LIMIT/STOP/TAKE_PROFIT orders.
            Enables Binance BBO matching; cannot be sent together with `price`.
        newClientOrderId : str, optional
            The client order ID for the request. A unique ID among open orders.
            Automatically generated if not provided.
        strategyId : int,  optional
            Only for SPOT/MARGIN orders.
            The client strategy ID for the request.
        strategyType : int, optional
            Only for SPOT/MARGIN orders
            The client strategy type for the request. Cannot be less than 1000000
        stopPrice : str, optional
            Mandatory for STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, TAKE_PROFIT_LIMIT,
            STOP, STOP_MARKET, TAKE_PROFIT_MARKET.
            The order stop price for the request.
        trailingDelta : str, optional
            Only for SPOT/MARGIN orders
            Can be used instead of or in addition to stopPrice for STOP_LOSS,
            STOP_LOSS_LIMIT, TAKE_PROFIT, TAKE_PROFIT_LIMIT orders.
            The order trailing delta of the request.
        icebergQty : str, optional
            Only for SPOT/MARGIN orders
            Can be used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to
            create an iceberg order.
        reduceOnly : str ('true', 'false'), optional
            Only for FUTURES orders
            Cannot be sent in Hedge Mode, cannot be sent with closePosition = 'true'
        closePosition : str ('true', 'false'), optional
            Only for FUTURES orders
            Can be used with STOP_MARKET or TAKE_PROFIT_MARKET orders
            Whether to close all open positions for the given symbol.
        activationPrice : str, optional
            Only for FUTURES orders
            Can be used with TRAILING_STOP_MARKET orders.
            Defaults to the latest price.
        callbackRate : str, optional
            Only for FUTURES orders
            Mandatory for TRAILING_STOP_MARKET orders.
            The order trailing delta of the request.
        workingType : str ("MARK_PRICE", "CONTRACT_PRICE"), optional
            Only for FUTURES orders
            The trigger type for the order.
            Defaults to "CONTRACT_PRICE"
        priceProtect : str ('true', 'false'), optional
            Only for FUTURES orders
            Whether price protection is active.
            Defaults to 'false'
        newOrderRespType : NewOrderRespType, optional
            The response type for the order request.
            SPOT/MARGIN MARKET, LIMIT orders default to FULL.
            All others default to ACK.
            FULL response only for SPOT/MARGIN orders.
        goodTillDate : int, optional
            The order cancel time for timeInForce GTD, mandatory when timeEnforce set to GTD;
            order the timestamp only retains second-level precision, ms part will be ignored.
            The goodTillDate timestamp must be greater than the current time plus 600 seconds and
            smaller than 253402300799000.
        recvWindow : str, optional
            The response receive window in milliseconds for the request.
            Cannot exceed 60000.
        """
        symbol: BinanceSymbol
        timestamp: str
        side: BinanceOrderSide
        type: BinanceOrderType
        timeInForce: BinanceTimeInForce | None = None
        positionSide: BinanceFuturesPositionSide | None = None
        quantity: str | None = None
        quoteOrderQty: str | None = None
        price: str | None = None
        priceMatch: str | None = None
        newClientOrderId: str | None = None
        strategyId: int | None = None
        strategyType: int | None = None
        stopPrice: str | None = None
        trailingDelta: str | None = None
        icebergQty: str | None = None
        reduceOnly: str | None = None
        closePosition: str | None = None
        activationPrice: str | None = None
        callbackRate: str | None = None
        workingType: str | None = None
        priceProtect: str | None = None
        newOrderRespType: BinanceNewOrderRespType | None = None
        goodTillDate: int | None = None
        recvWindow: str | None = None
    class PutParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Order amendment PUT endpoint parameters.
        Parameters
        ----------
        orderId : int, optional
            The order ID for the request.
        origClientOrderId : str, optional
            The client specified order identifier.
        symbol : BinanceSymbol
            The symbol of the order.
        side : BinanceOrderSide
            The market side of the order (BUY, SELL).
        quantity : str, optional
            The order quantity in base asset units for the request.
        price : str, optional
            The order price for the request.
        recvWindow : str, optional
            The response receive window in milliseconds for the request.
            Cannot exceed 60000.
        timestamp : str
            The millisecond timestamp of the request.
        """
        symbol: BinanceSymbol
        side: BinanceOrderSide
        quantity: str
        price: str
        timestamp: str
        orderId: int | None = None
        origClientOrderId: str | None = None
        recvWindow: str | None = None
    async def get(self, params: GetDeleteParameters) -> BinanceOrder:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._resp_decoder.decode(raw)
    async def delete(self, params: GetDeleteParameters) -> BinanceOrder:
        method_type = HttpMethod.DELETE
        raw = await self._method(method_type, params)
        return self._resp_decoder.decode(raw)
    async def post(self, params: PostParameters) -> BinanceOrder:
        method_type = HttpMethod.POST
        raw = await self._method(method_type, params)
        return self._resp_decoder.decode(raw)
    async def put(self, params: PutParameters) -> BinanceOrder:
        method_type = HttpMethod.PUT
        raw = await self._method(method_type, params)
        return self._resp_decoder.decode(raw)
class BinanceAllOrdersHttp(BinanceHttpEndpoint):
    """
    Endpoint of all account orders, active, cancelled or filled.
    `GET /api/v3/allOrders`
    `GET /fapi/v1/allOrders`
    `GET /dapi/v1/allOrders`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#all-orders-user_data
    https://binance-docs.github.io/apidocs/futures/en/#all-orders-user_data
    https://binance-docs.github.io/apidocs/delivery/en/#all-orders-user_data
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.USER_DATA,
        }
        url_path = base_endpoint + "allOrders"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_resp_decoder = msgspec.json.Decoder(list[BinanceOrder])
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Parameters of allOrders GET request.
        Parameters
        ----------
        symbol : BinanceSymbol
            The symbol of the orders
        timestamp : str
            The millisecond timestamp of the request
        orderId : int, optional
            The order ID for the request.
            If included, request will return orders from this orderId INCLUSIVE
        startTime : int, optional
            The start time (UNIX milliseconds) filter for the request.
        endTime : int, optional
            The end time (UNIX milliseconds) filter for the request.
        limit : int, optional
            The limit for the response.
            Default 500, max 1000
        recvWindow : str, optional
            The response receive window for the request (cannot be greater than 60000).
        """
        symbol: BinanceSymbol
        timestamp: str
        orderId: int | None = None
        startTime: int | None = None
        endTime: int | None = None
        limit: int | None = None
        recvWindow: str | None = None
    async def get(self, params: GetParameters) -> list[BinanceOrder]:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._get_resp_decoder.decode(raw)
class BinanceOpenOrdersHttp(BinanceHttpEndpoint):
    """
    Endpoint of all open orders on a symbol.
    `GET /api/v3/openOrders`
    `GET /fapi/v1/openOrders`
    `GET /dapi/v1/openOrders`
    Warnings
    --------
    Care should be taken when accessing this endpoint with no symbol specified.
    The weight usage can be very large, which may cause rate limits to be hit.
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#current-open-orders-user_data
    https://binance-docs.github.io/apidocs/futures/en/#current-all-open-orders-user_data
    https://binance-docs.github.io/apidocs/futures/en/#current-all-open-orders-user_data
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
        methods: dict[HttpMethod, BinanceSecurityType] | None = None,
    ):
        if methods is None:
            methods = {
                HttpMethod.GET: BinanceSecurityType.USER_DATA,
            }
        url_path = base_endpoint + "openOrders"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_resp_decoder = msgspec.json.Decoder(list[BinanceOrder])
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Parameters of openOrders GET request.
        Parameters
        ----------
        timestamp : str
            The millisecond timestamp of the request
        symbol : BinanceSymbol, optional
            The symbol of the orders
        recvWindow : str, optional
            The response receive window for the request (cannot be greater than 60000).
        """
        timestamp: str
        symbol: BinanceSymbol | None = None
        recvWindow: str | None = None
    async def get(self, params: GetParameters) -> list[BinanceOrder]:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._get_resp_decoder.decode(raw)
class BinanceUserTradesHttp(BinanceHttpEndpoint):
    """
    Endpoint of trades for a specific account and symbol.
    `GET /api/v3/myTrades`
    `GET /fapi/v1/userTrades`
    `GET /dapi/v1/userTrades`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#account-trade-list-user_data
    https://binance-docs.github.io/apidocs/futures/en/#account-trade-list-user_data
    https://binance-docs.github.io/apidocs/delivery/en/#account-trade-list-user_data
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        url_path: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.USER_DATA,
        }
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_resp_decoder = msgspec.json.Decoder(list[BinanceUserTrade])
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Parameters of allOrders GET request.
        Parameters
        ----------
        symbol : BinanceSymbol
            The symbol of the orders
        timestamp : str
            The millisecond timestamp of the request
        orderId : int, optional
            The order ID for the request.
            If included, request will return orders from this orderId INCLUSIVE
        startTime : int, optional
            The start time (UNIX milliseconds) filter for the request.
        endTime : int, optional
            The end time (UNIX milliseconds) filter for the request.
        fromId : int, optional
            Trade ID to fetch from. Default gets most recent trades.
        limit : int, optional
            The limit for the response.
            Default 500, max 1000
        recvWindow : str, optional
            The response receive window for the request (cannot be greater than 60000).
        """
        symbol: BinanceSymbol
        timestamp: str
        orderId: int | None = None
        startTime: int | None = None
        endTime: int | None = None
        fromId: int | None = None
        limit: int | None = None
        recvWindow: str | None = None
    async def _get(self, params: GetParameters) -> list[BinanceUserTrade]:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._get_resp_decoder.decode(raw)
class BinanceAccountHttpAPI:
    """
    Provides access to the Binance Account/Trade HTTP REST API.
    Parameters
    ----------
    client : BinanceHttpClient
        The Binance REST API client.
    account_type : BinanceAccountType
        The Binance account type, used to select the endpoint prefix
    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        clock: LiveClock,
        account_type: BinanceAccountType,
    ):
        PyCondition.not_none(client, "client")
        self.client = client
        self._clock = clock
        if account_type.is_spot_or_margin:
            self.base_endpoint = "/api/v3/"
            user_trades_url = self.base_endpoint + "myTrades"
        elif account_type == BinanceAccountType.USDT_FUTURES:
            self.base_endpoint = "/fapi/v1/"
            user_trades_url = self.base_endpoint + "userTrades"
        elif account_type == BinanceAccountType.COIN_FUTURES:
            self.base_endpoint = "/dapi/v1/"
            user_trades_url = self.base_endpoint + "userTrades"
        else:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"invalid `BinanceAccountType`, was {account_type}",  # pragma: no cover
            )
        # Create endpoints
        self._endpoint_order = BinanceOrderHttp(client, self.base_endpoint)
        self._endpoint_all_orders = BinanceAllOrdersHttp(client, self.base_endpoint)
        self._endpoint_open_orders = BinanceOpenOrdersHttp(client, self.base_endpoint)
        self._endpoint_user_trades = BinanceUserTradesHttp(client, user_trades_url)
    def _timestamp(self) -> str:
        """
        Create Binance timestamp from internal clock.
        """
        return str(self._clock.timestamp_ms())
    async def query_order(
        self,
        symbol: str,
        order_id: int | None = None,
        orig_client_order_id: str | None = None,
        recv_window: str | None = None,
    ) -> BinanceOrder:
        """
        Check an order status.
        """
        if order_id is None and orig_client_order_id is None:
            raise RuntimeError(
                "Either orderId or origClientOrderId must be sent.",
            )
        binance_order = await self._endpoint_order.get(
            params=self._endpoint_order.GetDeleteParameters(
                symbol=BinanceSymbol(symbol),
                timestamp=self._timestamp(),
                orderId=order_id,
                origClientOrderId=orig_client_order_id,
                recvWindow=recv_window,
            ),
        )
        return binance_order
    async def cancel_all_open_orders(
        self,
        symbol: str,
        recv_window: str | None = None,
    ) -> bool:
        # Implement in child class
        raise NotImplementedError
    async def cancel_order(
        self,
        symbol: str,
        order_id: int | None = None,
        orig_client_order_id: str | None = None,
        recv_window: str | None = None,
    ) -> BinanceOrder:
        """
        Cancel an active order.
        """
        if order_id is None and orig_client_order_id is None:
            raise RuntimeError(
                "Either orderId or origClientOrderId must be sent.",
            )
        binance_order = await self._endpoint_order.delete(
            params=self._endpoint_order.GetDeleteParameters(
                symbol=BinanceSymbol(symbol),
                timestamp=self._timestamp(),
                orderId=order_id,
                origClientOrderId=orig_client_order_id,
                recvWindow=recv_window,
            ),
        )
        return binance_order
    async def new_order(
        self,
        symbol: str,
        side: BinanceOrderSide,
        order_type: BinanceOrderType,
        time_in_force: BinanceTimeInForce | None = None,
        position_side: BinanceFuturesPositionSide | None = None,
        quantity: str | None = None,
        quote_order_qty: str | None = None,
        price: str | None = None,
        price_match: str | None = None,
        new_client_order_id: str | None = None,
        strategy_id: int | None = None,
        strategy_type: int | None = None,
        stop_price: str | None = None,
        trailing_delta: str | None = None,
        iceberg_qty: str | None = None,
        reduce_only: str | None = None,
        close_position: str | None = None,
        activation_price: str | None = None,
        callback_rate: str | None = None,
        working_type: str | None = None,
        price_protect: str | None = None,
        good_till_date: int | None = None,
        new_order_resp_type: BinanceNewOrderRespType | None = None,
        recv_window: str | None = None,
    ) -> BinanceOrder:
        """
        Send in a new order to Binance.
        """
        binance_order = await self._endpoint_order.post(
            params=self._endpoint_order.PostParameters(
                symbol=BinanceSymbol(symbol),
                timestamp=self._timestamp(),
                side=side,
                type=order_type,
                timeInForce=time_in_force,
                positionSide=position_side,
                quantity=quantity,
                quoteOrderQty=quote_order_qty,
                price=price,
                priceMatch=price_match,
                newClientOrderId=new_client_order_id,
                strategyId=strategy_id,
                strategyType=strategy_type,
                stopPrice=stop_price,
                trailingDelta=trailing_delta,
                icebergQty=iceberg_qty,
                reduceOnly=reduce_only,
                closePosition=close_position,
                activationPrice=activation_price,
                callbackRate=callback_rate,
                workingType=working_type,
                priceProtect=price_protect,
                goodTillDate=good_till_date,
                newOrderRespType=new_order_resp_type,
                recvWindow=recv_window,
            ),
        )
        return binance_order
    async def modify_order(
        self,
        symbol: str,
        side: BinanceOrderSide,
        quantity: str,
        price: str,
        order_id: int | None = None,
        orig_client_order_id: str | None = None,
        recv_window: str | None = None,
    ) -> BinanceOrder:
        """
        Modify a LIMIT order with Binance.
        """
        binance_order = await self._endpoint_order.put(
            params=self._endpoint_order.PutParameters(
                symbol=BinanceSymbol(symbol),
                timestamp=self._timestamp(),
                orderId=order_id,
                origClientOrderId=orig_client_order_id,
                side=side,
                quantity=quantity,
                price=price,
                recvWindow=recv_window,
            ),
        )
        return binance_order
    async def query_all_orders(
        self,
        symbol: str,
        order_id: int | None = None,
        start_time: int | None = None,
        end_time: int | None = None,
        limit: int | None = None,
        recv_window: str | None = None,
    ) -> list[BinanceOrder]:
        """
        Query all orders, active or filled.
        """
        return await self._endpoint_all_orders.get(
            params=self._endpoint_all_orders.GetParameters(
                symbol=BinanceSymbol(symbol),
                timestamp=self._timestamp(),
                orderId=order_id,
                startTime=start_time,
                endTime=end_time,
                limit=limit,
                recvWindow=recv_window,
            ),
        )
    async def query_open_orders(
        self,
        symbol: str | None = None,
        recv_window: str | None = None,
    ) -> list[BinanceOrder]:
        """
        Query open orders.
        """
        return await self._endpoint_open_orders.get(
            params=self._endpoint_open_orders.GetParameters(
                symbol=BinanceSymbol(symbol) if symbol else None,
                timestamp=self._timestamp(),
                recvWindow=recv_window,
            ),
        )
    async def query_user_trades(
        self,
        symbol: str,
        order_id: int | None = None,
        start_time: int | None = None,
        end_time: int | None = None,
        from_id: int | None = None,
        limit: int | None = None,
        recv_window: str | None = None,
    ) -> list[BinanceUserTrade]:
        """
        Query user's trade history for a symbol, with provided filters.
        """
        if (order_id or from_id) is not None and (start_time or end_time) is not None:
            raise RuntimeError(
                "Cannot specify both order_id/from_id AND start_time/end_time parameters.",
            )
        return await self._endpoint_user_trades._get(
            params=self._endpoint_user_trades.GetParameters(
                symbol=BinanceSymbol(symbol),
                timestamp=self._timestamp(),
                orderId=order_id,
                startTime=start_time,
                endTime=end_time,
                fromId=from_id,
                limit=limit,
                recvWindow=recv_window,
            ),
        )
</document_content>
</document>
<document index="1765">
<source>nautilus_trader/adapters/binance/http/client.py</source>
<document_content>

import base64
import urllib.parse
from typing import Any
import msgspec
import nautilus_trader
class BinanceHttpClient:
    """
    Provides a Binance asynchronous HTTP client.
    Parameters
    ----------
    clock : LiveClock
        The clock for the client.
    api_key : str
        The Binance API key for requests.
    api_secret : str
        The Binance API secret for signed requests.
    key_type : BinanceKeyType, default 'HMAC'
        The private key cryptographic algorithm type.
    rsa_private_key : str, optional
        The RSA private key for RSA signing.
    ed25519_private_key : str, optional
        The Ed25519 private key for Ed25519 signing.
    base_url : str, optional
        The base endpoint URL for the client.
    ratelimiter_quotas : list[tuple[str, Quota]], optional
        The keyed rate limiter quotas for the client.
    ratelimiter_quota : Quota, optional
        The default rate limiter quota for the client.
    proxy_url : str, optional
        The proxy URL for HTTP requests.
    """
    def __init__(
        self,
        clock: LiveClock,
        api_key: str,
        api_secret: str,
        base_url: str,
        key_type: BinanceKeyType = BinanceKeyType.HMAC,
        rsa_private_key: str | None = None,
        ed25519_private_key: str | None = None,
        ratelimiter_quotas: list[tuple[str, Quota]] | None = None,
        ratelimiter_default_quota: Quota | None = None,
        proxy_url: str | None = None,
    ) -> None:
        self._clock: LiveClock = clock
        self._log: Logger = Logger(type(self).__name__)
        self._key: str = api_key
        self._base_url: str = base_url
        self._secret: str = api_secret
        self._key_type: BinanceKeyType = key_type
        self._rsa_private_key: str | None = rsa_private_key
        self._ed25519_private_key: bytes | None = None
        if ed25519_private_key:
            # Decode base64 ASN.1/DER format
            key_bytes = base64.b64decode(ed25519_private_key)
            # ASN.1/DER structure: the 32-byte seed is typically at the end
            self._ed25519_private_key = key_bytes[-32:]
        self._headers: dict[str, Any] = {
            "Content-Type": "application/json",
            "User-Agent": nautilus_trader.NAUTILUS_USER_AGENT,
            "X-MBX-APIKEY": api_key,
        }
        self._client = HttpClient(
            keyed_quotas=ratelimiter_quotas or [],
            default_quota=ratelimiter_default_quota,
            proxy_url=proxy_url,
        )
    @property
    def base_url(self) -> str:
        """
        Return the base URL being used by the client.
        Returns
        -------
        str
        """
        return self._base_url
    @property
    def api_key(self) -> str:
        """
        Return the Binance API key being used by the client.
        Returns
        -------
        str
        """
        return self._key
    @property
    def headers(self):
        """
        Return the headers being used by the client.
        Returns
        -------
        str
        """
        return self._headers
    def _prepare_params(self, params: dict[str, Any]) -> str:
        # Encode a dict into a URL query string
        return urllib.parse.urlencode(params)
    def _get_sign(self, data: str) -> str:
        match self._key_type:
            case BinanceKeyType.HMAC:
                return hmac_signature(self._secret, data)
            case BinanceKeyType.RSA:
                if not self._rsa_private_key:
                    raise ValueError("`rsa_private_key` was `None`")
                return rsa_signature(self._rsa_private_key, data)
            case BinanceKeyType.ED25519:
                if not self._ed25519_private_key:
                    raise ValueError("`ed25519_private_key` was `None`")
                return ed25519_signature(self._ed25519_private_key, data)
            case _:
                # Theoretically unreachable but retained to keep the match exhaustive
                raise ValueError(f"Unsupported key type, was '{self._key_type.value}'")
    async def sign_request(
        self,
        http_method: HttpMethod,
        url_path: str,
        payload: dict[str, str] | None = None,
        ratelimiter_keys: list[str] | None = None,
    ) -> Any:
        if payload is None:
            payload = {}
        query_string = self._prepare_params(payload)
        signature = self._get_sign(query_string)
        payload["signature"] = signature
        return await self.send_request(
            http_method,
            url_path,
            payload=payload,
            ratelimiter_keys=ratelimiter_keys,
        )
    async def send_request(
        self,
        http_method: HttpMethod,
        url_path: str,
        payload: dict[str, str] | None = None,
        ratelimiter_keys: list[str] | None = None,
    ) -> bytes:
        if payload:
            url_path += "?" + urllib.parse.urlencode(payload)
            payload = None  # Don't send payload in the body
        self._log.debug(f"{url_path} {payload}", LogColor.MAGENTA)
        response: HttpResponse = await self._client.request(
            http_method,
            url=self._base_url + url_path,
            headers=self._headers,
            body=msgspec.json.encode(payload) if payload else None,
            keys=ratelimiter_keys,
        )
        response_body = response.body
        if response.status >= 400:
            try:
                message = msgspec.json.decode(response_body) if response_body else None
            except msgspec.DecodeError:
                message = response_body.decode()
            if response.status >= 500:
                raise BinanceServerError(
                    status=response.status,
                    message=message,
                    headers=response.headers,
                )
            else:
                raise BinanceClientError(
                    status=response.status,
                    message=message,
                    headers=response.headers,
                )
        return response.body
</document_content>
</document>
<document index="1766">
<source>nautilus_trader/adapters/binance/http/endpoint.py</source>
<document_content>

from typing import Any
import msgspec
def enc_hook(obj: Any) -> Any:
    if isinstance(obj, (BinanceSymbol, BinanceSymbols)):
        return str(obj)  # serialize BinanceSymbol as string.
    else:
        raise TypeError(f"Objects of type {type(obj)} are not supported")
class BinanceHttpEndpoint:
    """
    Base functionality of endpoints connecting to the Binance REST API.
    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        methods_desc: dict[HttpMethod, BinanceSecurityType],
        url_path: str,
    ):
        self.client = client
        self.methods_desc = methods_desc
        self.url_path = url_path
        self._ratelimiter_key = f"binance:{url_path}"
        self.decoder = msgspec.json.Decoder()
        self.encoder = msgspec.json.Encoder(enc_hook=enc_hook)
        self._method_request = {
            BinanceSecurityType.NONE: self.client.send_request,
            BinanceSecurityType.USER_STREAM: self.client.send_request,
            BinanceSecurityType.MARKET_DATA: self.client.send_request,
            BinanceSecurityType.TRADE: self.client.sign_request,
            BinanceSecurityType.MARGIN: self.client.sign_request,
            BinanceSecurityType.USER_DATA: self.client.sign_request,
        }
    async def _method(
        self,
        method_type: HttpMethod,
        params: Any,
        ratelimiter_keys: list[str] | None = None,
    ) -> bytes:
        payload: dict = self.decoder.decode(self.encoder.encode(params))
        if self.methods_desc[method_type] is None:
            raise RuntimeError(
                f"{method_type.name} not available for {self.url_path}",
            )
        default_keys: list[str] = []
        if ratelimiter_keys:
            default_keys.extend(ratelimiter_keys)
        default_keys.append(self._ratelimiter_key)
        default_keys.append("binance:global")
        # Maintain order but remove duplicates so overlapping quotas only queue once
        unique_keys: list[str] = []
        seen: set[str] = set()
        for key in default_keys:
            if key not in seen:
                seen.add(key)
                unique_keys.append(key)
        raw: bytes = await self._method_request[self.methods_desc[method_type]](
            http_method=method_type,
            url_path=self.url_path,
            payload=payload,
            ratelimiter_keys=unique_keys,
        )
        return raw
</document_content>
</document>
<document index="1767">
<source>nautilus_trader/adapters/binance/http/error.py</source>
<document_content>

class BinanceError(Exception):
    """
    The base class for all Binance specific errors.
    """
    def __init__(self, status, message, headers):
        super().__init__(message)
        self.status = status
        self.message = message
        self.headers = headers
class BinanceServerError(BinanceError):
    """
    Represents an Binance specific 500 series HTTP error.
    """
    def __init__(self, status, message, headers):
        super().__init__(status, message, headers)
class BinanceClientError(BinanceError):
    """
    Represents an Binance specific 400 series HTTP error.
    """
    def __init__(self, status, message, headers):
        super().__init__(status, message, headers)
def get_binance_error_code(error: BaseException) -> BinanceErrorCode | None:
    """
    Extract the Binance error code from an exception.
    Parameters
    ----------
    error : BaseException
        The error to extract the code from.
    Returns
    -------
    BinanceErrorCode | None
        The error code if it can be extracted, otherwise None.
    """
    if isinstance(error, BinanceError):
        try:
            # Handle case where message might be a dict, string, or missing 'code' key
            if isinstance(error.message, dict) and "code" in error.message:
                return BinanceErrorCode(int(error.message["code"]))
            elif isinstance(error.message, str):
                # Try to parse error code from string format like '{"code":-1021,"msg":"..."}'
                import json
                try:
                    parsed_message = json.loads(error.message)
                    if isinstance(parsed_message, dict) and "code" in parsed_message:
                        return BinanceErrorCode(int(parsed_message["code"]))
                except (json.JSONDecodeError, ValueError, KeyError):
                    pass
        except (ValueError, KeyError, TypeError):
            pass  # If any parsing fails, return None
    return None
def should_retry(error: BaseException) -> bool:
    """
    Determine if a retry should be attempted based on the error code.
    Parameters
    ----------
    error : BaseException
        The error to check.
    Returns
    -------
    bool
        True if should retry, otherwise False.
    """
    error_code = get_binance_error_code(error)
    return error_code in BINANCE_RETRY_ERRORS if error_code else False
</document_content>
</document>
<document index="1768">
<source>nautilus_trader/adapters/binance/http/market.py</source>
<document_content>

import sys
import time
import msgspec
class BinancePingHttp(BinanceHttpEndpoint):
    """
    Endpoint for testing connectivity to the REST API.
    `GET /api/v3/ping`
    `GET /fapi/v1/ping`
    `GET /dapi/v1/ping`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#test-connectivity
    https://binance-docs.github.io/apidocs/futures/en/#test-connectivity
    https://binance-docs.github.io/apidocs/delivery/en/#test-connectivity
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.NONE,
        }
        url_path = base_endpoint + "ping"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_resp_decoder = msgspec.json.Decoder()
    async def get(self) -> dict:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, None)
        return self._get_resp_decoder.decode(raw)
class BinanceTimeHttp(BinanceHttpEndpoint):
    """
    Endpoint for testing connectivity to the REST API and receiving current server time.
    `GET /api/v3/time`
    `GET /fapi/v1/time`
    `GET /dapi/v1/time`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#check-server-time
    https://binance-docs.github.io/apidocs/futures/en/#check-server-time
    https://binance-docs.github.io/apidocs/delivery/en/#check-server-time
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.NONE,
        }
        url_path = base_endpoint + "time"
        super().__init__(client, methods, url_path)
        self._get_resp_decoder = msgspec.json.Decoder(BinanceTime)
    async def get(self) -> BinanceTime:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, None)
        return self._get_resp_decoder.decode(raw)
class BinanceDepthHttp(BinanceHttpEndpoint):
    """
    Endpoint of orderbook depth.
    `GET /api/v3/depth`
    `GET /fapi/v1/depth`
    `GET /dapi/v1/depth`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#order-book
    https://binance-docs.github.io/apidocs/futures/en/#order-book
    https://binance-docs.github.io/apidocs/delivery/en/#order-book
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.NONE,
        }
        url_path = base_endpoint + "depth"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_resp_decoder = msgspec.json.Decoder(BinanceDepth)
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Orderbook depth GET endpoint parameters.
        Parameters
        ----------
        symbol : BinanceSymbol
            The trading pair.
        limit : int, optional, default 100
            The limit for the response.
            SPOT/MARGIN (GET /api/v3/depth)
                Default 100; max 5000.
            FUTURES (GET /*api/v1/depth)
                Default 500; max 1000.
                Valid limits:[5, 10, 20, 50, 100, 500, 1000].
        """
        symbol: BinanceSymbol
        limit: int | None = None
    async def get(self, params: GetParameters) -> BinanceDepth:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._get_resp_decoder.decode(raw)
class BinanceTradesHttp(BinanceHttpEndpoint):
    """
    Endpoint of recent market trades.
    `GET /api/v3/trades`
    `GET /fapi/v1/trades`
    `GET /dapi/v1/trades`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#recent-trades-list
    https://binance-docs.github.io/apidocs/futures/en/#recent-trades-list
    https://binance-docs.github.io/apidocs/delivery/en/#recent-trades-list
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.NONE,
        }
        url_path = base_endpoint + "trades"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_resp_decoder = msgspec.json.Decoder(list[BinanceTrade])
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        GET parameters for recent trades.
        Parameters
        ----------
        symbol : BinanceSymbol
            The trading pair.
        limit : int, optional
            The limit for the response. Default 500; max 1000.
        """
        symbol: BinanceSymbol
        limit: int | None = None
    async def get(self, params: GetParameters) -> list[BinanceTrade]:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._get_resp_decoder.decode(raw)
class BinanceHistoricalTradesHttp(BinanceHttpEndpoint):
    """
    Endpoint of older market historical trades.
    `GET /api/v3/historicalTrades`
    `GET /fapi/v1/historicalTrades`
    `GET /dapi/v1/historicalTrades`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#old-trade-lookup-market_data
    https://binance-docs.github.io/apidocs/futures/en/#old-trades-lookup-market_data
    https://binance-docs.github.io/apidocs/delivery/en/#old-trades-lookup-market_data
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.MARKET_DATA,
        }
        url_path = base_endpoint + "historicalTrades"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_resp_decoder = msgspec.json.Decoder(list[BinanceTrade])
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        GET parameters for historical trades.
        Parameters
        ----------
        symbol : BinanceSymbol
            The trading pair.
        limit : int, optional
            The limit for the response. Default 500; max 1000.
        fromId : int, optional
            Trade ID to fetch from. Default gets most recent trades
        """
        symbol: BinanceSymbol
        limit: int | None = None
        fromId: int | None = None
    async def get(self, params: GetParameters) -> list[BinanceTrade]:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._get_resp_decoder.decode(raw)
class BinanceAggTradesHttp(BinanceHttpEndpoint):
    """
    Endpoint of compressed and aggregated market trades. Market trades that fill in
    100ms with the same price and same taking side will have the quantity aggregated.
    `GET /api/v3/aggTrades`
    `GET /fapi/v1/aggTrades`
    `GET /dapi/v1/aggTrades`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#compressed-aggregate-trades-list
    https://binance-docs.github.io/apidocs/futures/en/#compressed-aggregate-trades-list
    https://binance-docs.github.io/apidocs/delivery/en/#compressed-aggregate-trades-list
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.NONE,
        }
        url_path = base_endpoint + "aggTrades"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_resp_decoder = msgspec.json.Decoder(list[BinanceAggTrade])
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        GET parameters for aggregate trades.
        Parameters
        ----------
        symbol : BinanceSymbol
            The trading pair.
        limit : int, optional
            The limit for the response. Default 500; max 1000.
        fromId : int, optional
            Trade ID to fetch from INCLUSIVE.
        startTime : int, optional
            Timestamp in ms to get aggregate trades from INCLUSIVE.
        endTime : int, optional
            Timestamp in ms to get aggregate trades until INCLUSIVE.
        """
        symbol: BinanceSymbol
        limit: int | None = None
        fromId: int | None = None
        startTime: int | None = None
        endTime: int | None = None
    async def get(self, params: GetParameters) -> list[BinanceAggTrade]:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._get_resp_decoder.decode(raw)
class BinanceKlinesHttp(BinanceHttpEndpoint):
    """
    Endpoint of Kline/candlestick bars for a symbol. Klines are uniquely identified by
    their open time.
    `GET /api/v3/klines`
    `GET /fapi/v1/klines`
    `GET /dapi/v1/klines`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#kline-candlestick-data
    https://binance-docs.github.io/apidocs/futures/en/#kline-candlestick-data
    https://binance-docs.github.io/apidocs/delivery/en/#kline-candlestick-data
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.NONE,
        }
        url_path = base_endpoint + "klines"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_resp_decoder = msgspec.json.Decoder(list[BinanceKline])
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        GET parameters for klines.
        Parameters
        ----------
        symbol : BinanceSymbol
            The trading pair.
        interval : str
            The interval of kline, e.g 1m, 5m, 1h, 1d, etc.
        limit : int, optional
            The limit for the response. Default 500; max 1000.
        startTime : int, optional
            Timestamp in ms to get klines from INCLUSIVE.
        endTime : int, optional
            Timestamp in ms to get klines until INCLUSIVE.
        """
        symbol: BinanceSymbol
        interval: BinanceKlineInterval
        limit: int | None = None
        startTime: int | None = None
        endTime: int | None = None
    async def get(self, params: GetParameters) -> list[BinanceKline]:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._get_resp_decoder.decode(raw)
class BinanceTicker24hrHttp(BinanceHttpEndpoint):
    """
    Endpoint of 24-hour rolling window price change statistics.
    `GET /api/v3/ticker/24hr`
    `GET /fapi/v1/ticker/24hr`
    `GET /dapi/v1/ticker/24hr`
    Warnings
    --------
    Care should be taken when accessing this endpoint with no symbol specified.
    The weight usage can be very large, which may cause rate limits to be hit.
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#24hr-ticker-price-change-statistics
    https://binance-docs.github.io/apidocs/futures/en/#24hr-ticker-price-change-statistics
    https://binance-docs.github.io/apidocs/delivery/en/#24hr-ticker-price-change-statistics
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.NONE,
        }
        url_path = base_endpoint + "ticker/24hr"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_obj_resp_decoder = msgspec.json.Decoder(BinanceTicker24hr)
        self._get_arr_resp_decoder = msgspec.json.Decoder(list[BinanceTicker24hr])
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        GET parameters for 24hr ticker.
        Parameters
        ----------
        symbol : BinanceSymbol
            The trading pair. When given, endpoint will return a single BinanceTicker24hr
            When omitted, endpoint will return a list of BinanceTicker24hr for all trading pairs.
        symbols : BinanceSymbols
            SPOT/MARGIN only!
            List of trading pairs. When given, endpoint will return a list of BinanceTicker24hr.
        type : str
            SPOT/MARGIN only!
            Select between FULL and MINI 24hr ticker responses to save bandwidth.
        """
        symbol: BinanceSymbol | None = None
        symbols: BinanceSymbols | None = None  # SPOT/MARGIN only
        type: str | None = None  # SPOT/MARIN only
    async def _get(self, params: GetParameters) -> list[BinanceTicker24hr]:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        if params.symbol is not None:
            return [self._get_obj_resp_decoder.decode(raw)]
        else:
            return self._get_arr_resp_decoder.decode(raw)
class BinanceTickerPriceHttp(BinanceHttpEndpoint):
    """
    Endpoint of latest price for a symbol or symbols.
    `GET /api/v3/ticker/price`
    `GET /fapi/v2/ticker/price`
    `GET /dapi/v1/ticker/price`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#symbol-price-ticker
    https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Price-Ticker-v2
    https://binance-docs.github.io/apidocs/delivery/en/#symbol-price-ticker
    Notes
    -----
    USDT-margined futures uses v2 (v1 deprecated). Coin-margined remains on v1.
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.NONE,
        }
        # Only USDT-margined futures has v2, coin-margined still uses v1
        endpoint = base_endpoint.replace("/fapi/v1/", "/fapi/v2/")
        url_path = endpoint + "ticker/price"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_obj_resp_decoder = msgspec.json.Decoder(BinanceTickerPrice)
        self._get_arr_resp_decoder = msgspec.json.Decoder(list[BinanceTickerPrice])
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        GET parameters for price ticker.
        Parameters
        ----------
        symbol : BinanceSymbol
            The trading pair. When given, endpoint will return a single BinanceTickerPrice.
            When omitted, endpoint will return a list of BinanceTickerPrice for all trading pairs.
        symbols : str
            SPOT/MARGIN only!
            List of trading pairs. When given, endpoint will return a list of BinanceTickerPrice.
        """
        symbol: BinanceSymbol | None = None
        symbols: BinanceSymbols | None = None  # SPOT/MARGIN only
    async def _get(self, params: GetParameters) -> list[BinanceTickerPrice]:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        if params.symbol is not None:
            return [self._get_obj_resp_decoder.decode(raw)]
        else:
            return self._get_arr_resp_decoder.decode(raw)
class BinanceTickerBookHttp(BinanceHttpEndpoint):
    """
    Endpoint of best price/qty on the order book for a symbol or symbols.
    `GET /api/v3/ticker/bookTicker`
    `GET /fapi/v1/ticker/bookTicker`
    `GET /dapi/v1/ticker/bookTicker`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#symbol-order-book-ticker
    https://binance-docs.github.io/apidocs/futures/en/#symbol-order-book-ticker
    https://binance-docs.github.io/apidocs/delivery/en/#symbol-order-book-ticker
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.NONE,
        }
        url_path = base_endpoint + "ticker/bookTicker"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_arr_resp_decoder = msgspec.json.Decoder(list[BinanceTickerBook])
        self._get_obj_resp_decoder = msgspec.json.Decoder(BinanceTickerBook)
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        GET parameters for order book ticker.
        Parameters
        ----------
        symbol : str
            The trading pair. When given, endpoint will return a single BinanceTickerBook
            When omitted, endpoint will return a list of BinanceTickerBook for all trading pairs.
        symbols : str
            SPOT/MARGIN only!
            List of trading pairs. When given, endpoint will return a list of BinanceTickerBook.
        """
        symbol: BinanceSymbol | None = None
        symbols: BinanceSymbols | None = None  # SPOT/MARGIN only
    async def _get(self, params: GetParameters) -> list[BinanceTickerBook]:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        if params.symbol is not None:
            return [self._get_obj_resp_decoder.decode(raw)]
        else:
            return self._get_arr_resp_decoder.decode(raw)
class BinanceMarketHttpAPI:
    """
    Provides access to the Binance Market HTTP REST API.
    Parameters
    ----------
    client : BinanceHttpClient
        The Binance REST API client.
    account_type : BinanceAccountType
        The Binance account type, used to select the endpoint prefix.
    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        account_type: BinanceAccountType,
    ):
        PyCondition.not_none(client, "client")
        self.client = client
        if account_type.is_spot_or_margin:
            self.base_endpoint = "/api/v3/"
        elif account_type == BinanceAccountType.USDT_FUTURES:
            self.base_endpoint = "/fapi/v1/"
        elif account_type == BinanceAccountType.COIN_FUTURES:
            self.base_endpoint = "/dapi/v1/"
        else:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"invalid `BinanceAccountType`, was {account_type}",  # pragma: no cover
            )
        # Create Endpoints
        self._endpoint_ping = BinancePingHttp(client, self.base_endpoint)
        self._endpoint_time = BinanceTimeHttp(client, self.base_endpoint)
        self._endpoint_depth = BinanceDepthHttp(client, self.base_endpoint)
        self._endpoint_trades = BinanceTradesHttp(client, self.base_endpoint)
        self._endpoint_historical_trades = BinanceHistoricalTradesHttp(client, self.base_endpoint)
        self._endpoint_agg_trades = BinanceAggTradesHttp(client, self.base_endpoint)
        self._endpoint_klines = BinanceKlinesHttp(client, self.base_endpoint)
        self._endpoint_ticker_24hr = BinanceTicker24hrHttp(client, self.base_endpoint)
        self._endpoint_ticker_price = BinanceTickerPriceHttp(client, self.base_endpoint)
        self._endpoint_ticker_book = BinanceTickerBookHttp(client, self.base_endpoint)
    async def ping(self) -> dict:
        """
        Ping Binance REST API.
        """
        return await self._endpoint_ping.get()
    async def request_server_time(self) -> int:
        """
        Request server time from Binance.
        """
        response = await self._endpoint_time.get()
        return response.serverTime
    async def query_depth(
        self,
        symbol: str,
        limit: int | None = None,
    ) -> BinanceDepth:
        """
        Query order book depth for a symbol.
        """
        return await self._endpoint_depth.get(
            params=self._endpoint_depth.GetParameters(
                symbol=BinanceSymbol(symbol),
                limit=limit,
            ),
        )
    async def request_order_book_snapshot(
        self,
        instrument_id: InstrumentId,
        ts_init: int,
        limit: int | None = None,
    ) -> OrderBookDeltas:
        """
        Request snapshot of order book depth.
        """
        depth = await self.query_depth(instrument_id.symbol.value, limit)
        return depth.parse_to_order_book_snapshot(
            instrument_id=instrument_id,
            ts_init=ts_init,
        )
    async def query_trades(
        self,
        symbol: str,
        limit: int | None = None,
    ) -> list[BinanceTrade]:
        """
        Query trades for symbol.
        """
        return await self._endpoint_trades.get(
            params=self._endpoint_trades.GetParameters(
                symbol=BinanceSymbol(symbol),
                limit=limit,
            ),
        )
    async def request_trade_ticks(
        self,
        instrument_id: InstrumentId,
        limit: int | None = None,
    ) -> list[TradeTick]:
        """
        Request TradeTicks from Binance.
        """
        trades = await self.query_trades(instrument_id.symbol.value, limit)
        return [
            trade.parse_to_trade_tick(
                instrument_id=instrument_id,
            )
            for trade in trades
        ]
    async def query_agg_trades(
        self,
        symbol: str,
        limit: int | None = None,
        start_time: int | None = None,
        end_time: int | None = None,
        from_id: int | None = None,
    ) -> list[BinanceAggTrade]:
        """
        Query aggregated trades for symbol.
        """
        return await self._endpoint_agg_trades.get(
            params=self._endpoint_agg_trades.GetParameters(
                symbol=BinanceSymbol(symbol),
                limit=limit,
                startTime=start_time,
                endTime=end_time,
                fromId=from_id,
            ),
        )
    async def request_agg_trade_ticks(
        self,
        instrument_id: InstrumentId,
        limit: int | None = 1000,
        start_time: int | None = None,
        end_time: int | None = None,
        from_id: int | None = None,
    ) -> list[TradeTick]:
        """
        Request TradeTicks from Binance aggregated trades.
        If start_time and end_time are both specified, will request *all* TradeTicks in
        the interval, making multiple requests if necessary.
        """
        ticks: list[TradeTick] = []
        next_start_time = start_time
        if end_time is None:
            end_time = sys.maxsize
        if from_id is not None and (start_time or end_time) is not None:
            raise RuntimeError(
                "Cannot specify both fromId and startTime or endTime.",
            )
        # Only split into separate requests if both start_time and end_time are specified
        max_interval = (1000 * 60 * 60) - 1  # 1ms under an hour, as specified in Futures docs.
        last_id = 0
        interval_limited = False
        def _calculate_next_end_time(start_time: int, end_time: int) -> tuple[int, bool]:
            next_interval = start_time + max_interval
            interval_limited = next_interval < end_time
            next_end_time = next_interval if interval_limited is True else end_time
            return next_end_time, interval_limited
        if start_time is not None and end_time is not None:
            next_end_time, interval_limited = _calculate_next_end_time(start_time, end_time)
        else:
            next_end_time = end_time
        while True:
            response = await self.query_agg_trades(
                instrument_id.symbol.value,
                limit,
                start_time=next_start_time,
                end_time=next_end_time,
                from_id=from_id,
            )
            for trade in response:
                if not trade.a > last_id:
                    # Skip duplicate trades
                    continue
                ticks.append(
                    trade.parse_to_trade_tick(
                        instrument_id=instrument_id,
                    ),
                )
            if limit and len(response) < limit and interval_limited is False:
                # end loop regardless when limit is not hit
                break
            if (
                start_time is None
                or end_time is None
                or next_end_time >= nanos_to_millis(time.time_ns())
            ):
                break
            else:
                last = response[-1]
                last_id = last.a
                next_start_time = last.T
                next_end_time, interval_limited = _calculate_next_end_time(
                    next_start_time,
                    end_time,
                )
                continue
        return ticks
    async def query_historical_trades(
        self,
        symbol: str,
        limit: int | None = None,
        from_id: int | None = None,
    ) -> list[BinanceTrade]:
        """
        Query historical trades for symbol.
        """
        return await self._endpoint_historical_trades.get(
            params=self._endpoint_historical_trades.GetParameters(
                symbol=BinanceSymbol(symbol),
                limit=limit,
                fromId=from_id,
            ),
        )
    async def request_historical_trade_ticks(
        self,
        instrument_id: InstrumentId,
        limit: int | None = None,
        from_id: int | None = None,
    ) -> list[TradeTick]:
        """
        Request historical TradeTicks from Binance.
        """
        historical_trades = await self.query_historical_trades(
            symbol=instrument_id.symbol.value,
            limit=limit,
            from_id=from_id,
        )
        return [
            trade.parse_to_trade_tick(
                instrument_id=instrument_id,
            )
            for trade in historical_trades
        ]
    async def query_klines(
        self,
        symbol: str,
        interval: BinanceKlineInterval,
        limit: int | None = None,
        start_time: int | None = None,
        end_time: int | None = None,
    ) -> list[BinanceKline]:
        """
        Query klines for a symbol over an interval.
        """
        return await self._endpoint_klines.get(
            params=self._endpoint_klines.GetParameters(
                symbol=BinanceSymbol(symbol),
                interval=interval,
                limit=limit,
                startTime=start_time,
                endTime=end_time,
            ),
        )
    async def request_binance_bars(
        self,
        bar_type: BarType,
        interval: BinanceKlineInterval,
        limit: int | None = None,
        start_time: int | None = None,
        end_time: int | None = None,
    ) -> list[BinanceBar]:
        """
        Request Binance Bars from Klines.
        """
        end_time_ms = int(end_time) if end_time is not None else sys.maxsize
        all_bars: list[BinanceBar] = []
        while True:
            klines = await self.query_klines(
                symbol=bar_type.instrument_id.symbol.value,
                interval=interval,
                limit=limit,
                start_time=start_time,
                end_time=end_time,
            )
            bars: list[BinanceBar] = [kline.parse_to_binance_bar(bar_type) for kline in klines]
            all_bars.extend(bars)
            # Update the start_time to fetch the next set of bars
            if klines:
                next_start_time = klines[-1].open_time + 1
            else:
                # Handle the case when klines is empty
                break
            # No more bars to fetch
            if (limit and len(klines) < limit) or next_start_time >= end_time_ms:
                break
            start_time = next_start_time
        return all_bars
    async def query_ticker_24hr(
        self,
        symbol: str | None = None,
        symbols: list[str] | None = None,
        response_type: str | None = None,
    ) -> list[BinanceTicker24hr]:
        """
        Query 24hr ticker for symbol or symbols.
        """
        if symbol is not None and symbols is not None:
            raise RuntimeError(
                "Cannot specify both symbol and symbols parameters.",
            )
        return await self._endpoint_ticker_24hr._get(
            params=self._endpoint_ticker_24hr.GetParameters(
                symbol=BinanceSymbol(symbol) if symbol else None,
                symbols=BinanceSymbols(symbols) if symbols else None,
                type=response_type,
            ),
        )
    async def query_ticker_price(
        self,
        symbol: str | None = None,
        symbols: list[str] | None = None,
    ) -> list[BinanceTickerPrice]:
        """
        Query price ticker for symbol or symbols.
        """
        if symbol is not None and symbols is not None:
            raise RuntimeError(
                "Cannot specify both symbol and symbols parameters.",
            )
        return await self._endpoint_ticker_price._get(
            params=self._endpoint_ticker_price.GetParameters(
                symbol=BinanceSymbol(symbol) if symbol else None,
                symbols=BinanceSymbols(symbols) if symbols else None,
            ),
        )
    async def query_ticker_book(
        self,
        symbol: str | None = None,
        symbols: list[str] | None = None,
    ) -> list[BinanceTickerBook]:
        """
        Query book ticker for symbol or symbols.
        """
        if symbol is not None and symbols is not None:
            raise RuntimeError(
                "Cannot specify both symbol and symbols parameters.",
            )
        return await self._endpoint_ticker_book._get(
            params=self._endpoint_ticker_book.GetParameters(
                symbol=BinanceSymbol(symbol) if symbol else None,
                symbols=BinanceSymbols(symbols) if symbols else None,
            ),
        )
</document_content>
</document>
<document index="1769">
<source>nautilus_trader/adapters/binance/http/user.py</source>
<document_content>

import msgspec
class BinanceListenKeyHttp(BinanceHttpEndpoint):
    """
    Endpoint for managing user data streams (listenKey).
    `POST /api/v3/userDataStream`
    `POST /sapi/v3/userDataStream`
    `POST /sapi/v3/userDataStream/isolated`
    `POST /fapi/v1/listenKey`
    `POST /dapi/v1/listenKey`
    `PUT /api/v3/userDataStream`
    `PUT /sapi/v3/userDataStream`
    `PUT /sapi/v3/userDataStream/isolated`
    `PUT /fapi/v1/listenKey`
    `PUT /dapi/v1/listenKey`
    `DELETE /api/v3/userDataStream`
    `DELETE /sapi/v3/userDataStream`
    `DELETE /sapi/v3/userDataStream/isolated`
    `DELETE /fapi/v1/listenKey`
    `DELETE /dapi/v1/listenKey`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#listen-key-spot
    https://binance-docs.github.io/apidocs/spot/en/#listen-key-margin
    https://binance-docs.github.io/apidocs/futures/en/#start-user-data-stream-user_stream
    https://binance-docs.github.io/apidocs/delivery/en/#start-user-data-stream-user_stream
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        url_path: str,
    ):
        methods = {
            HttpMethod.POST: BinanceSecurityType.USER_STREAM,
            HttpMethod.PUT: BinanceSecurityType.USER_STREAM,
            HttpMethod.DELETE: BinanceSecurityType.USER_STREAM,
        }
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._post_resp_decoder = msgspec.json.Decoder(BinanceListenKey)
        self._put_resp_decoder = msgspec.json.Decoder()
        self._delete_resp_decoder = msgspec.json.Decoder()
    class PostParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        POST parameters for creating listen keys.
        Parameters
        ----------
        symbol : BinanceSymbol
            The trading pair. Only required for ISOLATED MARGIN accounts!
        """
        symbol: BinanceSymbol | None = None  # MARGIN_ISOLATED only, mandatory
    class PutDeleteParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        PUT & DELETE parameters for managing listen keys.
        Parameters
        ----------
        symbol : BinanceSymbol
            The trading pair. Only required for ISOLATED MARGIN accounts!
        listenKey : str
            The listen key to manage. Only required for SPOT/MARGIN accounts!
        """
        symbol: BinanceSymbol | None = None  # MARGIN_ISOLATED only, mandatory
        listenKey: str | None = None  # SPOT/MARGIN only, mandatory
    async def _post(self, params: PostParameters | None = None) -> BinanceListenKey:
        method_type = HttpMethod.POST
        raw = await self._method(method_type, params)
        return self._post_resp_decoder.decode(raw)
    async def _put(self, params: PutDeleteParameters | None = None) -> dict:
        method_type = HttpMethod.PUT
        raw = await self._method(method_type, params)
        return self._put_resp_decoder.decode(raw)
    async def _delete(self, params: PutDeleteParameters | None = None) -> dict:
        method_type = HttpMethod.DELETE
        raw = await self._method(method_type, params)
        return self._delete_resp_decoder.decode(raw)
class BinanceUserDataHttpAPI:
    """
    Provides access to the Binance User HTTP REST API.
    Parameters
    ----------
    client : BinanceHttpClient
        The Binance REST API client.
    account_type : BinanceAccountType
        The Binance account type, used to select the endpoint.
    Warnings
    --------
    This class should not be used directly, but through a concrete subclass.
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        account_type: BinanceAccountType,
    ):
        PyCondition.not_none(client, "client")
        self.client = client
        self.account_type = account_type
        if account_type == BinanceAccountType.SPOT:
            self.base_endpoint = "/api/v3/"
            listen_key_url = self.base_endpoint + "userDataStream"
        elif account_type == BinanceAccountType.MARGIN:
            self.base_endpoint = "/sapi/v1/"
            listen_key_url = self.base_endpoint + "userDataStream"
        elif account_type == BinanceAccountType.ISOLATED_MARGIN:
            self.base_endpoint = "/sapi/v1/"
            listen_key_url = self.base_endpoint + "userDataStream/isolated"
        elif account_type == BinanceAccountType.USDT_FUTURES:
            self.base_endpoint = "/fapi/v1/"
            listen_key_url = self.base_endpoint + "listenKey"
        elif account_type == BinanceAccountType.COIN_FUTURES:
            self.base_endpoint = "/dapi/v1/"
            listen_key_url = self.base_endpoint + "listenKey"
        else:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"invalid `BinanceAccountType`, was {account_type}",  # pragma: no cover (design-time error)
            )
        self._endpoint_listenkey = BinanceListenKeyHttp(client, listen_key_url)
    async def create_listen_key(
        self,
        symbol: str | None = None,
    ) -> BinanceListenKey:
        """
        Create Binance ListenKey.
        """
        key = await self._endpoint_listenkey._post(
            params=self._endpoint_listenkey.PostParameters(
                symbol=BinanceSymbol(symbol) if symbol else None,
            ),
        )
        return key
    async def keepalive_listen_key(
        self,
        symbol: str | None = None,
        listen_key: str | None = None,
    ):
        """
        Ping/Keepalive Binance ListenKey.
        """
        await self._endpoint_listenkey._put(
            params=self._endpoint_listenkey.PutDeleteParameters(
                symbol=BinanceSymbol(symbol) if symbol else None,
                listenKey=listen_key,
            ),
        )
    async def delete_listen_key(
        self,
        symbol: str | None = None,
        listen_key: str | None = None,
    ):
        """
        Delete Binance ListenKey.
        """
        await self._endpoint_listenkey._delete(
            params=self._endpoint_listenkey.PutDeleteParameters(
                symbol=BinanceSymbol(symbol) if symbol else None,
                listenKey=listen_key,
            ),
        )
</document_content>
</document>
<document index="1770">
<source>nautilus_trader/adapters/binance/loaders.py</source>
<document_content>

from os import PathLike
import pandas as pd
class BinanceOrderBookDeltaDataLoader:
    """
    Provides a means of loading Binance order book data.
    """
    @classmethod
    def load(
        cls,
        file_path: PathLike[str] | str,
        nrows: int | None = None,
    ) -> pd.DataFrame:
        """
        Return the deltas `pandas.DataFrame` loaded from the given CSV `file_path`.
        Parameters
        ----------
        file_path : str, path object or file-like object
            The path to the CSV file.
        nrows : int, optional
            The maximum number of rows to load.
        Returns
        -------
        pd.DataFrame
        """
        df = pd.read_csv(file_path, nrows=nrows)
        # Convert the timestamp column from milliseconds to UTC datetime
        df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms", utc=True)
        df = df.set_index("timestamp")
        df = df.rename(columns={"qty": "size"})
        df["instrument_id"] = df["symbol"] + ".BINANCE"
        df["action"] = df.apply(cls.map_actions, axis=1)
        df["side"] = df["side"].apply(cls.map_sides)
        df["order_id"] = 0  # No order ID for level 2 data
        df["flags"] = df.apply(cls.map_flags, axis=1)
        df["sequence"] = df["last_update_id"]
        # Drop now redundant columns
        df = df.drop(columns=["symbol", "update_type", "first_update_id", "last_update_id"])
        # Reorder columns
        columns = [
            "instrument_id",
            "action",
            "side",
            "price",
            "size",
            "order_id",
            "flags",
            "sequence",
        ]
        df = df[columns]
        return df
    @classmethod
    def map_actions(cls, row: pd.Series) -> str:
        if row["update_type"] == "snap":
            return "ADD"
        elif row["size"] == 0:
            return "DELETE"
        else:
            return "UPDATE"
    @classmethod
    def map_sides(cls, side: str) -> str:
        side = side.lower()
        if side == "b":
            return "BUY"
        elif side == "a":
            return "SELL"
        else:
            raise RuntimeError(f"unrecognized side '{side}'")
    @classmethod
    def map_flags(cls, row: pd.Series) -> int:
        if row.update_type == "snap":
            return RecordFlag.F_SNAPSHOT.value
        else:
            return 0
</document_content>
</document>
<document index="1771">
<source>nautilus_trader/adapters/binance/spot/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="1772">
<source>nautilus_trader/adapters/binance/spot/data.py</source>
<document_content>

import asyncio
import msgspec
class BinanceSpotDataClient(BinanceCommonDataClient):
    """
    Provides a data client for the Binance Spot/Margin exchange.
    Parameters
    ----------
    loop : asyncio.AbstractEventLoop
        The event loop for the client.
    client : BinanceHttpClient
        The binance HTTP client.
    msgbus : MessageBus
        The message bus for the client.
    cache : Cache
        The cache for the client.
    clock : LiveClock
        The clock for the client.
    instrument_provider : InstrumentProvider
        The instrument provider.
    base_url_ws : str
        The base URL for the WebSocket client.
    config : BinanceDataClientConfig
        The configuration for the client.
    account_type : BinanceAccountType, default 'SPOT'
        The account type for the client.
    name : str, optional
        The custom client ID.
    """
    def __init__(
        self,
        loop: asyncio.AbstractEventLoop,
        client: BinanceHttpClient,
        msgbus: MessageBus,
        cache: Cache,
        clock: LiveClock,
        instrument_provider: InstrumentProvider,
        base_url_ws: str,
        config: BinanceDataClientConfig,
        account_type: BinanceAccountType = BinanceAccountType.SPOT,
        name: str | None = None,
    ) -> None:
        PyCondition.is_true(
            account_type.is_spot_or_margin,
            "account_type was not SPOT, MARGIN or ISOLATED_MARGIN",
        )
        # Spot HTTP API
        self._spot_http_market = BinanceSpotMarketHttpAPI(client, account_type)
        # Spot enum parser
        self._spot_enum_parser = BinanceSpotEnumParser()
        super().__init__(
            loop=loop,
            client=client,
            market=self._spot_http_market,
            enum_parser=self._spot_enum_parser,
            msgbus=msgbus,
            cache=cache,
            clock=clock,
            instrument_provider=instrument_provider,
            account_type=account_type,
            base_url_ws=base_url_ws,
            name=name,
            config=config,
        )
        # Websocket msgspec decoders
        self._decoder_spot_trade = msgspec.json.Decoder(BinanceSpotTradeMsg)
        self._decoder_spot_order_book_partial_depth = msgspec.json.Decoder(
            BinanceSpotOrderBookPartialDepthMsg,
        )
    # -- WEBSOCKET HANDLERS ---------------------------------------------------------------------------------
    def _handle_book_partial_update(self, raw: bytes) -> None:
        msg = self._decoder_spot_order_book_partial_depth.decode(raw)
        instrument_id: InstrumentId = self._get_cached_instrument_id(
            msg.stream.partition("@")[0],
        )
        book_snapshot: OrderBookDeltas = msg.data.parse_to_order_book_snapshot(
            instrument_id=instrument_id,
            ts_init=self._clock.timestamp_ns(),
        )
        # Check if book buffer active
        book_buffer: list[OrderBookDelta | OrderBookDeltas] | None = self._book_buffer.get(
            instrument_id,
        )
        if book_buffer is not None:
            book_buffer.append(book_snapshot)
        else:
            self._handle_data(book_snapshot)
    def _handle_trade(self, raw: bytes) -> None:
        msg = self._decoder_spot_trade.decode(raw)
        instrument_id: InstrumentId = self._get_cached_instrument_id(msg.data.s)
        trade_tick: TradeTick = msg.data.parse_to_trade_tick(
            instrument_id=instrument_id,
            ts_init=self._clock.timestamp_ns(),
        )
        self._handle_data(trade_tick)
</document_content>
</document>
<document index="1773">
<source>nautilus_trader/adapters/binance/spot/enums.py</source>
<document_content>

"""
Defines Binance Spot/Margin specific enums.
References
----------
https://binance-docs.github.io/apidocs/spot/en/#public-api-definitions
"""
from enum import Enum
from enum import unique
@unique
class BinanceSpotPermissions(Enum):
    """
    Represents Binance Spot/Margin trading permissions.
    """
    SPOT = "SPOT"
    MARGIN = "MARGIN"
    LEVERAGED = "LEVERAGED"
    TRD_GRP_002 = "TRD_GRP_002"
    TRD_GRP_003 = "TRD_GRP_003"
    TRD_GRP_004 = "TRD_GRP_004"
    TRD_GRP_005 = "TRD_GRP_005"
    TRD_GRP_006 = "TRD_GRP_006"
    TRD_GRP_007 = "TRD_GRP_007"
    TRD_GRP_008 = "TRD_GRP_008"
    TRD_GRP_009 = "TRD_GRP_009"
    TRD_GRP_010 = "TRD_GRP_010"
    TRD_GRP_011 = "TRD_GRP_011"
    TRD_GRP_012 = "TRD_GRP_012"
    TRD_GRP_013 = "TRD_GRP_013"
    TRD_GRP_014 = "TRD_GRP_014"
    TRD_GRP_015 = "TRD_GRP_015"
    TRD_GRP_016 = "TRD_GRP_016"
    TRD_GRP_017 = "TRD_GRP_017"
    TRD_GRP_018 = "TRD_GRP_018"
    TRD_GRP_019 = "TRD_GRP_019"
    TRD_GRP_020 = "TRD_GRP_020"
    TRD_GRP_021 = "TRD_GRP_021"
    TRD_GRP_022 = "TRD_GRP_022"
    TRD_GRP_023 = "TRD_GRP_023"
    TRD_GRP_024 = "TRD_GRP_024"
    TRD_GRP_025 = "TRD_GRP_025"
    TRD_GRP_026 = "TRD_GRP_026"
    TRD_GRP_027 = "TRD_GRP_027"
    TRD_GRP_028 = "TRD_GRP_028"
    TRD_GRP_029 = "TRD_GRP_029"
    TRD_GRP_030 = "TRD_GRP_030"
    TRD_GRP_031 = "TRD_GRP_031"
    TRD_GRP_032 = "TRD_GRP_032"
@unique
class BinanceSpotSymbolStatus(Enum):
    """
    Represents a Binance Spot/Margin symbol status.
    """
    PRE_TRADING = "PRE_TRADING"
    TRADING = "TRADING"
    POST_TRADING = "POST_TRADING"
    END_OF_DAY = "END_OF_DAY"
    HALT = "HALT"
    AUCTION_MATCH = "AUCTION_MATCH"
    BREAK = "BREAK"
@unique
class BinanceSpotEventType(Enum):
    """
    Represents a Binance Spot/Margin event type.
    """
    outboundAccountPosition = "outboundAccountPosition"
    balanceUpdate = "balanceUpdate"
    executionReport = "executionReport"
    listStatus = "listStatus"
class BinanceSpotEnumParser(BinanceEnumParser):
    """
    Provides parsing methods for enums used by the 'Binance Spot/Margin' exchange.
    """
    def __init__(self) -> None:
        super().__init__()
        # Spot specific order type conversion
        self.spot_ext_to_int_order_type = {
            BinanceOrderType.LIMIT: OrderType.LIMIT,
            BinanceOrderType.MARKET: OrderType.MARKET,
            BinanceOrderType.STOP: OrderType.STOP_MARKET,
            BinanceOrderType.STOP_LOSS: OrderType.STOP_MARKET,
            BinanceOrderType.STOP_LOSS_LIMIT: OrderType.STOP_LIMIT,
            BinanceOrderType.TAKE_PROFIT: OrderType.LIMIT,
            BinanceOrderType.TAKE_PROFIT_LIMIT: OrderType.STOP_LIMIT,
            BinanceOrderType.LIMIT_MAKER: OrderType.LIMIT,
        }
        self.spot_valid_time_in_force = {
            TimeInForce.GTC,
            TimeInForce.GTD,  # Will be transformed to GTC with warning
            TimeInForce.FOK,
            TimeInForce.IOC,
        }
        self.spot_valid_order_types = {
            OrderType.MARKET,
            OrderType.LIMIT,
            OrderType.LIMIT_IF_TOUCHED,
            OrderType.STOP_LIMIT,
        }
    def parse_binance_order_type(self, order_type: BinanceOrderType) -> OrderType:
        try:
            return self.spot_ext_to_int_order_type[order_type]
        except KeyError:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"unrecognized Binance Spot/Margin order type, was {order_type}",  # pragma: no cover
            )
    def parse_internal_order_type(self, order: Order) -> BinanceOrderType:
        if order.order_type == OrderType.MARKET:
            return BinanceOrderType.MARKET
        elif order.order_type == OrderType.LIMIT:
            if order.is_post_only:
                return BinanceOrderType.LIMIT_MAKER
            else:
                return BinanceOrderType.LIMIT
        elif order.order_type == OrderType.STOP_LIMIT:
            return BinanceOrderType.STOP_LOSS_LIMIT
        elif order.order_type == OrderType.LIMIT_IF_TOUCHED:
            return BinanceOrderType.TAKE_PROFIT_LIMIT
        else:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"invalid or unsupported `OrderType`, was {order_type_to_str(order.order_type)}",  # pragma: no cover
            )
</document_content>
</document>
<document index="1774">
<source>nautilus_trader/adapters/binance/spot/execution.py</source>
<document_content>

import asyncio
import msgspec
class BinanceSpotExecutionClient(BinanceCommonExecutionClient):
    """
    Provides an execution client for the Binance Spot/Margin exchange.
    Parameters
    ----------
    loop : asyncio.AbstractEventLoop
        The event loop for the client.
    client : BinanceHttpClient
        The binance HTTP client.
    msgbus : MessageBus
        The message bus for the client.
    cache : Cache
        The cache for the client.
    clock : LiveClock
        The clock for the client.
    instrument_provider : BinanceSpotInstrumentProvider
        The instrument provider.
    base_url_ws : str
        The base URL for the WebSocket client.
    config : BinanceExecClientConfig
        The configuration for the client.
    account_type : BinanceAccountType, default 'SPOT'
        The account type for the client.
    name : str, optional
        The custom client ID.
    """
    def __init__(
        self,
        loop: asyncio.AbstractEventLoop,
        client: BinanceHttpClient,
        msgbus: MessageBus,
        cache: Cache,
        clock: LiveClock,
        instrument_provider: BinanceSpotInstrumentProvider,
        base_url_ws: str,
        config: BinanceExecClientConfig,
        account_type: BinanceAccountType = BinanceAccountType.SPOT,
        name: str | None = None,
    ) -> None:
        PyCondition.is_true(
            account_type.is_spot_or_margin,
            "account_type was not SPOT, MARGIN or ISOLATED_MARGIN",
        )
        # Spot HTTP API
        self._spot_http_account = BinanceSpotAccountHttpAPI(client, clock, account_type)
        self._spot_http_market = BinanceSpotMarketHttpAPI(client, account_type)
        self._spot_http_user = BinanceSpotUserDataHttpAPI(client, account_type)
        # Spot enum parser
        self._spot_enum_parser = BinanceSpotEnumParser()
        # Instantiate common base class
        super().__init__(
            loop=loop,
            client=client,
            account=self._spot_http_account,
            market=self._spot_http_market,
            user=self._spot_http_user,
            enum_parser=self._spot_enum_parser,
            msgbus=msgbus,
            cache=cache,
            clock=clock,
            instrument_provider=instrument_provider,
            account_type=account_type,
            base_url_ws=base_url_ws,
            name=name,
            config=config,
        )
        # Register spot websocket user data event handlers
        self._spot_user_ws_handlers = {
            BinanceSpotEventType.outboundAccountPosition: self._handle_account_update,
            BinanceSpotEventType.executionReport: self._handle_execution_report,
            BinanceSpotEventType.listStatus: self._handle_list_status,
            BinanceSpotEventType.balanceUpdate: self._handle_balance_update,
        }
        # Websocket spot schema decoders
        self._decoder_spot_user_msg_wrapper = msgspec.json.Decoder(BinanceSpotUserMsgWrapper)
        self._decoder_spot_order_update_wrapper = msgspec.json.Decoder(
            BinanceSpotOrderUpdateWrapper,
        )
        self._decoder_spot_account_update_wrapper = msgspec.json.Decoder(
            BinanceSpotAccountUpdateWrapper,
        )
    async def _update_account_state(self) -> None:
        account_info: BinanceSpotAccountInfo = (
            await self._spot_http_account.query_spot_account_info(
                recv_window=str(5000),
            )
        )
        if account_info.canTrade:
            self._log.info("Binance API key authenticated.", LogColor.GREEN)
            self._log.info(f"API key {self._http_client.api_key} has trading permissions")
        else:
            self._log.error("Binance API key does not have trading permissions")
        self.generate_account_state(
            balances=account_info.parse_to_account_balances(),
            margins=[],
            reported=True,
            ts_event=millis_to_nanos(account_info.updateTime),
        )
    async def _init_dual_side_position(self) -> None:
        self._is_dual_side_position = False
        self._log.info(f"Dual side position: {self._is_dual_side_position}", LogColor.BLUE)
    # -- EXECUTION REPORTS ------------------------------------------------------------------------
    async def _get_binance_position_status_reports(
        self,
        symbol: str | None = None,
    ) -> list[PositionStatusReport]:
        # Never cash positions
        return []
    async def _get_binance_active_position_symbols(
        self,
        symbol: str | None = None,
    ) -> set[str]:
        # Never cash positions
        return set()
    # -- COMMAND HANDLERS -------------------------------------------------------------------------
    def _check_order_validity(self, order: Order) -> str | None:
        # Check order type valid
        if order.order_type not in self._spot_enum_parser.spot_valid_order_types:
            valid_types = [
                order_type_to_str(t) for t in self._spot_enum_parser.spot_valid_order_types
            ]
            return (
                f"UNSUPPORTED_ORDER_TYPE: {order_type_to_str(order.order_type)} "
                f"not supported for SPOT/MARGIN accounts (valid: {valid_types})"
            )
        # Check time in force valid
        if order.time_in_force not in self._spot_enum_parser.spot_valid_time_in_force:
            valid_tifs = [
                time_in_force_to_str(t) for t in self._spot_enum_parser.spot_valid_time_in_force
            ]
            return (
                f"UNSUPPORTED_TIME_IN_FORCE: {time_in_force_to_str(order.time_in_force)} "
                f"not supported for SPOT/MARGIN accounts (valid: {valid_tifs})"
            )
        # Check post-only
        if order.order_type == OrderType.STOP_LIMIT and order.is_post_only:
            return (
                "UNSUPPORTED_POST_ONLY: STOP_LIMIT post_only orders not supported for SPOT/MARGIN "
                "accounts (order may become a liquidity TAKER)"
            )
        return None
    async def _batch_cancel_orders(self, command: BatchCancelOrders) -> None:
        self._log.warning(
            "Batch cancel orders not supported by Binance Spot/Margin exchange, "
            f"falling back to individual cancellation of {len(command.cancels)} orders",
        )
        # Fallback to individual order cancellation
        successful_cancels = 0
        for cancel_command in command.cancels:
            try:
                await self._cancel_order(cancel_command)
                successful_cancels += 1
            except Exception as e:
                self._log.error(
                    f"Failed to cancel individual order {cancel_command.client_order_id}: {e}",
                )
                self.generate_order_cancel_rejected(
                    cancel_command.strategy_id,
                    cancel_command.instrument_id,
                    cancel_command.client_order_id,
                    cancel_command.venue_order_id,
                    f"Individual cancel fallback failed: {e}",
                    self._clock.timestamp_ns(),
                )
        self._log.info(
            f"Batch cancel fallback completed: {successful_cancels}/{len(command.cancels)} orders cancelled",
        )
    # -- WEBSOCKET EVENT HANDLERS --------------------------------------------------------------------
    def _handle_user_ws_message(self, raw: bytes) -> None:
        try:
            wrapper = self._decoder_spot_user_msg_wrapper.decode(raw)
            self._spot_user_ws_handlers[wrapper.data.e](raw)
        except Exception as e:
            self._log.exception(f"Error on handling {raw!r}", e)
    def _handle_account_update(self, raw: bytes) -> None:
        account_msg = self._decoder_spot_account_update_wrapper.decode(raw)
        account_msg.data.handle_account_update(self)
    def _handle_execution_report(self, raw: bytes) -> None:
        order_msg = self._decoder_spot_order_update_wrapper.decode(raw)
        order_msg.data.handle_execution_report(self)
    def _handle_list_status(self, raw: bytes) -> None:
        self._log.warning("List status (OCO) received")  # Implement
    def _handle_balance_update(self, raw: bytes) -> None:
        self.create_task(self._update_account_state())
</document_content>
</document>
<document index="1775">
<source>nautilus_trader/adapters/binance/spot/http/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="1776">
<source>nautilus_trader/adapters/binance/spot/http/account.py</source>
<document_content>

from typing import Any
import msgspec
class BinanceSpotOpenOrdersHttp(BinanceOpenOrdersHttp):
    """
    Endpoint of all SPOT/MARGIN open orders on a symbol.
    `GET /api/v3/openOrders` (inherited)
    `DELETE /api/v3/openOrders`
    Warnings
    --------
    Care should be taken when accessing this endpoint with no symbol specified.
    The weight usage can be very large, which may cause rate limits to be hit.
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#current-open-orders-user_data
    https://binance-docs.github.io/apidocs/spot/en/#cancel-all-open-orders-on-a-symbol-trade
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.USER_DATA,
            HttpMethod.DELETE: BinanceSecurityType.TRADE,
        }
        super().__init__(
            client,
            base_endpoint,
            methods,
        )
        self._delete_resp_decoder = msgspec.json.Decoder()
    class DeleteParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Parameters of openOrders SPOT/MARGIN DELETE request. Includes OCO orders.
        Parameters
        ----------
        timestamp : str
            The millisecond timestamp of the request
        symbol : BinanceSymbol
            The symbol of the orders
        recvWindow : str, optional
            The response receive window for the request (cannot be greater than 60000).
        """
        timestamp: str
        symbol: BinanceSymbol
        recvWindow: str | None = None
    async def _delete(self, params: DeleteParameters) -> list[dict[str, Any]]:
        method_type = HttpMethod.DELETE
        raw = await self._method(method_type, params)
        return self._delete_resp_decoder.decode(raw)
class BinanceSpotOrderOcoHttp(BinanceHttpEndpoint):
    """
    Endpoint for creating SPOT/MARGIN OCO orders.
    `POST /api/v3/order/oco`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#new-oco-trade
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.POST: BinanceSecurityType.TRADE,
        }
        url_path = base_endpoint + "order/oco"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._resp_decoder = msgspec.json.Decoder(BinanceSpotOrderOco)
    class PostParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        OCO order creation POST endpoint parameters.
        Parameters
        ----------
        symbol : BinanceSymbol
            The symbol of the order.
        timestamp : str
            The millisecond timestamp of the request.
        side : BinanceOrderSide
            The market side of the order (BUY, SELL).
        quantity : str
            The order quantity in base asset units for the request.
        price : str
            The order price for the request.
        stopPrice : str
            The order stop price for the request.
        listClientOrderId : str, optional
            A unique Id for the entire orderList
        limitClientOrderId : str, optional
            The client order ID for the limit request. A unique ID among open orders.
            Automatically generated if not provided.
        limitStrategyId : int,  optional
            The client strategy ID for the limit request.
        limitStrategyType : int, optional
            The client strategy type for the limit request. Cannot be less than 1000000
        limitIcebergQty : str, optional
            Create a limit iceberg order.
        trailingDelta : str, optional
            Can be used in addition to stopPrice.
            The order trailing delta of the request.
        stopClientOrderId : str, optional
            The client order ID for the stop request. A unique ID among open orders.
            Automatically generated if not provided.
        stopStrategyId : int,  optional
            The client strategy ID for the stop request.
        stopStrategyType : int, optional
            The client strategy type for the stop request. Cannot be less than 1000000.
        stopLimitPrice : str, optional
            Limit price for the stop order request.
            If provided, stopLimitTimeInForce is required.
        stopIcebergQty : str, optional
            Create a stop iceberg order.
        stopLimitTimeInForce : BinanceTimeInForce, optional
            The time in force of the stop limit order.
            Valid values: (GTC, FOK, IOC).
        newOrderRespType : BinanceNewOrderRespType, optional
            The response type for the order request.
        recvWindow : str, optional
            The response receive window in milliseconds for the request.
            Cannot exceed 60000.
        """
        symbol: BinanceSymbol
        timestamp: str
        side: BinanceOrderSide
        quantity: str
        price: str
        stopPrice: str
        listClientOrderId: str | None = None
        limitClientOrderId: str | None = None
        limitStrategyId: int | None = None
        limitStrategyType: int | None = None
        limitIcebergQty: str | None = None
        trailingDelta: str | None = None
        stopClientOrderId: str | None = None
        stopStrategyId: int | None = None
        stopStrategyType: int | None = None
        stopLimitPrice: str | None = None
        stopIcebergQty: str | None = None
        stopLimitTimeInForce: BinanceTimeInForce | None = None
        newOrderRespType: BinanceNewOrderRespType | None = None
        recvWindow: str | None = None
    async def _post(self, params: PostParameters) -> BinanceSpotOrderOco:
        method_type = HttpMethod.POST
        raw = await self._method(method_type, params)
        return self._resp_decoder.decode(raw)
class BinanceSpotOrderListHttp(BinanceHttpEndpoint):
    """
    Endpoint for querying and deleting SPOT/MARGIN OCO orders.
    `GET /api/v3/orderList`
    `DELETE /api/v3/orderList`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#query-oco-user_data
    https://binance-docs.github.io/apidocs/spot/en/#cancel-oco-trade
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.USER_DATA,
            HttpMethod.DELETE: BinanceSecurityType.TRADE,
        }
        url_path = base_endpoint + "orderList"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._resp_decoder = msgspec.json.Decoder(BinanceSpotOrderOco)
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        OrderList (OCO) GET endpoint parameters.
        Parameters
        ----------
        timestamp : str
            The millisecond timestamp of the request.
        orderListId : str, optional
            The unique identifier of the order list to retrieve.
        origClientOrderId : str, optional
            The client specified identifier of the order list to retrieve.
        recvWindow : str, optional
            The response receive window in milliseconds for the request.
            Cannot exceed 60000.
        NOTE: Either orderListId or origClientOrderId must be provided.
        """
        timestamp: str
        orderListId: str | None = None
        origClientOrderId: str | None = None
        recvWindow: str | None = None
    class DeleteParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        OrderList (OCO) DELETE endpoint parameters.
        Parameters
        ----------
        timestamp : str
            The millisecond timestamp of the request.
        symbol : BinanceSymbol
            The symbol of the order.
        orderListId : str, optional
            The unique identifier of the order list to retrieve.
        listClientOrderId : str, optional
            The client specified identifier of the order list to retrieve.
        newClientOrderId : str, optional
            Used to uniquely identify this cancel. Automatically generated
            by default.
        recvWindow : str, optional
            The response receive window in milliseconds for the request.
            Cannot exceed 60000.
        NOTE: Either orderListId or listClientOrderId must be provided.
        """
        timestamp: str
        symbol: BinanceSymbol
        orderListId: str | None = None
        listClientOrderId: str | None = None
        newClientOrderId: str | None = None
        recvWindow: str | None = None
    async def get(self, params: GetParameters) -> BinanceSpotOrderOco:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._resp_decoder.decode(raw)
    async def delete(self, params: DeleteParameters) -> BinanceSpotOrderOco:
        method_type = HttpMethod.DELETE
        raw = await self._method(method_type, params)
        return self._resp_decoder.decode(raw)
class BinanceSpotAllOrderListHttp(BinanceHttpEndpoint):
    """
    Endpoint for querying all SPOT/MARGIN OCO orders.
    `GET /api/v3/allOrderList`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#query-all-oco-user_data
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.USER_DATA,
        }
        url_path = base_endpoint + "allOrderList"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._resp_decoder = msgspec.json.Decoder(list[BinanceSpotOrderOco])
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Parameters of allOrderList GET request.
        Parameters
        ----------
        timestamp : str
            The millisecond timestamp of the request.
        fromId : int, optional
            The order ID for the request.
            If included, request will return orders from this orderId INCLUSIVE.
        startTime : int, optional
            The start time (UNIX milliseconds) filter for the request.
        endTime : int, optional
            The end time (UNIX milliseconds) filter for the request.
        limit : int, optional
            The limit for the response.
            Default 500, max 1000
        recvWindow : str, optional
            The response receive window for the request (cannot be greater than 60000).
        Warnings
        --------
        If fromId is specified, neither startTime endTime can be provided.
        """
        timestamp: str
        fromId: int | None = None
        startTime: int | None = None
        endTime: int | None = None
        limit: int | None = None
        recvWindow: str | None = None
    async def get(self, params: GetParameters) -> list[BinanceSpotOrderOco]:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._resp_decoder.decode(raw)
class BinanceSpotOpenOrderListHttp(BinanceHttpEndpoint):
    """
    Endpoint for querying all SPOT/MARGIN OPEN OCO orders.
    `GET /api/v3/openOrderList`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#query-open-oco-user_data
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.USER_DATA,
        }
        url_path = base_endpoint + "openOrderList"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._resp_decoder = msgspec.json.Decoder(list[BinanceSpotOrderOco])
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Parameters of allOrderList GET request.
        Parameters
        ----------
        timestamp : str
            The millisecond timestamp of the request.
        recvWindow : str, optional
            The response receive window for the request (cannot be greater than 60000).
        """
        timestamp: str
        recvWindow: str | None = None
    async def get(self, params: GetParameters) -> list[BinanceSpotOrderOco]:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._resp_decoder.decode(raw)
class BinanceSpotAccountHttp(BinanceHttpEndpoint):
    """
    Endpoint of current SPOT/MARGIN account information.
    `GET /api/v3/account`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#account-information-user_data
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.USER_DATA,
        }
        url_path = base_endpoint + "account"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._resp_decoder = msgspec.json.Decoder(BinanceSpotAccountInfo)
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Parameters of account GET request.
        Parameters
        ----------
        timestamp : str
            The millisecond timestamp of the request.
        recvWindow : str, optional
            The response receive window for the request (cannot be greater than 60000).
        """
        timestamp: str
        recvWindow: str | None = None
    async def get(self, params: GetParameters) -> BinanceSpotAccountInfo:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._resp_decoder.decode(raw)
class BinanceSpotOrderRateLimitHttp(BinanceHttpEndpoint):
    """
    Endpoint of current SPOT/MARGIN order count usage for all intervals.
    `GET /api/v3/rateLimit/order`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#query-current-order-count-usage-trade
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.TRADE,
        }
        url_path = base_endpoint + "rateLimit/order"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._resp_decoder = msgspec.json.Decoder(list[BinanceRateLimit])
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        Parameters of rateLimit/order GET request.
        Parameters
        ----------
        timestamp : str
            The millisecond timestamp of the request.
        recvWindow : str, optional
            The response receive window for the request (cannot be greater than 60000).
        """
        timestamp: str
        recvWindow: str | None = None
    async def get(self, params: GetParameters) -> list[BinanceRateLimit]:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._resp_decoder.decode(raw)
class BinanceSpotAccountHttpAPI(BinanceAccountHttpAPI):
    """
    Provides access to the Binance Spot/Margin Account/Trade HTTP REST API.
    Parameters
    ----------
    client : BinanceHttpClient
        The Binance REST API client.
    clock : LiveClock,
        The clock for the API client.
    account_type : BinanceAccountType
        The Binance account type, used to select the endpoint prefix.
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        clock: LiveClock,
        account_type: BinanceAccountType = BinanceAccountType.SPOT,
    ):
        super().__init__(
            client=client,
            clock=clock,
            account_type=account_type,
        )
        if not account_type.is_spot_or_margin:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"`BinanceAccountType` not SPOT, MARGIN or ISOLATED_MARGIN, was {account_type}",  # pragma: no cover
            )
        # Create endpoints
        self._endpoint_spot_open_orders = BinanceSpotOpenOrdersHttp(client, self.base_endpoint)
        self._endpoint_spot_order_oco = BinanceSpotOrderOcoHttp(client, self.base_endpoint)
        self._endpoint_spot_order_list = BinanceSpotOrderListHttp(client, self.base_endpoint)
        self._endpoint_spot_all_order_list = BinanceSpotAllOrderListHttp(client, self.base_endpoint)
        self._endpoint_spot_open_order_list = BinanceSpotOpenOrderListHttp(
            client,
            self.base_endpoint,
        )
        self._endpoint_spot_account = BinanceSpotAccountHttp(client, self.base_endpoint)
        self._endpoint_spot_order_rate_limit = BinanceSpotOrderRateLimitHttp(
            client,
            self.base_endpoint,
        )
    async def new_spot_oco(
        self,
        symbol: str,
        side: BinanceOrderSide,
        quantity: str,
        price: str,
        stop_price: str,
        list_client_order_id: str | None = None,
        limit_client_order_id: str | None = None,
        limit_strategy_id: int | None = None,
        limit_strategy_type: int | None = None,
        limit_iceberg_qty: str | None = None,
        trailing_delta: str | None = None,
        stop_client_order_id: str | None = None,
        stop_strategy_id: int | None = None,
        stop_strategy_type: int | None = None,
        stop_limit_price: str | None = None,
        stop_iceberg_qty: str | None = None,
        stop_limit_time_in_force: BinanceTimeInForce | None = None,
        new_order_resp_type: BinanceNewOrderRespType | None = None,
        recv_window: str | None = None,
    ) -> BinanceSpotOrderOco:
        """
        Send in a new spot OCO order to Binance.
        """
        if stop_limit_price is not None and stop_limit_time_in_force is None:
            raise RuntimeError(
                "stopLimitPrice cannot be provided without stopLimitTimeInForce.",
            )
        if stop_limit_time_in_force == BinanceTimeInForce.GTX:
            raise RuntimeError(
                "stopLimitTimeInForce, Good Till Crossing (GTX) not supported.",
            )
        return await self._endpoint_spot_order_oco._post(
            params=self._endpoint_spot_order_oco.PostParameters(
                symbol=BinanceSymbol(symbol),
                timestamp=self._timestamp(),
                side=side,
                quantity=quantity,
                price=price,
                stopPrice=stop_price,
                listClientOrderId=list_client_order_id,
                limitClientOrderId=limit_client_order_id,
                limitStrategyId=limit_strategy_id,
                limitStrategyType=limit_strategy_type,
                limitIcebergQty=limit_iceberg_qty,
                trailingDelta=trailing_delta,
                stopClientOrderId=stop_client_order_id,
                stopStrategyId=stop_strategy_id,
                stopStrategyType=stop_strategy_type,
                stopLimitPrice=stop_limit_price,
                stopIcebergQty=stop_iceberg_qty,
                stopLimitTimeInForce=stop_limit_time_in_force,
                newOrderRespType=new_order_resp_type,
                recvWindow=recv_window,
            ),
        )
    async def query_spot_oco(
        self,
        order_list_id: str | None = None,
        orig_client_order_id: str | None = None,
        recv_window: str | None = None,
    ) -> BinanceSpotOrderOco:
        """
        Check single spot OCO order information.
        """
        if order_list_id is None and orig_client_order_id is None:
            raise RuntimeError(
                "Either orderListId or origClientOrderId must be provided.",
            )
        return await self._endpoint_spot_order_list.get(
            params=self._endpoint_spot_order_list.GetParameters(
                timestamp=self._timestamp(),
                orderListId=order_list_id,
                origClientOrderId=orig_client_order_id,
                recvWindow=recv_window,
            ),
        )
    async def cancel_all_open_orders(
        self,
        symbol: str,
        recv_window: str | None = None,
    ) -> bool:
        """
        Cancel all active orders on a symbol, including OCO.
        Returns whether successful.
        """
        await self._endpoint_spot_open_orders._delete(
            params=self._endpoint_spot_open_orders.DeleteParameters(
                timestamp=self._timestamp(),
                symbol=BinanceSymbol(symbol),
                recvWindow=recv_window,
            ),
        )
        return True
    async def cancel_spot_oco(
        self,
        symbol: str,
        order_list_id: str | None = None,
        list_client_order_id: str | None = None,
        new_client_order_id: str | None = None,
        recv_window: str | None = None,
    ) -> BinanceSpotOrderOco:
        """
        Delete spot OCO order from Binance.
        """
        if order_list_id is None and list_client_order_id is None:
            raise RuntimeError(
                "Either orderListId or listClientOrderId must be provided.",
            )
        return await self._endpoint_spot_order_list.delete(
            params=self._endpoint_spot_order_list.DeleteParameters(
                timestamp=self._timestamp(),
                symbol=BinanceSymbol(symbol),
                orderListId=order_list_id,
                listClientOrderId=list_client_order_id,
                newClientOrderId=new_client_order_id,
                recvWindow=recv_window,
            ),
        )
    async def query_spot_all_oco(
        self,
        from_id: int | None = None,
        start_time: int | None = None,
        end_time: int | None = None,
        limit: int | None = None,
        recv_window: str | None = None,
    ) -> list[BinanceSpotOrderOco]:
        """
        Check all spot OCO orders' information, matching provided filter parameters.
        """
        if from_id is not None and (start_time or end_time) is not None:
            raise RuntimeError(
                "Cannot specify both fromId and a startTime/endTime.",
            )
        return await self._endpoint_spot_all_order_list.get(
            params=self._endpoint_spot_all_order_list.GetParameters(
                timestamp=self._timestamp(),
                fromId=from_id,
                startTime=start_time,
                endTime=end_time,
                limit=limit,
                recvWindow=recv_window,
            ),
        )
    async def query_spot_all_open_oco(
        self,
        recv_window: str | None = None,
    ) -> list[BinanceSpotOrderOco]:
        """
        Check all OPEN spot OCO orders' information.
        """
        return await self._endpoint_spot_open_order_list.get(
            params=self._endpoint_spot_open_order_list.GetParameters(
                timestamp=self._timestamp(),
                recvWindow=recv_window,
            ),
        )
    async def query_spot_account_info(
        self,
        recv_window: str | None = None,
    ) -> BinanceSpotAccountInfo:
        """
        Check SPOT/MARGIN Binance account information.
        """
        return await self._endpoint_spot_account.get(
            params=self._endpoint_spot_account.GetParameters(
                timestamp=self._timestamp(),
                recvWindow=recv_window,
            ),
        )
    async def query_spot_order_rate_limit(
        self,
        recv_window: str | None = None,
    ) -> list[BinanceRateLimit]:
        """
        Check SPOT/MARGIN order count/rateLimit.
        """
        return await self._endpoint_spot_order_rate_limit.get(
            params=self._endpoint_spot_order_rate_limit.GetParameters(
                timestamp=self._timestamp(),
                recvWindow=recv_window,
            ),
        )
</document_content>
</document>
<document index="1777">
<source>nautilus_trader/adapters/binance/spot/http/market.py</source>
<document_content>

import msgspec
class BinanceSpotExchangeInfoHttp(BinanceHttpEndpoint):
    """
    Endpoint of SPOT/MARGIN exchange trading rules and symbol information.
    `GET /api/v3/exchangeInfo`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#exchange-information
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.NONE,
        }
        url_path = base_endpoint + "exchangeInfo"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_resp_decoder = msgspec.json.Decoder(BinanceSpotExchangeInfo)
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        GET exchangeInfo parameters.
        Parameters
        ----------
        symbol : BinanceSymbol, optional
            The specify trading pair to get exchange info for.
        symbols : BinanceSymbols, optional
            The specify list of trading pairs to get exchange info for.
        permissions : BinanceSpotPermissions, optional
            The filter symbols list by supported permissions.
        """
        symbol: BinanceSymbol | None = None
        symbols: BinanceSymbols | None = None
        permissions: BinanceSpotPermissions | None = None
    async def get(self, params: GetParameters | None = None) -> BinanceSpotExchangeInfo:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._get_resp_decoder.decode(raw)
class BinanceSpotAvgPriceHttp(BinanceHttpEndpoint):
    """
    Endpoint of current average price of a symbol.
    `GET /api/v3/avgPrice`
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#current-average-price
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.NONE,
        }
        url_path = base_endpoint + "avgPrice"
        super().__init__(
            client,
            methods,
            url_path,
        )
        self._get_resp_decoder = msgspec.json.Decoder(BinanceSpotAvgPrice)
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        GET avgPrice parameters.
        Parameters
        ----------
        symbol : BinanceSymbol
            Specify trading pair to get average price for.
        """
        symbol: BinanceSymbol = None
    async def get(self, params: GetParameters) -> BinanceSpotAvgPrice:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._get_resp_decoder.decode(raw)
class BinanceSpotMarketHttpAPI(BinanceMarketHttpAPI):
    """
    Provides access to the Binance Spot Market HTTP REST API.
    Parameters
    ----------
    client : BinanceHttpClient
        The Binance REST API client.
    account_type : BinanceAccountType
        The Binance account type, used to select the endpoint.
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        account_type: BinanceAccountType = BinanceAccountType.SPOT,
    ):
        super().__init__(
            client=client,
            account_type=account_type,
        )
        if not account_type.is_spot_or_margin:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"`BinanceAccountType` not SPOT, MARGIN or ISOLATED_MARGIN, was {account_type}",  # pragma: no cover
            )
        self._endpoint_spot_exchange_info = BinanceSpotExchangeInfoHttp(client, self.base_endpoint)
        self._endpoint_spot_average_price = BinanceSpotAvgPriceHttp(client, self.base_endpoint)
    async def query_spot_exchange_info(
        self,
        symbol: str | None = None,
        symbols: list[str] | None = None,
        permissions: BinanceSpotPermissions | None = None,
    ) -> BinanceSpotExchangeInfo:
        """
        Check Binance Spot exchange information.
        """
        if symbol and symbols:
            raise ValueError("`symbol` and `symbols` cannot be sent together")
        return await self._endpoint_spot_exchange_info.get(
            params=self._endpoint_spot_exchange_info.GetParameters(
                symbol=BinanceSymbol(symbol) if symbol else None,
                symbols=BinanceSymbols(symbols) if symbols else None,
                permissions=permissions,
            ),
        )
    async def query_spot_average_price(self, symbol: str) -> BinanceSpotAvgPrice:
        """
        Check average price for a provided symbol on the Spot exchange.
        """
        return await self._endpoint_spot_average_price.get(
            params=self._endpoint_spot_average_price.GetParameters(
                symbol=BinanceSymbol(symbol),
            ),
        )
</document_content>
</document>
<document index="1778">
<source>nautilus_trader/adapters/binance/spot/http/user.py</source>
<document_content>

class BinanceSpotUserDataHttpAPI(BinanceUserDataHttpAPI):
    """
    Provides access to the Binance Spot/Margin User Data HTTP REST API.
    Parameters
    ----------
    client : BinanceHttpClient
        The Binance REST API client.
    account_type : BinanceAccountType
        The Binance account type, used to select the endpoint.
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        account_type: BinanceAccountType = BinanceAccountType.SPOT,
    ):
        super().__init__(
            client=client,
            account_type=account_type,
        )
        if not account_type.is_spot_or_margin:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"`BinanceAccountType` not SPOT, MARGIN or ISOLATED_MARGIN, was {account_type}",  # pragma: no cover (design-time error)
            )
</document_content>
</document>
<document index="1779">
<source>nautilus_trader/adapters/binance/spot/http/wallet.py</source>
<document_content>

import msgspec
class BinanceSpotTradeFeeHttp(BinanceHttpEndpoint):
    """
    Endpoint of maker/taker trade fee information.
    `GET /sapi/v1/asset/tradeFee` (Binance.com)
    `GET /sapi/v1/asset/query/trading-fee` (Binance.US)
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#trade-fee-user_data
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        base_endpoint: str,
    ):
        methods = {
            HttpMethod.GET: BinanceSecurityType.USER_DATA,
        }
        # Check if Binance.US based on base URL
        if ".us" in client.base_url:
            endpoint_path = base_endpoint + "query/trading-fee"
        else:
            endpoint_path = base_endpoint + "tradeFee"
        super().__init__(
            client,
            methods,
            endpoint_path,
        )
        self._get_arr_resp_decoder = msgspec.json.Decoder(list[BinanceSpotTradeFee])
    class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
        """
        GET parameters for requesting trade fees.
        Parameters
        ----------
        symbol : BinanceSymbol
            Optional symbol to receive individual trade fee
        recvWindow : str
            Optional number of milliseconds after timestamp the request is valid
        timestamp : str
            Millisecond timestamp of the request
        """
        timestamp: str
        symbol: BinanceSymbol | None = None
        recvWindow: str | None = None
    async def get(self, params: GetParameters) -> list[BinanceSpotTradeFee]:
        method_type = HttpMethod.GET
        raw = await self._method(method_type, params)
        return self._get_arr_resp_decoder.decode(raw)
class BinanceSpotWalletHttpAPI:
    """
    Provides access to the Binance Spot/Margin Wallet HTTP REST API.
    Parameters
    ----------
    client : BinanceHttpClient
        The Binance REST API client.
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        clock: LiveClock,
        account_type: BinanceAccountType = BinanceAccountType.SPOT,
    ):
        self.client = client
        self._clock = clock
        self.base_endpoint = "/sapi/v1/asset/"
        if not account_type.is_spot_or_margin:
            raise RuntimeError(  # pragma: no cover (design-time error)
                f"`BinanceAccountType` not SPOT, MARGIN or ISOLATED_MARGIN, was {account_type}",  # pragma: no cover
            )
        self._endpoint_spot_trade_fee = BinanceSpotTradeFeeHttp(client, self.base_endpoint)
    def _timestamp(self) -> str:
        """
        Create Binance timestamp from internal clock.
        """
        return str(self._clock.timestamp_ms())
    async def query_spot_trade_fees(
        self,
        symbol: str | None = None,
        recv_window: str | None = None,
    ) -> list[BinanceSpotTradeFee]:
        fees = await self._endpoint_spot_trade_fee.get(
            params=self._endpoint_spot_trade_fee.GetParameters(
                timestamp=self._timestamp(),
                symbol=BinanceSymbol(symbol) if symbol is not None else None,
                recvWindow=recv_window,
            ),
        )
        return fees
</document_content>
</document>
<document index="1780">
<source>nautilus_trader/adapters/binance/spot/providers.py</source>
<document_content>

from decimal import Decimal
from enum import Enum
from typing import Any
import msgspec
def _symbol_info_to_dict(symbol_info: BinanceSpotSymbolInfo) -> dict:
    """
    Convert symbol info to dict with all enums and nested structs converted to
    primitives.
    This ensures the info dict contains only JSON-serializable primitives.
    """
    def _convert_value(value: Any) -> Any:
        # Recursively convert enums and structs to primitives
        if isinstance(value, Enum):
            return value.value
        elif hasattr(value, "__struct_fields__"):
            return _convert_dict(msgspec.structs.asdict(value))
        elif isinstance(value, list):
            return [_convert_value(item) for item in value]
        elif isinstance(value, dict):
            return _convert_dict(value)
        return value
    def _convert_dict(d: dict) -> dict:
        return {key: _convert_value(val) for key, val in d.items()}
    return _convert_dict(msgspec.structs.asdict(symbol_info))
class BinanceSpotInstrumentProvider(InstrumentProvider):
    """
    Provides a means of loading instruments from the Binance Spot/Margin exchange.
    Parameters
    ----------
    client : APIClient
        The client for the provider.
    clock : LiveClock
        The clock for the provider.
    account_type : BinanceAccountType, default SPOT
        The Binance account type for the provider.
    is_testnet : bool, default False
        If the provider is for the Spot testnet.
    config : InstrumentProviderConfig, optional
        The configuration for the provider.
    """
    def __init__(
        self,
        client: BinanceHttpClient,
        clock: LiveClock,
        account_type: BinanceAccountType = BinanceAccountType.SPOT,
        is_testnet: bool = False,
        config: InstrumentProviderConfig | None = None,
        venue: Venue = BINANCE_VENUE,
    ) -> None:
        super().__init__(config=config)
        self._clock = clock
        self._client = client
        self._account_type = account_type
        self._is_testnet = is_testnet
        self._venue = venue
        self._http_wallet = BinanceSpotWalletHttpAPI(
            self._client,
            clock=self._clock,
            account_type=account_type,
        )
        self._http_market = BinanceSpotMarketHttpAPI(self._client, account_type=account_type)
        self._log_warnings = config.log_warnings if config else True
        self._decoder = msgspec.json.Decoder()
        self._encoder = msgspec.json.Encoder()
    async def load_all_async(self, filters: dict | None = None) -> None:
        filters_str = "..." if not filters else f" with filters {filters}..."
        self._log.info(f"Loading all instruments{filters_str}")
        try:
            # Get current commission rates
            if not self._is_testnet:
                response = await self._http_wallet.query_spot_trade_fees()
                fees_dict: dict[str, BinanceSpotTradeFee] = {fee.symbol: fee for fee in response}
            else:
                self._log.warning(
                    "Currently not requesting actual trade fees for the SPOT testnet; "
                    "all instruments will have zero fees",
                )
                fees_dict = {}
        except BinanceClientError as e:
            self._log.error(
                "Cannot load instruments: API key authentication failed "
                f"(this is needed to request the applicable account fee tier). {e.message}",
            )
            return
        # Get exchange info for all assets
        exchange_info = await self._http_market.query_spot_exchange_info()
        for symbol_info in exchange_info.symbols:
            self._parse_instrument(
                symbol_info=symbol_info,
                fee=fees_dict.get(symbol_info.symbol),
                ts_event=millis_to_nanos(exchange_info.serverTime),
            )
    async def load_ids_async(
        self,
        instrument_ids: list[InstrumentId],
        filters: dict | None = None,
    ) -> None:
        if not instrument_ids:
            self._log.info("No instrument IDs given for loading.")
            return
        # Check all instrument IDs
        for instrument_id in instrument_ids:
            PyCondition.equal(instrument_id.venue, self._venue, "instrument_id.venue", "BINANCE")
        try:
            # Get current commission rates
            if not self._is_testnet:
                response = await self._http_wallet.query_spot_trade_fees()
                fees_dict: dict[str, BinanceSpotTradeFee] = {fee.symbol: fee for fee in response}
            else:
                fees_dict = {}
                self._log.warning(
                    "Currently not requesting actual trade fees for the SPOT testnet; "
                    "all instruments will have zero fees.",
                )
        except BinanceClientError as e:
            self._log.error(
                "Cannot load instruments: API key authentication failed "
                f"(this is needed to request the applicable account fee tier): {e.message}",
            )
            return
        # Extract all symbol strings
        symbols = [
            str(BinanceSymbol(instrument_id.symbol.value)) for instrument_id in instrument_ids
        ]
        # Get exchange info for all assets
        exchange_info = await self._http_market.query_spot_exchange_info(symbols=symbols)
        symbol_info_dict: dict[str, BinanceSpotSymbolInfo] = {
            info.symbol: info for info in exchange_info.symbols
        }
        for symbol in symbols:
            self._parse_instrument(
                symbol_info=symbol_info_dict[symbol],
                fee=fees_dict.get(symbol),
                ts_event=millis_to_nanos(exchange_info.serverTime),
            )
    async def load_async(self, instrument_id: InstrumentId, filters: dict | None = None) -> None:
        PyCondition.not_none(instrument_id, "instrument_id")
        PyCondition.equal(instrument_id.venue, self._venue, "instrument_id.venue", "BINANCE")
        filters_str = "..." if not filters else f" with filters {filters}..."
        self._log.debug(f"Loading instrument {instrument_id}{filters_str}")
        symbol = str(BinanceSymbol(instrument_id.symbol.value))
        try:
            # Get current commission rates
            if not self._is_testnet:
                response = await self._http_wallet.query_spot_trade_fees(symbol=symbol)
                fees_dict: dict[str, BinanceSpotTradeFee] = {fee.symbol: fee for fee in response}
            else:
                self._log.warning(
                    "Currently not requesting actual trade fees for the SPOT testnet; "
                    "all instruments will have zero fees",
                )
                fees_dict = {}
        except BinanceClientError as e:
            self._log.error(
                "Cannot load instruments: API key authentication failed "
                f"(this is needed to request the applicable account fee tier): {e}",
            )
            return
        # Get exchange info for asset
        exchange_info = await self._http_market.query_spot_exchange_info(symbol=symbol)
        symbol_info_dict: dict[str, BinanceSpotSymbolInfo] = {
            info.symbol: info for info in exchange_info.symbols
        }
        self._parse_instrument(
            symbol_info=symbol_info_dict[symbol],
            fee=fees_dict.get(symbol),
            ts_event=millis_to_nanos(exchange_info.serverTime),
        )
    def _parse_instrument(
        self,
        symbol_info: BinanceSpotSymbolInfo,
        fee: BinanceSpotTradeFee | None,
        ts_event: int,
    ) -> None:
        ts_init = self._clock.timestamp_ns()
        try:
            base_currency = symbol_info.parse_to_base_asset()
            quote_currency = symbol_info.parse_to_quote_asset()
            raw_symbol = Symbol(symbol_info.symbol)
            instrument_id = InstrumentId(symbol=raw_symbol, venue=self._venue)
            # Parse instrument filters
            filters: dict[BinanceSymbolFilterType, BinanceSymbolFilter] = {
                f.filterType: f for f in symbol_info.filters
            }
            price_filter = filters[BinanceSymbolFilterType.PRICE_FILTER]
            lot_size_filter = filters[BinanceSymbolFilterType.LOT_SIZE]
            min_notional_filter = filters.get(BinanceSymbolFilterType.MIN_NOTIONAL)
            notional_filter = filters.get(BinanceSymbolFilterType.NOTIONAL)
            tick_size = price_filter.tickSize
            step_size = lot_size_filter.stepSize
            PyCondition.in_range(float(tick_size), PRICE_MIN, PRICE_MAX, "tick_size")
            PyCondition.in_range(float(step_size), QUANTITY_MIN, QUANTITY_MAX, "step_size")
            price_precision = abs(int(Decimal(tick_size).as_tuple().exponent))
            size_precision = abs(int(Decimal(step_size).as_tuple().exponent))
            price_increment = Price.from_str(tick_size)
            size_increment = Quantity.from_str(step_size)
            lot_size = Quantity.from_str(step_size)
            PyCondition.in_range(
                Decimal(lot_size_filter.maxQty),
                QUANTITY_MIN,
                QUANTITY_MAX,
                "maxQty",
            )
            PyCondition.in_range(
                Decimal(lot_size_filter.minQty),
                QUANTITY_MIN,
                QUANTITY_MAX,
                "minQty",
            )
            max_quantity = Quantity(float(lot_size_filter.maxQty), precision=size_precision)
            min_quantity = Quantity(float(lot_size_filter.minQty), precision=size_precision)
            max_notional = None
            min_notional = None
            if min_notional_filter:
                min_notional = Money(min_notional_filter.minNotional, currency=quote_currency)
            elif notional_filter:
                max_notional = Money(notional_filter.maxNotional, currency=quote_currency)
                min_notional = Money(notional_filter.minNotional, currency=quote_currency)
            max_price = Price(
                min(float(price_filter.maxPrice), 4294967296.0),
                precision=price_precision,
            )
            min_price = Price(max(float(price_filter.minPrice), 0.0), precision=price_precision)
            # Parse fees
            maker_fee: Decimal = Decimal(0)
            taker_fee: Decimal = Decimal(0)
            if fee:
                maker_fee = Decimal(fee.makerCommission)
                taker_fee = Decimal(fee.takerCommission)
            # Create instrument
            instrument = CurrencyPair(
                instrument_id=instrument_id,
                raw_symbol=raw_symbol,
                base_currency=base_currency,
                quote_currency=quote_currency,
                price_precision=price_precision,
                size_precision=size_precision,
                price_increment=price_increment,
                size_increment=size_increment,
                lot_size=lot_size,
                max_quantity=max_quantity,
                min_quantity=min_quantity,
                max_notional=max_notional,
                min_notional=min_notional,
                max_price=max_price,
                min_price=min_price,
                margin_init=Decimal(0),
                margin_maint=Decimal(0),
                maker_fee=maker_fee,
                taker_fee=taker_fee,
                ts_event=min(ts_event, ts_init),
                ts_init=ts_init,
                info=_symbol_info_to_dict(symbol_info),
            )
            self.add_currency(currency=instrument.base_currency)
            self.add_currency(currency=instrument.quote_currency)
            self.add(instrument=instrument)
            self._log.debug(f"Added instrument {instrument.id}.")
        except ValueError as e:
            if self._log_warnings:
                self._log.warning(f"Unable to parse instrument {symbol_info.symbol}: {e}.")
</document_content>
</document>
<document index="1781">
<source>nautilus_trader/adapters/binance/spot/schemas/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="1782">
<source>nautilus_trader/adapters/binance/spot/schemas/account.py</source>
<document_content>

from decimal import Decimal
import msgspec
################################################################################
# HTTP responses
################################################################################
class BinanceSpotBalanceInfo(msgspec.Struct, frozen=True):
    """
    HTTP response 'inner struct' from Binance Spot/Margin GET /api/v3/account (HMAC
    SHA256).
    """
    asset: str
    free: str
    locked: str
    def parse_to_account_balance(self) -> AccountBalance:
        currency = Currency.from_str(self.asset)
        free = Decimal(self.free)
        locked = Decimal(self.locked)
        total: Decimal = free + locked
        return AccountBalance(
            total=Money(total, currency),
            locked=Money(locked, currency),
            free=Money(free, currency),
        )
class BinanceSpotAccountInfo(msgspec.Struct, frozen=True):
    """
    HTTP response from Binance Spot/Margin GET /api/v3/account (HMAC SHA256).
    """
    makerCommission: int
    takerCommission: int
    buyerCommission: int
    sellerCommission: int
    canTrade: bool
    canWithdraw: bool
    canDeposit: bool
    updateTime: int
    accountType: BinanceAccountType
    balances: list[BinanceSpotBalanceInfo]
    permissions: list[str]
    def parse_to_account_balances(self) -> list[AccountBalance]:
        return [balance.parse_to_account_balance() for balance in self.balances]
class BinanceSpotOrderOco(msgspec.Struct, frozen=True):
    """
    HTTP response from Binance Spot/Margin GET /api/v3/orderList (HMAC SHA256).
    HTTP response from Binance Spot/Margin POST /api/v3/order/oco (HMAC SHA256). HTTP
    response from Binance Spot/Margin DELETE /api/v3/orderList (HMAC SHA256).
    """
    orderListId: int
    contingencyType: str
    listStatusType: str
    listOrderStatus: str
    listClientOrderId: str
    transactionTime: int
    symbol: str
    orders: list[BinanceOrder] | None = None  # Included for ACK response type
    orderReports: list[BinanceOrder] | None = None  # Included for FULL & RESPONSE types
</document_content>
</document>
<document index="1783">
<source>nautilus_trader/adapters/binance/spot/schemas/market.py</source>
<document_content>

import msgspec
################################################################################
# HTTP responses
################################################################################
class BinanceSpotSymbolInfo(msgspec.Struct, frozen=True):
    """
    HTTP response 'inner struct' from Binance Spot/Margin GET /api/v3/exchangeInfo.
    """
    symbol: str
    status: str
    baseAsset: str
    baseAssetPrecision: int
    quoteAsset: str
    quotePrecision: int
    quoteAssetPrecision: int
    orderTypes: list[BinanceOrderType]
    icebergAllowed: bool
    ocoAllowed: bool
    quoteOrderQtyMarketAllowed: bool
    allowTrailingStop: bool
    isSpotTradingAllowed: bool
    isMarginTradingAllowed: bool
    filters: list[BinanceSymbolFilter]
    permissions: list[str]
    def parse_to_base_asset(self):
        return Currency(
            code=self.baseAsset,
            precision=self.baseAssetPrecision,
            iso4217=0,  # Currently unspecified for crypto assets
            name=self.baseAsset,
            currency_type=CurrencyType.CRYPTO,
        )
    def parse_to_quote_asset(self):
        return Currency(
            code=self.quoteAsset,
            precision=self.quoteAssetPrecision,
            iso4217=0,  # Currently unspecified for crypto assets
            name=self.quoteAsset,
            currency_type=CurrencyType.CRYPTO,
        )
class BinanceSpotExchangeInfo(msgspec.Struct, frozen=True):
    """
    HTTP response from Binance Spot/Margin GET /api/v3/exchangeInfo.
    """
    timezone: str
    serverTime: int
    rateLimits: list[BinanceRateLimit]
    exchangeFilters: list[BinanceExchangeFilter]
    symbols: list[BinanceSpotSymbolInfo]
class BinanceSpotAvgPrice(msgspec.Struct, frozen=True):
    """
    HTTP response from Binance Spot/Margin GET /api/v3/avgPrice.
    """
    mins: int
    price: str
################################################################################
# WebSocket messages
################################################################################
class BinanceSpotOrderBookPartialDepthData(msgspec.Struct):
    """
    Websocket message 'inner struct' for 'Binance Spot/Margin Partial Book Depth
    Streams.'.
    """
    lastUpdateId: int
    bids: list[BinanceOrderBookDelta]
    asks: list[BinanceOrderBookDelta]
    def parse_to_order_book_snapshot(
        self,
        instrument_id: InstrumentId,
        ts_init: int,
    ) -> OrderBookDeltas:
        deltas: list[OrderBookDelta] = [OrderBookDelta.clear(instrument_id, 0, ts_init, ts_init)]
        bids_len = len(self.bids)
        asks_len = len(self.asks)
        for idx, bid in enumerate(self.bids):
            flags = 0
            if idx == bids_len - 1 and asks_len == 0:
                # F_LAST, 1 << 7
                # Last message in the book event or packet from the venue for a given `instrument_id`
                flags = RecordFlag.F_LAST
            delta = bid.parse_to_order_book_delta(
                instrument_id=instrument_id,
                side=OrderSide.BUY,
                flags=flags,
                sequence=self.lastUpdateId,
                ts_event=ts_init,  # No event timestamp
                ts_init=ts_init,
            )
            deltas.append(delta)
        for idx, ask in enumerate(self.asks):
            flags = 0
            if idx == asks_len - 1:
                # F_LAST, 1 << 7
                # Last message in the book event or packet from the venue for a given `instrument_id`
                flags = RecordFlag.F_LAST
            delta = ask.parse_to_order_book_delta(
                instrument_id=instrument_id,
                side=OrderSide.SELL,
                flags=flags,
                sequence=self.lastUpdateId,
                ts_event=ts_init,  # No event timestamp
                ts_init=ts_init,
            )
            deltas.append(delta)
        return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
class BinanceSpotOrderBookPartialDepthMsg(msgspec.Struct):
    """
    WebSocket message for 'Binance Spot/Margin' Partial Book Depth Streams.
    """
    stream: str
    data: BinanceSpotOrderBookPartialDepthData
class BinanceSpotTradeData(msgspec.Struct):
    """
    WebSocket message 'inner struct' for Binance Spot/Margin Trade Streams.
    Fields
    ------
    - e: Event type
    - E: Event time
    - s: Symbol
    - t: Trade ID
    - p: Price
    - q: Quantity
    - T: Trade time
    - m: Is the buyer the market maker?
    """
    e: str  # Event type
    E: int  # Event time
    s: str  # Symbol
    t: int  # Trade ID
    p: str  # Price
    q: str  # Quantity
    T: int  # Trade time
    m: bool  # Is the buyer the market maker?
    def parse_to_trade_tick(
        self,
        instrument_id: InstrumentId,
        ts_init: int | None = None,
    ) -> TradeTick:
        ts_event = millis_to_nanos(self.T)
        return TradeTick(
            instrument_id=instrument_id,
            price=Price.from_str(self.p),
            size=Quantity.from_str(self.q),
            aggressor_side=AggressorSide.SELLER if self.m else AggressorSide.BUYER,
            trade_id=TradeId(str(self.t)),
            ts_event=ts_event,
            ts_init=(ts_init or ts_event),
        )
class BinanceSpotTradeMsg(msgspec.Struct):
    """
    WebSocket message from Binance Trade Streams.
    """
    stream: str
    data: BinanceSpotTradeData
</document_content>
</document>
<document index="1784">
<source>nautilus_trader/adapters/binance/spot/schemas/user.py</source>
<document_content>

from decimal import Decimal
import msgspec
################################################################################
# WebSocket messages
################################################################################
class BinanceSpotUserMsgData(msgspec.Struct, frozen=True):
    """
    Inner struct for execution WebSocket messages from Binance.
    """
    e: BinanceSpotEventType
class BinanceSpotUserMsgWrapper(msgspec.Struct, frozen=True):
    """
    Provides a wrapper for execution WebSocket messages from Binance.
    """
    stream: str
    data: BinanceSpotUserMsgData
class BinanceSpotBalance(msgspec.Struct, frozen=True):
    """
    Inner struct for Binance Spot/Margin balances.
    """
    a: str  # Asset
    f: str  # Free
    l: str  # Locked
    def parse_to_account_balance(self) -> AccountBalance:
        currency = Currency.from_str(self.a)
        free = Decimal(self.f)
        locked = Decimal(self.l)
        total: Decimal = free + locked
        return AccountBalance(
            total=Money(total, currency),
            locked=Money(locked, currency),
            free=Money(free, currency),
        )
class BinanceSpotAccountUpdateMsg(msgspec.Struct, frozen=True):
    """
    WebSocket message for Binance Spot/Margin Account Update events.
    """
    e: str  # Event Type
    E: int  # Event Time
    u: int  # Transaction Time
    B: list[BinanceSpotBalance]
    def parse_to_account_balances(self) -> list[AccountBalance]:
        return [balance.parse_to_account_balance() for balance in self.B]
    def handle_account_update(self, exec_client: BinanceCommonExecutionClient):
        """
        Handle BinanceSpotAccountUpdateMsg as payload of outboundAccountPosition.
        """
        exec_client.generate_account_state(
            balances=self.parse_to_account_balances(),
            margins=[],
            reported=True,
            ts_event=millis_to_nanos(self.u),
        )
class BinanceSpotAccountUpdateWrapper(msgspec.Struct, frozen=True):
    """
    WebSocket message wrapper for Binance Spot/Margin Account Update events.
    """
    stream: str
    data: BinanceSpotAccountUpdateMsg
class BinanceSpotOrderUpdateData(msgspec.Struct, kw_only=True):
    """
    WebSocket message 'inner struct' for Binance Spot/Margin Order Update events.
    """
    e: BinanceSpotEventType
    E: int  # Event time
    s: str  # Symbol
    c: str  # Client order ID
    S: BinanceOrderSide
    o: BinanceOrderType
    f: BinanceTimeInForce
    q: str  # Original Quantity
    p: str  # Original Price
    P: str  # Stop price
    F: str  # Iceberg quantity
    g: int  # Order list ID
    C: str  # Original client order ID; This is the ID of the order being canceled
    x: BinanceExecutionType
    X: BinanceOrderStatus
    r: str  # Order reject reason; will be an error code
    i: int  # Order ID
    l: str  # Order Last Filled Quantity
    z: str  # Order Filled Accumulated Quantity
    L: str  # Last Filled Price
    n: str | None = None  # Commission, will not push if no commission
    N: str | None = None  # Commission Asset, will not push if no commission
    T: int  # Order Trade Time
    t: int  # Trade ID
    I: int  # Ignore
    w: bool  # Is the order on the book?
    m: bool  # Is trade the maker side
    M: bool  # Ignore
    O: int  # Order creation time
    Z: str  # Cumulative quote asset transacted quantity
    Y: str  # Last quote asset transacted quantity (i.e. lastPrice * lastQty)
    Q: str  # Quote Order Qty
    W: int | None = None  # Working Time (when order was added to the book)
    V: str | None = None  # Self-Trade Prevention Mode
    def parse_to_order_status_report(
        self,
        account_id: AccountId,
        instrument_id: InstrumentId,
        client_order_id: ClientOrderId,
        venue_order_id: VenueOrderId,
        ts_event: int,
        ts_init: int,
        enum_parser: BinanceEnumParser,
    ) -> OrderStatusReport:
        price = Price.from_str(self.p) if self.p is not None else None
        trigger_price = Price.from_str(self.P) if self.P is not None else None
        order_side = OrderSide.BUY if self.S == BinanceOrderSide.BUY else OrderSide.SELL
        post_only = self.f == BinanceTimeInForce.GTX
        display_qty = (
            Quantity.from_str(
                str(Decimal(self.q) - Decimal(self.F)),
            )
            if self.F is not None
            else None
        )
        return OrderStatusReport(
            account_id=account_id,
            instrument_id=instrument_id,
            client_order_id=client_order_id,
            venue_order_id=venue_order_id,
            order_side=order_side,
            order_type=enum_parser.parse_binance_order_type(self.o),
            time_in_force=enum_parser.parse_binance_time_in_force(self.f),
            order_status=enum_parser.parse_binance_order_status(self.X),
            price=price,
            trigger_price=trigger_price,
            trigger_type=TriggerType.LAST_PRICE,
            trailing_offset=None,
            trailing_offset_type=TrailingOffsetType.NO_TRAILING_OFFSET,
            quantity=Quantity.from_str(self.q),
            filled_qty=Quantity.from_str(self.z),
            display_qty=display_qty,
            avg_px=None,
            post_only=post_only,
            reduce_only=False,
            report_id=UUID4(),
            ts_accepted=ts_event,
            ts_last=ts_event,
            ts_init=ts_init,
        )
    def handle_execution_report(  # noqa: C901 (too complex)
        self,
        exec_client: BinanceCommonExecutionClient,
    ):
        """
        Handle BinanceSpotOrderUpdateData as payload of executionReport event.
        """
        client_order_id_str: str = self.c
        if not client_order_id_str or not client_order_id_str.startswith("O"):
            client_order_id_str = self.C
        client_order_id = ClientOrderId(client_order_id_str or UUID4().value)
        ts_event = millis_to_nanos(self.T)
        venue_order_id = VenueOrderId(str(self.i))
        instrument_id = exec_client._get_cached_instrument_id(self.s)
        strategy_id = exec_client._cache.strategy_id_for_order(client_order_id)
        if strategy_id is None:
            report = self.parse_to_order_status_report(
                account_id=exec_client.account_id,
                instrument_id=instrument_id,
                client_order_id=client_order_id,
                venue_order_id=venue_order_id,
                ts_event=ts_event,
                ts_init=exec_client._clock.timestamp_ns(),
                enum_parser=exec_client._enum_parser,
            )
            exec_client._send_order_status_report(report)
            return
        if self.x == BinanceExecutionType.NEW:
            exec_client.generate_order_accepted(
                strategy_id=strategy_id,
                instrument_id=instrument_id,
                client_order_id=client_order_id,
                venue_order_id=venue_order_id,
                ts_event=ts_event,
            )
            # Check if price changed (for price_match orders)
            order = exec_client._cache.order(client_order_id)
            if order and order.has_price:
                instrument = exec_client._instrument_provider.find(instrument_id=instrument_id)
                if instrument is not None:
                    price_precision = instrument.price_precision
                    binance_price = Price(float(self.p), price_precision)
                    if binance_price != order.price:
                        # Preserve trigger price for stop orders (priceMatch only affects limit price)
                        trigger_price = order.trigger_price if order.has_trigger_price else None
                        exec_client.generate_order_updated(
                            strategy_id=strategy_id,
                            instrument_id=instrument_id,
                            client_order_id=client_order_id,
                            venue_order_id=venue_order_id,
                            quantity=order.quantity,
                            price=binance_price,
                            trigger_price=trigger_price,
                            ts_event=ts_event,
                        )
        elif self.x == BinanceExecutionType.TRADE or self.x == BinanceExecutionType.CALCULATED:
            if self.x == BinanceExecutionType.CALCULATED:
                exec_client._log.info(
                    f"Received CALCULATED (liquidation) execution for order {venue_order_id}, "
                    f"generating OrderFilled event",
                )
            if Decimal(self.L) == 0:
                exec_client._log.warning(
                    f"Received {self.x.value} execution with L=0 for order {venue_order_id}, "
                    f"order status={self.X.value}",
                )
                # Route based on order status to ensure terminal events are generated
                if self.X == BinanceOrderStatus.EXPIRED:
                    exec_client.generate_order_expired(
                        strategy_id=strategy_id,
                        instrument_id=instrument_id,
                        client_order_id=client_order_id,
                        venue_order_id=venue_order_id,
                        ts_event=ts_event,
                    )
                    return
                elif self.X == BinanceOrderStatus.CANCELED:
                    exec_client.generate_order_canceled(
                        strategy_id=strategy_id,
                        instrument_id=instrument_id,
                        client_order_id=client_order_id,
                        venue_order_id=venue_order_id,
                        ts_event=ts_event,
                    )
                    return
                elif self.X in (BinanceOrderStatus.FILLED, BinanceOrderStatus.PARTIALLY_FILLED):
                    # Continue to generate fill with L=0 to close order
                    # Better to have bad price data than stuck order
                    exec_client._log.warning(
                        f"Generating OrderFilled with L=0 for terminal state {self.X.value} "
                        f"to prevent order from being stuck",
                    )
                else:
                    # Non-terminal status with L=0, skip fill generation
                    return
            instrument = exec_client._instrument_provider.find(instrument_id=instrument_id)
            if instrument is None:
                raise ValueError(
                    f"Cannot process fill for {instrument_id}: instrument not found in cache",
                )
            # Determine commission
            commission_asset = self.N
            commission_amount = self.n
            if commission_asset is not None:
                commission = Money.from_str(f"{commission_amount} {commission_asset}")
            else:
                # Binance typically charges commission as base asset or BNB
                commission = Money(0, instrument.base_currency)
            # Liquidations are always taker, regular trades use the 'm' field
            liquidity_side = (
                LiquiditySide.TAKER
                if self.x == BinanceExecutionType.CALCULATED
                else (LiquiditySide.MAKER if self.m else LiquiditySide.TAKER)
            )
            exec_client.generate_order_filled(
                strategy_id=strategy_id,
                instrument_id=instrument_id,
                client_order_id=client_order_id,
                venue_order_id=venue_order_id,
                venue_position_id=None,  # NETTING accounts
                trade_id=TradeId(str(self.t)),  # Trade ID
                order_side=exec_client._enum_parser.parse_binance_order_side(self.S),
                order_type=exec_client._enum_parser.parse_binance_order_type(self.o),
                last_qty=Quantity.from_str(self.l),
                last_px=Price.from_str(self.L),
                quote_currency=instrument.quote_currency,
                commission=commission,
                liquidity_side=liquidity_side,
                ts_event=ts_event,
            )
        elif self.x == BinanceExecutionType.CANCELED:
            exec_client.generate_order_canceled(
                strategy_id=strategy_id,
                instrument_id=instrument_id,
                client_order_id=client_order_id,
                venue_order_id=venue_order_id,
                ts_event=ts_event,
            )
        elif self.x == BinanceExecutionType.REJECTED:
            # A rejection can occur for many reasons, but most commonly for
            # POST-ONLY (GTX) orders that would immediately take liquidity. We
            # flag these specifically so downstream components can distinguish
            # between generic rejections and those due to the post-only
            # constraint.
            due_post_only = self.f == BinanceTimeInForce.GTX
            exec_client.generate_order_rejected(
                strategy_id=strategy_id,
                instrument_id=instrument_id,
                client_order_id=client_order_id,
                reason=str(self.r),
                ts_event=ts_event,
                due_post_only=due_post_only,
            )
        elif self.x == BinanceExecutionType.EXPIRED:
            exec_client.generate_order_expired(
                strategy_id=strategy_id,
                instrument_id=instrument_id,
                client_order_id=client_order_id,
                venue_order_id=venue_order_id,
                ts_event=ts_event,
            )
        elif self.x == BinanceExecutionType.TRADE_PREVENTION:
            # Self-trade prevention triggered - no actual trade occurred
            exec_client._log.info(
                f"Self-trade prevention triggered for order {venue_order_id}, "
                f"prevented qty={self.l} at price={self.L}",
            )
        else:
            # Event not handled
            exec_client._log.warning(f"Received unhandled {self}")
class BinanceSpotOrderUpdateWrapper(msgspec.Struct, frozen=True):
    """
    WebSocket message wrapper for Binance Spot/Margin Order Update events.
    """
    stream: str
    data: BinanceSpotOrderUpdateData
</document_content>
</document>
<document index="1785">
<source>nautilus_trader/adapters/binance/spot/schemas/wallet.py</source>
<document_content>

import msgspec
################################################################################
# HTTP responses
################################################################################
class BinanceSpotTradeFee(msgspec.Struct, frozen=True):
    """
    Schema of a single Binance Spot/Margin tradeFee.
    """
    symbol: str
    makerCommission: str
    takerCommission: str
</document_content>
</document>
<document index="1786">
<source>nautilus_trader/adapters/binance/websocket/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="1787">
<source>nautilus_trader/adapters/binance/websocket/client.py</source>
<document_content>

import asyncio
from collections.abc import Awaitable
from collections.abc import Callable
from typing import Any
from weakref import WeakSet
import msgspec
class BinanceWebSocketClient:
    """
    Provides a Binance streaming WebSocket client.
    Manages multiple WebSocket connections with up to 200 subscriptions per connection
    as per Binance documentation.
    Parameters
    ----------
    clock : LiveClock
        The clock for the client.
    base_url : str
        The base URL for the WebSocket connection.
    handler : Callable[[bytes], None]
        The callback handler for message events.
    handler_reconnect : Callable[..., Awaitable[None]], optional
        The callback handler to be called on reconnect.
    loop : asyncio.AbstractEventLoop
        The event loop for the client.
    References
    ----------
    https://binance-docs.github.io/apidocs/spot/en/#websocket-market-streams
    """
    MAX_SUBSCRIPTIONS_PER_CLIENT = 200
    MAX_CLIENTS = 20  # Allows up to 4000 total subscriptions (20 x 200)
    def __init__(
        self,
        clock: LiveClock,
        base_url: str,
        handler: Callable[[bytes], None],
        handler_reconnect: Callable[..., Awaitable[None]] | None,
        loop: asyncio.AbstractEventLoop,
    ) -> None:
        self._clock = clock
        self._log: Logger = Logger(type(self).__name__)
        self._base_url: str = base_url
        self._handler: Callable[[bytes], None] = handler
        self._handler_reconnect: Callable[..., Awaitable[None]] | None = handler_reconnect
        self._loop = loop
        self._tasks: WeakSet[asyncio.Task] = WeakSet()
        self._streams: list[str] = []
        self._clients: dict[int, WebSocketClient | None] = {}  # Client ID -> WebSocket client
        self._client_streams: dict[int, list[str]] = {}  # Client ID -> streams
        self._is_connecting: dict[int, bool] = {}  # Client ID -> is_connecting flag
        self._msg_id: int = 0
        self._next_client_id: int = 0
    @property
    def url(self) -> str:
        """
        Return the server URL being used by the client.
        Returns
        -------
        str
        """
        return self._base_url
    @property
    def subscriptions(self) -> list[str]:
        """
        Return the current active subscriptions for the client.
        Returns
        -------
        str
        """
        return self._streams.copy()
    @property
    def has_subscriptions(self) -> bool:
        """
        Return whether the client has subscriptions.
        Returns
        -------
        bool
        """
        return bool(self._streams)
    def _get_client_for_stream(self, stream: str) -> int:
        """
        Determine which client is handling a particular stream.
        Returns
        -------
        int
            The client ID handling the stream, or -1 if not found.
        """
        for client_id, streams in self._client_streams.items():
            if stream in streams:
                return client_id
        return -1
    def _get_client_id_for_new_subscription(self) -> int:
        """
        Find or create a client ID for a new subscription.
        Returns
        -------
        int
            The client ID to use for the new subscription.
        Raises
        ------
        RuntimeError
            If maximum number of clients and subscriptions are exceeded.
        """
        # Try to find an existing client with room for another subscription
        for client_id, streams in self._client_streams.items():
            if len(streams) < self.MAX_SUBSCRIPTIONS_PER_CLIENT:
                return client_id
        # Check if we can create a new client
        if len(self._clients) >= self.MAX_CLIENTS:
            max_total_streams = self.MAX_CLIENTS * self.MAX_SUBSCRIPTIONS_PER_CLIENT
            raise RuntimeError(
                f"Cannot create new subscription: maximum limit of {max_total_streams} "
                f"total subscriptions ({self.MAX_CLIENTS} clients x "
                f"{self.MAX_SUBSCRIPTIONS_PER_CLIENT} subscriptions) exceeded",
            )
        # Create a new client ID
        client_id = self._next_client_id
        self._next_client_id += 1
        self._clients[client_id] = None
        self._client_streams[client_id] = []
        self._is_connecting[client_id] = False
        return client_id
    async def connect(self) -> None:
        """
        Connect websocket clients to the server based on existing subscriptions.
        """
        if not self._streams:
            self._log.error("Cannot connect: no streams for initial connection")
            return
        # Group streams by client (using existing assignments or creating new ones)
        client_streams: dict[int, list[str]] = {}
        for stream in self._streams:
            client_id = self._get_client_for_stream(stream)
            if client_id == -1:
                client_id = self._get_client_id_for_new_subscription()
            if client_id not in client_streams:
                client_streams[client_id] = []
            client_streams[client_id].append(stream)
        # Connect clients
        for client_id, streams in client_streams.items():
            await self._connect_client(client_id, streams)
    async def _connect_client(self, client_id: int, streams: list[str]) -> None:
        """
        Connect a single websocket client to the server.
        Parameters
        ----------
        client_id : int
            ID of the client to connect
        streams : list[str]
            List of streams for this client
        """
        if not streams:
            self._log.error(f"Cannot connect client {client_id}: no streams provided")
            return
        # Update client streams tracking
        self._client_streams[client_id] = streams.copy()
        # Binance expects at least one stream for the initial connection
        initial_stream = streams[0]
        ws_url = self._base_url + f"/stream?streams={initial_stream}"
        self._log.debug(f"ws-client {client_id}: Connecting to {ws_url}...")
        self._is_connecting[client_id] = True
        config = WebSocketConfig(
            url=ws_url,
            handler=self._handler,
            heartbeat=60,
            headers=[],
            ping_handler=lambda raw: self._handle_ping(client_id, raw),
        )
        self._clients[client_id] = await WebSocketClient.connect(
            config=config,
            post_reconnection=lambda: self._handle_reconnect(client_id),
        )
        self._is_connecting[client_id] = False
        self._log.info(f"ws-client {client_id}: Connected to {self._base_url}", LogColor.BLUE)
        self._log.debug(f"ws-client {client_id}: Subscribed to {initial_stream}")
        # If there are multiple streams, subscribe to the rest
        if len(streams) > 1:
            msg = self._create_subscribe_msg(streams=streams[1:])
            await self._send(client_id, msg)
            self._log.debug(
                f"ws-client {client_id}: Subscribed to additional {len(streams) - 1} streams",
            )
    def _handle_ping(self, client_id: int, raw: bytes) -> None:
        task = self._loop.create_task(self.send_pong(client_id, raw))
        self._tasks.add(task)
    async def send_pong(self, client_id: int, raw: bytes) -> None:
        """
        Send the given raw payload to the server as a PONG message.
        """
        client = self._clients.get(client_id)
        if client is None:
            return
        try:
            await client.send_pong(raw)
        except WebSocketClientError as e:
            self._log.error(f"ws-client {client_id}: {e!s}")
    def _handle_reconnect(self, client_id: int) -> None:
        """
        Handle reconnection for a specific client.
        """
        if client_id not in self._client_streams or not self._client_streams[client_id]:
            self._log.error(f"ws-client {client_id}: Cannot reconnect: no streams for this client")
            return
        self._log.warning(f"ws-client {client_id}: Reconnected to {self._base_url}")
        # Re-subscribe to all streams for this client
        streams = self._client_streams[client_id]
        task = self._loop.create_task(self._resubscribe_client(client_id, streams))
        self._tasks.add(task)
        if self._handler_reconnect:
            task = self._loop.create_task(self._handler_reconnect())  # type: ignore
            self._tasks.add(task)
    async def _resubscribe_client(self, client_id: int, streams: list[str]) -> None:
        """
        Resubscribe all streams for a given client.
        """
        if not streams:
            return
        msg = self._create_subscribe_msg(streams=streams)
        await self._send(client_id, msg)
        self._log.debug(f"ws-client {client_id}: Resubscribed to {len(streams)} streams")
    async def disconnect(self) -> None:
        """
        Disconnect all clients from the server.
        """
        await cancel_tasks_with_timeout(self._tasks, self._log)
        tasks = []
        for client_id in list(self._clients.keys()):
            tasks.append(self._disconnect_client(client_id))
        if tasks:
            await asyncio.gather(*tasks)
            self._log.info(f"Disconnected all clients from {self._base_url}", LogColor.BLUE)
    async def _disconnect_client(self, client_id: int) -> None:
        """
        Disconnect a specific client from the server.
        """
        client = self._clients.get(client_id)
        if client is None:
            return
        # Check Rust-level state to make this idempotent
        if client.is_disconnecting() or client.is_closed():
            self._log.debug(f"ws-client {client_id}: Already disconnecting/closed, skipping")
            return
        self._log.debug(f"ws-client {client_id}: Disconnecting...")
        try:
            await client.disconnect()
        except WebSocketClientError as e:
            self._log.error(f"ws-client {client_id}: {e!s}")
        self._clients[client_id] = None  # Dispose (will go out of scope)
        self._log.debug(f"ws-client {client_id}: Disconnected from {self._base_url}")
    async def subscribe_listen_key(self, listen_key: str) -> None:
        """
        Subscribe to user data stream.
        """
        await self._subscribe(listen_key)
    async def unsubscribe_listen_key(self, listen_key: str) -> None:
        """
        Unsubscribe from user data stream.
        """
        await self._unsubscribe(listen_key)
    async def subscribe_agg_trades(self, symbol: str) -> None:
        """
        Subscribe to aggregate trade stream.
        The Aggregate Trade Streams push trade information that is aggregated for a single taker order.
        Stream Name: <symbol>@aggTrade
        Update Speed: Real-time
        """
        stream = f"{BinanceSymbol(symbol).lower()}@aggTrade"
        await self._subscribe(stream)
    async def unsubscribe_agg_trades(self, symbol: str) -> None:
        """
        Unsubscribe from aggregate trade stream.
        """
        stream = f"{BinanceSymbol(symbol).lower()}@aggTrade"
        await self._unsubscribe(stream)
    async def subscribe_trades(self, symbol: str) -> None:
        """
        Subscribe to trade stream.
        The Trade Streams push raw trade information; each trade has a unique buyer and seller.
        Stream Name: <symbol>@trade
        Update Speed: Real-time
        """
        stream = f"{BinanceSymbol(symbol).lower()}@trade"
        await self._subscribe(stream)
    async def unsubscribe_trades(self, symbol: str) -> None:
        """
        Unsubscribe from trade stream.
        """
        stream = f"{BinanceSymbol(symbol).lower()}@trade"
        await self._unsubscribe(stream)
    async def subscribe_bars(
        self,
        symbol: str,
        interval: str,
    ) -> None:
        """
        Subscribe to bar (kline/candlestick) stream.
        The Kline/Candlestick Stream push updates to the current klines/candlestick every second.
        Stream Name: <symbol>@kline_<interval>
        interval:
        m -> minutes; h -> hours; d -> days; w -> weeks; M -> months
        - 1m
        - 3m
        - 5m
        - 15m
        - 30m
        - 1h
        - 2h
        - 4h
        - 6h
        - 8h
        - 12h
        - 1d
        - 3d
        - 1w
        - 1M
        Update Speed: 2000ms
        """
        stream = f"{BinanceSymbol(symbol).lower()}@kline_{interval}"
        await self._subscribe(stream)
    async def unsubscribe_bars(
        self,
        symbol: str,
        interval: str,
    ) -> None:
        """
        Unsubscribe from bar (kline/candlestick) stream.
        """
        stream = f"{BinanceSymbol(symbol).lower()}@kline_{interval}"
        await self._unsubscribe(stream)
    async def subscribe_mini_ticker(
        self,
        symbol: str | None = None,
    ) -> None:
        """
        Subscribe to individual symbol or all symbols mini ticker stream.
        24hr rolling window mini-ticker statistics.
        These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs
        Stream Name: <symbol>@miniTicker or
        Stream Name: !miniTicker@arr
        Update Speed: 1000ms
        """
        if symbol is None:
            stream = "!miniTicker@arr"
        else:
            stream = f"{BinanceSymbol(symbol).lower()}@miniTicker"
        await self._subscribe(stream)
    async def unsubscribe_mini_ticker(
        self,
        symbol: str | None = None,
    ) -> None:
        """
        Unsubscribe to individual symbol or all symbols mini ticker stream.
        """
        if symbol is None:
            stream = "!miniTicker@arr"
        else:
            stream = f"{BinanceSymbol(symbol).lower()}@miniTicker"
        await self._unsubscribe(stream)
    async def subscribe_ticker(
        self,
        symbol: str | None = None,
    ) -> None:
        """
        Subscribe to individual symbol or all symbols ticker stream.
        24hr rolling window ticker statistics for a single symbol.
        These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs.
        Stream Name: <symbol>@ticker or
        Stream Name: !ticker@arr
        Update Speed: 1000ms
        """
        if symbol is None:
            stream = "!ticker@arr"
        else:
            stream = f"{BinanceSymbol(symbol).lower()}@ticker"
        await self._subscribe(stream)
    async def unsubscribe_ticker(
        self,
        symbol: str | None = None,
    ) -> None:
        """
        Unsubscribe from individual symbol or all symbols ticker stream.
        """
        if symbol is None:
            stream = "!ticker@arr"
        else:
            stream = f"{BinanceSymbol(symbol).lower()}@ticker"
        await self._unsubscribe(stream)
    async def subscribe_book_ticker(
        self,
        symbol: str | None = None,
    ) -> None:
        """
        Subscribe to individual symbol or all book tickers stream.
        Pushes any update to the best bid or ask's price or quantity in real-time for a specified symbol.
        Stream Name: <symbol>@bookTicker or
        Stream Name: !bookTicker
        Update Speed: realtime
        """
        if symbol is None:
            stream = "!bookTicker"
        else:
            stream = f"{BinanceSymbol(symbol).lower()}@bookTicker"
        await self._subscribe(stream)
    async def unsubscribe_book_ticker(
        self,
        symbol: str | None = None,
    ) -> None:
        """
        Unsubscribe from individual symbol or all book tickers.
        """
        if symbol is None:
            stream = "!bookTicker"
        else:
            stream = f"{BinanceSymbol(symbol).lower()}@bookTicker"
        await self._unsubscribe(stream)
    async def subscribe_partial_book_depth(
        self,
        symbol: str,
        depth: int,
        speed: int,
    ) -> None:
        """
        Subscribe to partial book depth stream.
        Top bids and asks, Valid are 5, 10, or 20.
        Stream Names: <symbol>@depth<levels> OR <symbol>@depth<levels>@100ms.
        Update Speed: 1000ms or 100ms
        """
        stream = f"{BinanceSymbol(symbol).lower()}@depth{depth}@{speed}ms"
        await self._subscribe(stream)
    async def unsubscribe_partial_book_depth(
        self,
        symbol: str,
        depth: int,
        speed: int,
    ) -> None:
        """
        Unsubscribe from partial book depth stream.
        """
        stream = f"{BinanceSymbol(symbol).lower()}@depth{depth}@{speed}ms"
        await self._unsubscribe(stream)
    async def subscribe_diff_book_depth(
        self,
        symbol: str,
        speed: int,
    ) -> None:
        """
        Subscribe to diff book depth stream.
        Stream Name: <symbol>@depth OR <symbol>@depth@100ms
        Update Speed: 1000ms or 100ms
        Order book price and quantity depth updates used to locally manage an order book.
        """
        stream = f"{BinanceSymbol(symbol).lower()}@depth@{speed}ms"
        await self._subscribe(stream)
    async def unsubscribe_diff_book_depth(
        self,
        symbol: str,
        speed: int,
    ) -> None:
        """
        Unsubscribe from diff book depth stream.
        """
        stream = f"{BinanceSymbol(symbol).lower()}@depth@{speed}ms"
        await self._unsubscribe(stream)
    async def subscribe_mark_price(
        self,
        symbol: str | None = None,
        speed: int | None = None,
    ) -> None:
        """
        Subscribe to aggregate mark price stream.
        """
        if speed and speed not in (1000, 3000):
            raise ValueError(f"`speed` options are 1000ms or 3000ms only, was {speed}")
        if symbol is None:
            stream = "!markPrice@arr"
        else:
            stream = f"{BinanceSymbol(symbol).lower()}@markPrice"
        if speed:
            stream += f"@{int(speed / 1000)}s"
        await self._subscribe(stream)
    async def unsubscribe_mark_price(
        self,
        symbol: str | None = None,
        speed: int | None = None,
    ) -> None:
        """
        Unsubscribe from aggregate mark price stream.
        """
        if speed not in (1000, 3000):
            raise ValueError(f"`speed` options are 1000ms or 3000ms only, was {speed}")
        if symbol is None:
            stream = "!markPrice@arr"
        else:
            stream = f"{BinanceSymbol(symbol).lower()}@markPrice@{int(speed / 1000)}s"
        await self._unsubscribe(stream)
    async def _subscribe(self, stream: str) -> None:
        if stream in self._streams:
            self._log.warning(f"Cannot subscribe to {stream}: already subscribed")
            return  # Already subscribed
        self._streams.append(stream)
        # Determine which client should handle this stream
        client_id = self._get_client_id_for_new_subscription()
        # Add to client's stream list
        if client_id not in self._client_streams:
            self._client_streams[client_id] = []
        self._client_streams[client_id].append(stream)
        # Wait for client to finish connecting if it's in progress
        while self._is_connecting.get(client_id):
            await asyncio.sleep(0.01)
        # If client doesn't exist yet, connect it
        if client_id not in self._clients or self._clients[client_id] is None:
            await self._connect_client(client_id, [stream])
            return
        # Otherwise, send subscription message to existing client
        msg = self._create_subscribe_msg(streams=[stream])
        await self._send(client_id, msg)
        self._log.debug(f"ws-client {client_id}: Subscribed to {stream}")
    async def _unsubscribe(self, stream: str) -> None:
        if stream not in self._streams:
            self._log.warning(f"Cannot unsubscribe from {stream}: not subscribed")
            return  # Not subscribed
        # Find which client has this stream
        client_id = self._get_client_for_stream(stream)
        if client_id == -1:
            self._log.warning(f"Cannot find client for stream {stream}")
            self._streams.remove(stream)
            return
        # Remove from global streams list
        self._streams.remove(stream)
        # Remove from client's streams list
        if client_id in self._client_streams and stream in self._client_streams[client_id]:
            self._client_streams[client_id].remove(stream)
        # Send unsubscribe message
        msg = self._create_unsubscribe_msg(streams=[stream])
        await self._send(client_id, msg)
        self._log.debug(f"ws-client {client_id}: Unsubscribed from {stream}")
        # If client has no more streams, disconnect it
        if client_id in self._client_streams and not self._client_streams[client_id]:
            await self._disconnect_client(client_id)
            self._log.debug(
                f"ws-client {client_id}: Disconnected due to no remaining subscriptions",
            )
    def _create_subscribe_msg(self, streams: list[str]) -> dict[str, Any]:
        message = {
            "method": "SUBSCRIBE",
            "params": streams,
            "id": self._msg_id,
        }
        self._msg_id += 1
        return message
    def _create_unsubscribe_msg(self, streams: list[str]) -> dict[str, Any]:
        message = {
            "method": "UNSUBSCRIBE",
            "params": streams,
            "id": self._msg_id,
        }
        self._msg_id += 1
        return message
    async def _send(self, client_id: int, msg: dict[str, Any]) -> None:
        client = self._clients.get(client_id)
        if client is None:
            self._log.error(f"ws-client {client_id}: Cannot send message {msg}: not connected")
            return
        self._log.debug(f"ws-client {client_id}: SENDING: {msg}")
        try:
            await client.send_text(msgspec.json.encode(msg))
        except WebSocketClientError as e:
            self._log.error(f"ws-client {client_id}: {e!s}")
</document_content>
</document>
<document index="2504">
<source>tests/integration_tests/adapters/binance/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="2505">
<source>tests/integration_tests/adapters/binance/conftest.py</source>
<document_content>

import pytest
@pytest.fixture(scope="session")
def live_clock():
    return LiveClock()
@pytest.fixture(scope="session")
def live_logger():
    return Logger("TEST_LOGGER")
@pytest.fixture(scope="session")
def binance_http_client(session_event_loop, live_clock):
    client = BinanceHttpClient(
        clock=live_clock,
        api_key="SOME_BINANCE_API_KEY",
        api_secret="SOME_BINANCE_API_SECRET",
        base_url="https://api.binance.com/",  # Spot/Margin
    )
    return client
@pytest.fixture()
def venue() -> Venue:
    raise BINANCE_VENUE
@pytest.fixture()
def data_client():
    pass
@pytest.fixture()
def exec_client():
    pass
@pytest.fixture()
def instrument():
    pass
@pytest.fixture()
def account_state():
    pass
</document_content>
</document>
<document index="2506">
<source>tests/integration_tests/adapters/binance/resources/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="2507">
<source>tests/integration_tests/adapters/binance/resources/http_responses/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="2508">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_account_orders.json</source>
<document_content>
[
  {
    "avgPrice": "0.00000",
    "clientOrderId": "abc",
    "cumQuote": "0",
    "executedQty": "0",
    "orderId": 1917641,
    "origQty": "0.40",
    "origType": "TRAILING_STOP_MARKET",
    "price": "0",
    "reduceOnly": false,
    "side": "BUY",
    "positionSide": "SHORT",
    "status": "NEW",
    "stopPrice": "9300",
    "closePosition": false,
    "symbol": "BTCUSDT",
    "time": 1579276756075,
    "timeInForce": "GTC",
    "type": "TRAILING_STOP_MARKET",
    "activatePrice": "9020",
    "priceRate": "0.3",
    "updateTime": 1579276756075,
    "workingType": "CONTRACT_PRICE",
    "priceProtect": false
  }
]
</document_content>
</document>
<document index="2509">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_account_position_side_dual.json</source>
<document_content>
{
  "dualSidePosition": true
}
</document_content>
</document>
<document index="2510">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_account_positions_hedge.json</source>
<document_content>
[
  {
    "entryPrice": "6563.66500",
    "marginType": "isolated",
    "isAutoAddMargin": "false",
    "isolatedMargin": "15517.54150468",
    "leverage": "10",
    "liquidationPrice": "5930.78",
    "markPrice": "6679.50671178",
    "maxNotionalValue": "20000000",
    "positionAmt": "20.000",
    "symbol": "BTCUSDT",
    "unRealizedProfit": "2316.83423560",
    "positionSide": "LONG",
    "updateTime": 1625474304765
  },
  {
    "entryPrice": "0.00000",
    "marginType": "isolated",
    "isAutoAddMargin": "false",
    "isolatedMargin": "5413.95799991",
    "leverage": "10",
    "liquidationPrice": "7189.95",
    "markPrice": "6679.50671178",
    "maxNotionalValue": "20000000",
    "positionAmt": "-10.000",
    "symbol": "BTCUSDT",
    "unRealizedProfit": "-1156.46711780",
    "positionSide": "SHORT",
    "updateTime": 0
  }
]
</document_content>
</document>
<document index="2511">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_account_positions_one_way.json</source>
<document_content>
[
  {
    "entryPrice": "0.00000",
    "marginType": "isolated",
    "isAutoAddMargin": "false",
    "isolatedMargin": "0.00000000",
    "leverage": "10",
    "liquidationPrice": "0",
    "markPrice": "6679.50671178",
    "maxNotionalValue": "20000000",
    "positionAmt": "0.000",
    "symbol": "BTCUSDT",
    "unRealizedProfit": "0.00000000",
    "positionSide": "BOTH",
    "updateTime": 0
  }
]
</document_content>
</document>
<document index="2512">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_account_symbol_config.json</source>
<document_content>
[
  {
    "symbol": "ETHUSDT",
    "marginType": "CROSSED",
    "isAutoAddMargin": false,
    "leverage": 20,
    "maxNotionalValue": "1000000"
  },
  {
    "symbol": "BTCUSDT",
    "marginType": "ISOLATED",
    "isAutoAddMargin": true,
    "leverage": 25,
    "maxNotionalValue": "2000000"
  }
]
</document_content>
</document>
<document index="2513">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_account_trades.json</source>
<document_content>
[
    {
        "symbol": "ETHUSDT",
        "id": 82357626,
        "orderId": 831238666,
        "side": "SELL",
        "price": "2778.35",
        "qty": "0.005",
        "realizedPnl": "0",
        "marginAsset": "USDT",
        "quoteQty": "13.89175",
        "commission": "0.00555670",
        "commissionAsset": "USDT",
        "time": 1645930322371,
        "positionSide": "BOTH",
        "buyer": false,
        "maker": false
    },
    {
        "symbol": "ETHUSDT",
        "id": 82357629,
        "orderId": 831238690,
        "side": "BUY",
        "price": "2779",
        "qty": "0.005",
        "realizedPnl": "-0.00325000",
        "marginAsset": "USDT",
        "quoteQty": "13.89500",
        "commission": "0.00555800",
        "commissionAsset": "USDT",
        "time": 1645930333910,
        "positionSide": "BOTH",
        "buyer": true,
        "maker": false
    }
]
</document_content>
</document>
<document index="2514">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_agg_trades.json</source>
<document_content>
[
  {
    "a": 26129,
    "p": "0.01633102",
    "q": "4.70443515",
    "f": 27781,
    "l": 27781,
    "T": 1498793709153,
    "m": true
  }
]
</document_content>
</document>
<document index="2515">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_asset_index.json</source>
<document_content>
{
  "symbol": "ADAUSD",
  "time": 1635740268004,
  "index": "1.92957370",
  "bidBuffer": "0.10000000",
  "askBuffer": "0.10000000",
  "bidRate": "1.73661633",
  "askRate": "2.12253107",
  "autoExchangeBidBuffer": "0.05000000",
  "autoExchangeAskBuffer": "0.05000000",
  "autoExchangeBidRate": "1.83309501",
  "autoExchangeAskRate": "2.02605238"
}
</document_content>
</document>
<document index="2516">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_blvt_nav_kline.json</source>
<document_content>
[
  [
    1598371200000,
    "5.88275270",
    "6.03142087",
    "5.85749741",
    "5.99403551",
    "2.28602984",
    1598374799999,
    "0",
    6209,
    "14517.64507907",
    "0",
    "0"
  ]
]
</document_content>
</document>
<document index="2517">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_book_ticker.json</source>
<document_content>
{
  "symbol": "BTCUSDT",
  "bidPrice": "4.00000000",
  "bidQty": "431.00000000",
  "askPrice": "4.00000200",
  "askQty": "9.00000000",
  "time": 1589437530011
}
</document_content>
</document>
<document index="2518">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_continuous_klines.json</source>
<document_content>
[
  [
    1607444700000,
    "18879.99",
    "18900.00",
    "18878.98",
    "18896.13",
    "492.363",
    1607444759999,
    "9302145.66080",
    1874,
    "385.983",
    "7292402.33267",
    "0"
  ]
]
</document_content>
</document>
<document index="2519">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_depth.json</source>
<document_content>
{
  "lastUpdateId": 1027024,
  "E": 1589436922972,
  "T": 1589436922959,
  "bids": [
    [
      "4.00000000",
      "431.00000000"
    ]
  ],
  "asks": [
    [
      "4.00000200",
      "12.00000000"
    ]
  ]
}
</document_content>
</document>
<document index="2520">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_exchange_info.json</source>
<document_content>
{
  "timezone": "UTC",
  "serverTime": 1645233611962,
  "futuresType": "U_MARGINED",
  "rateLimits": [
    {
      "rateLimitType": "REQUEST_WEIGHT",
      "interval": "MINUTE",
      "intervalNum": 1,
      "limit": 6000
    },
    {
      "rateLimitType": "ORDERS",
      "interval": "MINUTE",
      "intervalNum": 1,
      "limit": 1200
    },
    {
      "rateLimitType": "ORDERS",
      "interval": "SECOND",
      "intervalNum": 10,
      "limit": 300
    }
  ],
  "exchangeFilters": [],
  "assets": [
    {
      "asset": "USDT",
      "marginAvailable": true,
      "autoAssetExchange": "-100"
    },
    {
      "asset": "BTC",
      "marginAvailable": true,
      "autoAssetExchange": "-0.00100000"
    },
    {
      "asset": "BNB",
      "marginAvailable": true,
      "autoAssetExchange": "-0.00100000"
    },
    {
      "asset": "ETH",
      "marginAvailable": true,
      "autoAssetExchange": "-0.00100000"
    },
    {
      "asset": "BUSD",
      "marginAvailable": true,
      "autoAssetExchange": "-100"
    }
  ],
  "symbols": [
    {
      "symbol": "BTCUSDT",
      "pair": "BTCUSDT",
      "contractType": "PERPETUAL",
      "deliveryDate": 4133404802000,
      "onboardDate": 1569398400000,
      "status": "TRADING",
      "maintMarginPercent": "2.5000",
      "requiredMarginPercent": "5.0000",
      "baseAsset": "BTC",
      "quoteAsset": "USDT",
      "marginAsset": "USDT",
      "pricePrecision": 2,
      "quantityPrecision": 3,
      "baseAssetPrecision": 8,
      "quotePrecision": 8,
      "underlyingType": "COIN",
      "underlyingSubType": [],
      "settlePlan": 0,
      "triggerProtect": "0.0500",
      "liquidationFee": "0.012000",
      "marketTakeBound": "0.30",
      "filters": [
        {
          "minPrice": "402",
          "maxPrice": "1246396.60",
          "filterType": "PRICE_FILTER",
          "tickSize": "0.10"
        },
        {
          "stepSize": "0.001",
          "filterType": "LOT_SIZE",
          "maxQty": "1000",
          "minQty": "0.001"
        },
        {
          "stepSize": "0.001",
          "filterType": "MARKET_LOT_SIZE",
          "maxQty": "1000",
          "minQty": "0.001"
        },
        {
          "limit": 200,
          "filterType": "MAX_NUM_ORDERS"
        },
        {
          "limit": 10,
          "filterType": "MAX_NUM_ALGO_ORDERS"
        },
        {
          "notional": "10",
          "filterType": "MIN_NOTIONAL"
        },
        {
          "multiplierDown": "0.5454",
          "multiplierUp": "1.1000",
          "multiplierDecimal": "4",
          "filterType": "PERCENT_PRICE"
        }
      ],
      "orderTypes": [
        "LIMIT",
        "MARKET",
        "STOP",
        "STOP_MARKET",
        "TAKE_PROFIT",
        "TAKE_PROFIT_MARKET",
        "TRAILING_STOP_MARKET"
      ],
      "timeInForce": [
        "GTC",
        "IOC",
        "FOK",
        "GTX"
      ]
    },
    {
      "symbol": "ETHUSDT",
      "pair": "ETHUSDT",
      "contractType": "PERPETUAL",
      "deliveryDate": 4133404800000,
      "onboardDate": 1569398400000,
      "status": "TRADING",
      "maintMarginPercent": "2.5000",
      "requiredMarginPercent": "5.0000",
      "baseAsset": "ETH",
      "quoteAsset": "USDT",
      "marginAsset": "USDT",
      "pricePrecision": 2,
      "quantityPrecision": 3,
      "baseAssetPrecision": 8,
      "quotePrecision": 8,
      "underlyingType": "COIN",
      "underlyingSubType": [],
      "settlePlan": 0,
      "triggerProtect": "0.0500",
      "liquidationFee": "0.030000",
      "marketTakeBound": "0.10",
      "filters": [
        {
          "minPrice": "28.23",
          "maxPrice": "144004.03",
          "filterType": "PRICE_FILTER",
          "tickSize": "0.01"
        },
        {
          "stepSize": "0.001",
          "filterType": "LOT_SIZE",
          "maxQty": "10000",
          "minQty": "0.001"
        },
        {
          "stepSize": "0.001",
          "filterType": "MARKET_LOT_SIZE",
          "maxQty": "10000",
          "minQty": "0.001"
        },
        {
          "limit": 200,
          "filterType": "MAX_NUM_ORDERS"
        },
        {
          "limit": 10,
          "filterType": "MAX_NUM_ALGO_ORDERS"
        },
        {
          "notional": "10",
          "filterType": "MIN_NOTIONAL"
        },
        {
          "multiplierDown": "0.9000",
          "multiplierUp": "1.1000",
          "multiplierDecimal": "4",
          "filterType": "PERCENT_PRICE"
        }
      ],
      "orderTypes": [
        "LIMIT",
        "MARKET",
        "STOP",
        "STOP_MARKET",
        "TAKE_PROFIT",
        "TAKE_PROFIT_MARKET",
        "TRAILING_STOP_MARKET"
      ],
      "timeInForce": [
        "GTC",
        "IOC",
        "FOK",
        "GTX"
      ]
    },
    {
      "symbol": "BTCUSDT_220325",
      "pair": "BTCUSDT",
      "contractType": "CURRENT_QUARTER",
      "deliveryDate": 1648195200000,
      "onboardDate": 1640332800000,
      "status": "TRADING",
      "maintMarginPercent": "2.5000",
      "requiredMarginPercent": "5.0000",
      "baseAsset": "BTC",
      "quoteAsset": "USDT",
      "marginAsset": "USDT",
      "pricePrecision": 1,
      "quantityPrecision": 3,
      "baseAssetPrecision": 8,
      "quotePrecision": 8,
      "underlyingType": "COIN",
      "underlyingSubType": [],
      "settlePlan": 0,
      "triggerProtect": "0.0500",
      "liquidationFee": "0.010000",
      "marketTakeBound": "0.05",
      "filters": [
        {
          "minPrice": "1093.3",
          "maxPrice": "1822332.8",
          "filterType": "PRICE_FILTER",
          "tickSize": "0.1"
        },
        {
          "stepSize": "0.001",
          "filterType": "LOT_SIZE",
          "maxQty": "500",
          "minQty": "0.001"
        },
        {
          "stepSize": "0.001",
          "filterType": "MARKET_LOT_SIZE",
          "maxQty": "500",
          "minQty": "0.001"
        },
        {
          "limit": 200,
          "filterType": "MAX_NUM_ORDERS"
        },
        {
          "limit": 10,
          "filterType": "MAX_NUM_ALGO_ORDERS"
        },
        {
          "notional": "10",
          "filterType": "MIN_NOTIONAL"
        },
        {
          "multiplierDown": "0.9500",
          "multiplierUp": "1.0500",
          "multiplierDecimal": "4",
          "filterType": "PERCENT_PRICE"
        }
      ],
      "orderTypes": [
        "LIMIT",
        "MARKET",
        "STOP",
        "STOP_MARKET",
        "TAKE_PROFIT",
        "TAKE_PROFIT_MARKET",
        "TRAILING_STOP_MARKET"
      ],
      "timeInForce": [
        "GTC",
        "IOC",
        "FOK",
        "GTX"
      ]
    }
  ]
}
</document_content>
</document>
<document index="2521">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_funding_rate.json</source>
<document_content>
[
  {
    "symbol": "BTCUSDT",
    "fundingRate": "-0.03750000",
    "fundingTime": 1570608000000
  },
  {
    "symbol": "BTCUSDT",
    "fundingRate": "0.00010000",
    "fundingTime": 1570636800000
  }
]
</document_content>
</document>
<document index="2522">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_global_long_short_account_ratio.json</source>
<document_content>
[
  {
    "symbol": "BTCUSDT",
    "longShortRatio": "0.1960",
    "longAccount": "0.6622",
    "shortAccount": "0.3378",
    "timestamp": "1583139600000"
  },
  {
    "symbol": "BTCUSDT",
    "longShortRatio": "1.9559",
    "longAccount": "0.6617",
    "shortAccount": "0.3382",
    "timestamp": "1583139900000"
  }
]
</document_content>
</document>
<document index="2523">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_historical_trades.json</source>
<document_content>
[
  {
    "id": 28457,
    "price": "4.00000100",
    "qty": "12.00000000",
    "quoteQty": "8000.00",
    "time": 1499865549590,
    "isBuyerMaker": true
  }
]
</document_content>
</document>
<document index="2524">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_index_info.json</source>
<document_content>
[
  {
    "symbol": "DEFIUSDT",
    "time": 1589437530011,
    "component": "baseAsset",
    "baseAssetList": [
      {
        "baseAsset": "BAL",
        "quoteAsset": "USDT",
        "weightInQuantity": "1.04406228",
        "weightInPercentage": "0.02783900"
      },
      {
        "baseAsset": "BAND",
        "quoteAsset": "USDT",
        "weightInQuantity": "3.53782729",
        "weightInPercentage": "0.03935200"
      }
    ]
  }
]
</document_content>
</document>
<document index="2525">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_index_price_klines.json</source>
<document_content>
[
  [
    1591256400000,
    "9653.69440000",
    "9653.69640000",
    "9651.38600000",
    "9651.55200000",
    "0",
    1591256459999,
    "0",
    60,
    "0",
    "0",
    "0"
  ]
]
</document_content>
</document>
<document index="2526">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_klines.json</source>
<document_content>
[
  [
    1499040000000,
    "0.01634790",
    "0.80000000",
    "0.01575800",
    "0.01577100",
    "148976.11427815",
    1499644799999,
    "2434.19055334",
    308,
    "1756.87402397",
    "28.46694368",
    "17928899.62484339"
  ]
]
</document_content>
</document>
<document index="2527">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_mark_price_klines.json</source>
<document_content>
[
  [
    1591256460000,
    "9653.29201333",
    "9654.56401333",
    "9653.07367333",
    "9653.07367333",
    "0",
    1591256519999,
    "0",
    60,
    "0",
    "0",
    "0"
  ]
]
</document_content>
</document>
<document index="2528">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_open_interest.json</source>
<document_content>
{
  "openInterest": "10659.509",
  "symbol": "BTCUSDT",
  "time": 1589437530011
}
</document_content>
</document>
<document index="2529">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_open_interest_historical.json</source>
<document_content>
[
  {
    "symbol": "BTCUSDT",
    "sumOpenInterest": "20403.63700000",
    "sumOpenInterestValue": "150570784.07809979",
    "timestamp": "1583127900000"
  },
  {
    "symbol": "BTCUSDT",
    "sumOpenInterest": "20401.36700000",
    "sumOpenInterestValue": "149940752.14464448",
    "timestamp": "1583128200000"
  }
]
</document_content>
</document>
<document index="2530">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_premium_index.json</source>
<document_content>
{
  "symbol": "BTCUSDT",
  "markPrice": "11793.63104562",
  "indexPrice": "11781.80495970",
  "estimatedSettlePrice": "11781.16138815",
  "lastFundingRate": "0.00038246",
  "nextFundingTime": 1597392000000,
  "interestRate": "0.00010000",
  "time": 1597370495002
}
</document_content>
</document>
<document index="2531">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_taker_long_short_ratio.json</source>
<document_content>
[
  {
    "buySellRatio": "1.5586",
    "buyVol": "387.3300",
    "sellVol": "248.5030",
    "timestamp": "1585614900000"
  },
  {
    "buySellRatio": "1.3104",
    "buyVol": "343.9290",
    "sellVol": "248.5030",
    "timestamp": "1583139900000"
  }
]
</document_content>
</document>
<document index="2532">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_ticker_24hr.json</source>
<document_content>
{
  "symbol": "BTCUSDT",
  "priceChange": "-94.99999800",
  "priceChangePercent": "-95.960",
  "weightedAvgPrice": "0.29628482",
  "lastPrice": "4.00000200",
  "lastQty": "200.00000000",
  "openPrice": "99.00000000",
  "highPrice": "100.00000000",
  "lowPrice": "0.10000000",
  "volume": "8913.30000000",
  "quoteVolume": "15.30000000",
  "openTime": 1499783499040,
  "closeTime": 1499869899040,
  "firstId": 28385,
  "lastId": 28460,
  "count": 76
}
</document_content>
</document>
<document index="2533">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_ticker_price.json</source>
<document_content>
{
  "symbol": "BTCUSDT",
  "price": "6000.01",
  "time": 1589437530011
}
</document_content>
</document>
<document index="2534">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_top_long_short_account_ratio.json</source>
<document_content>
[
  {
    "symbol": "BTCUSDT",
    "longShortRatio": "1.8105",
    "longAccount": "0.6442",
    "shortAccount": "0.3558",
    "timestamp": "1583139600000"
  },
  {
    "symbol": "BTCUSDT",
    "longShortRatio": "0.5576",
    "longAccount": "0.3580",
    "shortAccount": "0.6420",
    "timestamp": "1583139900000"
  }
]
</document_content>
</document>
<document index="2535">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_top_long_short_position_ratio.json</source>
<document_content>
[
  {
    "symbol": "BTCUSDT",
    "longShortRatio": "1.4342",
    "longAccount": "0.5891",
    "shortAccount": "0.4108",
    "timestamp": "1583139600000"
  },
  {
    "symbol": "BTCUSDT",
    "longShortRatio": "1.4337",
    "longAccount": "0.3583",
    "shortAccount": "0.6417",
    "timestamp": "1583139900000"
  }
]
</document_content>
</document>
<document index="2536">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_futures_market_trades.json</source>
<document_content>
[
  {
    "id": 28457,
    "price": "4.00000100",
    "qty": "12.00000000",
    "quoteQty": "48.00",
    "time": 1499865549590,
    "isBuyerMaker": true
  }
]
</document_content>
</document>
<document index="2537">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_spot_market_agg_trades.json</source>
<document_content>
[
  {
    "a": 966492862,
    "p": "60759.60000000",
    "q": "0.00841000",
    "f": 1111480471,
    "l": 1111480471,
    "T": 1634944096633,
    "m": false,
    "M": true
  },
  {
    "a": 966492863,
    "p": "60759.60000000",
    "q": "0.00189000",
    "f": 1111480472,
    "l": 1111480472,
    "T": 1634944096848,
    "m": false,
    "M": true
  },
  {
    "a": 966492864,
    "p": "60759.59000000",
    "q": "0.00037000",
    "f": 1111480473,
    "l": 1111480473,
    "T": 1634944096877,
    "m": true,
    "M": true
  },
  {
    "a": 966492865,
    "p": "60759.60000000",
    "q": "0.00100000",
    "f": 1111480474,
    "l": 1111480474,
    "T": 1634944096878,
    "m": false,
    "M": true
  },
  {
    "a": 966492866,
    "p": "60759.60000000",
    "q": "0.00431000",
    "f": 1111480475,
    "l": 1111480475,
    "T": 1634944097038,
    "m": false,
    "M": true
  },
  {
    "a": 966492867,
    "p": "60759.60000000",
    "q": "0.00100000",
    "f": 1111480476,
    "l": 1111480476,
    "T": 1634944097501,
    "m": false,
    "M": true
  },
  {
    "a": 966492868,
    "p": "60759.60000000",
    "q": "0.00100000",
    "f": 1111480477,
    "l": 1111480477,
    "T": 1634944097857,
    "m": false,
    "M": true
  },
  {
    "a": 966492869,
    "p": "60759.59000000",
    "q": "0.00033000",
    "f": 1111480478,
    "l": 1111480478,
    "T": 1634944098082,
    "m": true,
    "M": true
  },
  {
    "a": 966492870,
    "p": "60759.59000000",
    "q": "0.00017000",
    "f": 1111480479,
    "l": 1111480479,
    "T": 1634944098130,
    "m": true,
    "M": true
  },
  {
    "a": 966492871,
    "p": "60759.60000000",
    "q": "0.00100000",
    "f": 1111480480,
    "l": 1111480480,
    "T": 1634944098216,
    "m": false,
    "M": true
  }
]
</document_content>
</document>
<document index="2538">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_spot_market_avg_price.json</source>
<document_content>
{
  "mins": 5,
  "price": "60753.92405551"
}
</document_content>
</document>
<document index="2539">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_spot_market_book_ticker.json</source>
<document_content>
{
  "symbol": "BTCUSDT",
  "bidPrice": "60741.67000000",
  "bidQty": "0.36580000",
  "askPrice": "60741.68000000",
  "askQty": "0.45178000"
}
</document_content>
</document>
<document index="2540">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_spot_market_depth.json</source>
<document_content>
{
  "lastUpdateId": 14527958487,
  "bids": [
    [
      "60650.00000000",
      "0.00213000"
    ],
    [
      "60648.08000000",
      "0.06346000"
    ],
    [
      "60648.01000000",
      "0.06430000"
    ],
    [
      "60648.00000000",
      "0.09332000"
    ],
    [
      "60647.53000000",
      "0.19622000"
    ],
    [
      "60647.52000000",
      "0.03000000"
    ],
    [
      "60646.55000000",
      "0.06431000"
    ],
    [
      "60643.57000000",
      "0.08904000"
    ],
    [
      "60643.56000000",
      "0.00203000"
    ],
    [
      "60639.93000000",
      "0.07282000"
    ]
  ],
  "asks": [
    [
      "60650.01000000",
      "0.61982000"
    ],
    [
      "60653.68000000",
      "0.00696000"
    ],
    [
      "60653.69000000",
      "0.00026000"
    ],
    [
      "60656.89000000",
      "0.01000000"
    ],
    [
      "60657.87000000",
      "0.02000000"
    ],
    [
      "60657.99000000",
      "0.04993000"
    ],
    [
      "60658.00000000",
      "0.02000000"
    ],
    [
      "60659.00000000",
      "0.12244000"
    ],
    [
      "60659.71000000",
      "0.35691000"
    ],
    [
      "60659.94000000",
      "0.96170000"
    ]
  ]
}
</document_content>
</document>
<document index="2541">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_spot_market_exchange_info.json</source>
<document_content>
{
  "timezone": "UTC",
  "serverTime": 1634942465856,
  "rateLimits": [
    {
      "rateLimitType": "REQUEST_WEIGHT",
      "interval": "MINUTE",
      "intervalNum": 1,
      "limit": 1200
    },
    {
      "rateLimitType": "ORDERS",
      "interval": "SECOND",
      "intervalNum": 10,
      "limit": 50
    },
    {
      "rateLimitType": "ORDERS",
      "interval": "DAY",
      "intervalNum": 1,
      "limit": 160000
    },
    {
      "rateLimitType": "RAW_REQUESTS",
      "interval": "MINUTE",
      "intervalNum": 5,
      "limit": 6100
    }
  ],
  "exchangeFilters": [],
  "symbols": [
    {
      "symbol": "BTCUSDT",
      "status": "TRADING",
      "baseAsset": "BTC",
      "baseAssetPrecision": 8,
      "quoteAsset": "USDT",
      "quotePrecision": 8,
      "quoteAssetPrecision": 8,
      "baseCommissionPrecision": 8,
      "quoteCommissionPrecision": 8,
      "orderTypes": [
        "LIMIT",
        "LIMIT_MAKER",
        "MARKET",
        "STOP_LOSS_LIMIT",
        "TAKE_PROFIT_LIMIT"
      ],
      "icebergAllowed": true,
      "ocoAllowed": true,
      "quoteOrderQtyMarketAllowed": true,
      "isSpotTradingAllowed": true,
      "isMarginTradingAllowed": true,
      "filters": [
        {
          "filterType": "PRICE_FILTER",
          "minPrice": "0.01000000",
          "maxPrice": "1000000.00000000",
          "tickSize": "0.01000000"
        },
        {
          "filterType": "PERCENT_PRICE",
          "multiplierUp": "5",
          "multiplierDown": "0.2",
          "avgPriceMins": 5
        },
        {
          "filterType": "LOT_SIZE",
          "minQty": "0.00001000",
          "maxQty": "9000.00000000",
          "stepSize": "0.00001000"
        },
        {
          "filterType": "MIN_NOTIONAL",
          "minNotional": "10.00000000",
          "applyToMarket": true,
          "avgPriceMins": 5
        },
        {
          "filterType": "ICEBERG_PARTS",
          "limit": 10
        },
        {
          "filterType": "MARKET_LOT_SIZE",
          "minQty": "0.00000000",
          "maxQty": "112.21108820",
          "stepSize": "0.00000000"
        },
        {
          "filterType": "MAX_NUM_ORDERS",
          "maxNumOrders": 200
        },
        {
          "filterType": "MAX_NUM_ALGO_ORDERS",
          "maxNumAlgoOrders": 5
        }
      ],
      "permissions": [
        "SPOT",
        "MARGIN"
      ]
    },
    {
      "symbol": "ETHUSDT",
      "status": "TRADING",
      "baseAsset": "ETH",
      "baseAssetPrecision": 8,
      "quoteAsset": "USDT",
      "quotePrecision": 8,
      "quoteAssetPrecision": 8,
      "baseCommissionPrecision": 8,
      "quoteCommissionPrecision": 8,
      "orderTypes": [
        "LIMIT",
        "LIMIT_MAKER",
        "MARKET",
        "STOP_LOSS_LIMIT",
        "TAKE_PROFIT_LIMIT"
      ],
      "icebergAllowed": true,
      "ocoAllowed": true,
      "quoteOrderQtyMarketAllowed": true,
      "isSpotTradingAllowed": true,
      "isMarginTradingAllowed": true,
      "filters": [
        {
          "filterType": "PRICE_FILTER",
          "minPrice": "0.01000000",
          "maxPrice": "1000000.00000000",
          "tickSize": "0.01000000"
        },
        {
          "filterType": "PERCENT_PRICE",
          "multiplierUp": "5",
          "multiplierDown": "0.2",
          "avgPriceMins": 5
        },
        {
          "filterType": "LOT_SIZE",
          "minQty": "0.00010000",
          "maxQty": "9000.00000000",
          "stepSize": "0.00010000"
        },
        {
          "filterType": "MIN_NOTIONAL",
          "minNotional": "10.00000000",
          "applyToMarket": true,
          "avgPriceMins": 5
        },
        {
          "filterType": "ICEBERG_PARTS",
          "limit": 10
        },
        {
          "filterType": "MARKET_LOT_SIZE",
          "minQty": "0.00000000",
          "maxQty": "1630.44517663",
          "stepSize": "0.00000000"
        },
        {
          "filterType": "MAX_NUM_ORDERS",
          "maxNumOrders": 200
        },
        {
          "filterType": "MAX_NUM_ALGO_ORDERS",
          "maxNumAlgoOrders": 5
        }
      ],
      "permissions": [
        "SPOT",
        "MARGIN"
      ]
    }
  ]
}
</document_content>
</document>
<document index="2542">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_spot_market_historical_trades.json</source>
<document_content>
[
  {
    "id": 1111471896,
    "price": "60814.78000000",
    "qty": "0.00034000",
    "quoteQty": "20.67702520",
    "time": 1634943219887,
    "isBuyerMaker": true,
    "isBestMatch": true
  },
  {
    "id": 1111471897,
    "price": "60814.79000000",
    "qty": "0.00300000",
    "quoteQty": "182.44437000",
    "time": 1634943219918,
    "isBuyerMaker": false,
    "isBestMatch": true
  },
  {
    "id": 1111471898,
    "price": "60814.79000000",
    "qty": "0.00120000",
    "quoteQty": "72.97774800",
    "time": 1634943219918,
    "isBuyerMaker": false,
    "isBestMatch": true
  },
  {
    "id": 1111471899,
    "price": "60816.08000000",
    "qty": "0.01100000",
    "quoteQty": "668.97688000",
    "time": 1634943219918,
    "isBuyerMaker": false,
    "isBestMatch": true
  },
  {
    "id": 1111471900,
    "price": "60817.45000000",
    "qty": "0.00024000",
    "quoteQty": "14.59618800",
    "time": 1634943219918,
    "isBuyerMaker": false,
    "isBestMatch": true
  },
  {
    "id": 1111471901,
    "price": "60818.18000000",
    "qty": "0.03456000",
    "quoteQty": "2101.87630080",
    "time": 1634943219918,
    "isBuyerMaker": false,
    "isBestMatch": true
  },
  {
    "id": 1111471902,
    "price": "60818.10000000",
    "qty": "0.00312000",
    "quoteQty": "189.75247200",
    "time": 1634943219933,
    "isBuyerMaker": true,
    "isBestMatch": true
  },
  {
    "id": 1111471903,
    "price": "60818.18000000",
    "qty": "0.00893000",
    "quoteQty": "543.10634740",
    "time": 1634943219985,
    "isBuyerMaker": true,
    "isBestMatch": true
  },
  {
    "id": 1111471904,
    "price": "60818.18000000",
    "qty": "0.00465000",
    "quoteQty": "282.80453700",
    "time": 1634943220037,
    "isBuyerMaker": true,
    "isBestMatch": true
  },
  {
    "id": 1111471905,
    "price": "60814.79000000",
    "qty": "0.06902000",
    "quoteQty": "4197.43680580",
    "time": 1634943220769,
    "isBuyerMaker": false,
    "isBestMatch": true
  }
]
</document_content>
</document>
<document index="2543">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_spot_market_klines.json</source>
<document_content>
[
  [
    1634943780000,
    "60685.22000000",
    "60729.84000000",
    "60670.90000000",
    "60719.27000000",
    "21.63272000",
    1634943839999,
    "1313200.01340410",
    617,
    "12.28492000",
    "745719.41022840",
    "0"
  ],
  [
    1634943840000,
    "60719.28000000",
    "60780.41000000",
    "60707.00000000",
    "60771.81000000",
    "21.91797000",
    1634943899999,
    "1331667.75064580",
    769,
    "11.54481000",
    "701336.15460230",
    "0"
  ],
  [
    1634943900000,
    "60773.18000000",
    "60799.13000000",
    "60745.24000000",
    "60768.71000000",
    "15.38660000",
    1634943959999,
    "935075.44683130",
    722,
    "8.00939000",
    "486770.65274100",
    "0"
  ],
  [
    1634943960000,
    "60768.71000000",
    "60807.52000000",
    "60756.51000000",
    "60786.56000000",
    "12.67640000",
    1634944019999,
    "770557.36364250",
    673,
    "7.76431000",
    "471949.75356410",
    "0"
  ],
  [
    1634944020000,
    "60786.55000000",
    "60787.15000000",
    "60756.07000000",
    "60759.65000000",
    "8.13593000",
    1634944079999,
    "494393.78819910",
    491,
    "4.47881000",
    "272159.74054760",
    "0"
  ],
  [
    1634944080000,
    "60762.99000000",
    "60778.81000000",
    "60734.58000000",
    "60774.88000000",
    "10.90120000",
    1634944139999,
    "662331.06213830",
    593,
    "7.59992000",
    "461754.80405980",
    "0"
  ],
  [
    1634944140000,
    "60774.88000000",
    "60787.69000000",
    "60758.92000000",
    "60776.64000000",
    "4.72517000",
    1634944199999,
    "287163.77238330",
    393,
    "1.54229000",
    "93731.58578990",
    "0"
  ],
  [
    1634944200000,
    "60776.63000000",
    "60776.63000000",
    "60723.78000000",
    "60738.58000000",
    "7.94426000",
    1634944259999,
    "482551.20781590",
    414,
    "3.85428000",
    "234118.43306360",
    "0"
  ],
  [
    1634944260000,
    "60740.00000000",
    "60765.48000000",
    "60725.00000000",
    "60739.85000000",
    "5.31675000",
    1634944319999,
    "322972.88368840",
    375,
    "2.80953000",
    "170666.05221680",
    "0"
  ],
  [
    1634944320000,
    "60739.85000000",
    "60739.85000000",
    "60739.85000000",
    "60739.85000000",
    "0.04734000",
    1634944379999,
    "2875.42449900",
    7,
    "0.04734000",
    "2875.42449900",
    "0"
  ]
]
</document_content>
</document>
<document index="2544">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_spot_market_ping.json</source>
<document_content>
{}
</document_content>
</document>
<document index="2545">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_spot_market_ticker_price.json</source>
<document_content>
{
  "symbol": "BTCUSDT",
  "price": "60740.00000000"
}
</document_content>
</document>
<document index="2546">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_spot_market_time.json</source>
<document_content>
{
  "serverTime": 1633835466289
}
</document_content>
</document>
<document index="2547">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_spot_market_trades.json</source>
<document_content>
[
  {
    "id": 1111468873,
    "price": "60650.00000000",
    "qty": "0.02924000",
    "quoteQty": "1773.40600000",
    "time": 1634942949263,
    "isBuyerMaker": true,
    "isBestMatch": true
  },
  {
    "id": 1111468874,
    "price": "60650.01000000",
    "qty": "0.00082000",
    "quoteQty": "49.73300820",
    "time": 1634942949287,
    "isBuyerMaker": false,
    "isBestMatch": true
  },
  {
    "id": 1111468875,
    "price": "60650.01000000",
    "qty": "0.01100000",
    "quoteQty": "667.15011000",
    "time": 1634942949583,
    "isBuyerMaker": false,
    "isBestMatch": true
  },
  {
    "id": 1111468876,
    "price": "60650.00000000",
    "qty": "0.00738000",
    "quoteQty": "447.59700000",
    "time": 1634942949873,
    "isBuyerMaker": true,
    "isBestMatch": true
  },
  {
    "id": 1111468877,
    "price": "60650.01000000",
    "qty": "0.00025000",
    "quoteQty": "15.16250250",
    "time": 1634942949950,
    "isBuyerMaker": false,
    "isBestMatch": true
  },
  {
    "id": 1111468878,
    "price": "60650.02000000",
    "qty": "0.00100000",
    "quoteQty": "60.65002000",
    "time": 1634942949950,
    "isBuyerMaker": false,
    "isBestMatch": true
  },
  {
    "id": 1111468879,
    "price": "60655.00000000",
    "qty": "0.01100000",
    "quoteQty": "667.20500000",
    "time": 1634942949950,
    "isBuyerMaker": false,
    "isBestMatch": true
  },
  {
    "id": 1111468880,
    "price": "60654.99000000",
    "qty": "0.00623000",
    "quoteQty": "377.88058770",
    "time": 1634942949986,
    "isBuyerMaker": true,
    "isBestMatch": true
  },
  {
    "id": 1111468881,
    "price": "60654.99000000",
    "qty": "0.00445000",
    "quoteQty": "269.91470550",
    "time": 1634942950034,
    "isBuyerMaker": true,
    "isBestMatch": true
  },
  {
    "id": 1111468882,
    "price": "60654.99000000",
    "qty": "0.00997000",
    "quoteQty": "604.73025030",
    "time": 1634942950067,
    "isBuyerMaker": true,
    "isBestMatch": true
  }
]
</document_content>
</document>
<document index="2548">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_spot_streams_listen_key.json</source>
<document_content>
{
  "listenKey": "pqia91ma19a5s61cv6a81va65sdf19v8a65a1a5s61cv6a81va65sdf19v8a65a1"
}
</document_content>
</document>
<document index="2549">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_spot_wallet_account.json</source>
<document_content>
{
  "makerCommission": 15,
  "takerCommission": 15,
  "buyerCommission": 0,
  "sellerCommission": 0,
  "canTrade": true,
  "canWithdraw": true,
  "canDeposit": true,
  "updateTime": 123456789,
  "accountType": "SPOT",
  "balances": [
    {
      "asset": "BTC",
      "free": "4723846.89208129",
      "locked": "0.00000000"
    },
    {
      "asset": "LTC",
      "free": "4763368.68006011",
      "locked": "0.00000000"
    }
  ],
  "permissions": [
    "SPOT"
  ]
}
</document_content>
</document>
<document index="2550">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_wallet_trading_fee.json</source>
<document_content>
{
  "symbol": "BTCUSDT",
  "makerCommission": "0.001",
  "takerCommission": "0.001"
}
</document_content>
</document>
<document index="2551">
<source>tests/integration_tests/adapters/binance/resources/http_responses/http_wallet_trading_fees.json</source>
<document_content>
[
  {
    "symbol": "BTCUSDT",
    "makerCommission": "0.001",
    "takerCommission": "0.001"
  },
  {
    "symbol": "ETHUSDT",
    "makerCommission": "0.001",
    "takerCommission": "0.001"
  }
]
</document_content>
</document>
<document index="2552">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="2553">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_futures_book_ticker.json</source>
<document_content>
{
  "e":"bookTicker",
  "u":400900217,
  "E": 1568014460893,
  "T": 1568014460891,
  "s":"BNBUSDT",
  "b":"25.35190000",
  "B":"31.21000000",
  "a":"25.36520000",
  "A":"40.66000000"
}
</document_content>
</document>
<document index="2554">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_futures_depth_diff_update.json</source>
<document_content>
{
  "e": "depthUpdate",
  "E": 123456789,
  "T": 123456788,
  "s": "BTCUSDT",
  "U": 157,
  "u": 160,
  "pu": 149,
  "b": [
    [
      "0.0024",
      "10"
    ]
  ],
  "a": [
    [
      "0.0026",
      "100"
    ]
  ]
}
</document_content>
</document>
<document index="2555">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_futures_depth_update.json</source>
<document_content>
{
  "e": "depthUpdate",
  "E": 1571889248277,
  "T": 1571889248276,
  "s": "BTCUSDT",
  "U": 390497796,
  "u": 390497878,
  "pu": 390497794,
  "b": [
    [
      "7403.89",
      "0.002"
    ],
    [
      "7403.90",
      "3.906"
    ],
    [
      "7404.00",
      "1.428"
    ],
    [
      "7404.85",
      "5.239"
    ],
    [
      "7405.43",
      "2.562"
    ]
  ],
  "a": [
    [
      "7405.96",
      "3.340"
    ],
    [
      "7406.63",
      "4.525"
    ],
    [
      "7407.08",
      "2.475"
    ],
    [
      "7407.15",
      "4.800"
    ],
    [
      "7407.20",
      "0.175"
    ]
  ]
}
</document_content>
</document>
<document index="2556">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_futures_order_update_adl.json</source>
<document_content>
{
  "stream": "ORDER_TRADE_UPDATE",
  "data": {
    "e": "ORDER_TRADE_UPDATE",
    "E": 1759347763200,
    "T": 1759347763200,
    "o": {
      "s": "ETHUSDT",
      "c": "adl_autoclose",
      "S": "BUY",
      "o": "MARKET",
      "f": "GTC",
      "q": "1.000",
      "p": "0",
      "ap": "2500.00",
      "sp": null,
      "x": "CALCULATED",
      "X": "FILLED",
      "i": 8765432109,
      "l": "1.000",
      "z": "1.000",
      "L": "2500.00",
      "N": "USDT",
      "n": "2.50000000",
      "T": 1759347763200,
      "t": 2233445566,
      "b": "0",
      "a": "0",
      "m": false,
      "R": false,
      "wt": "CONTRACT_PRICE",
      "ot": "MARKET",
      "ps": "SHORT",
      "cp": false,
      "AP": null,
      "cr": null,
      "pP": false,
      "si": 0,
      "ss": 0,
      "rp": "50.00",
      "gtd": 0,
      "W": null,
      "V": null
    }
  }
}
</document_content>
</document>
<document index="2557">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_futures_order_update_liquidation.json</source>
<document_content>
{
  "stream": "ORDER_TRADE_UPDATE",
  "data": {
    "e": "ORDER_TRADE_UPDATE",
    "E": 1759347763167,
    "T": 1759347763167,
    "o": {
      "s": "BTCUSDT",
      "c": "autoclose-1234567890123456",
      "S": "SELL",
      "o": "MARKET",
      "f": "GTC",
      "q": "0.100",
      "p": "0",
      "ap": "50000.00",
      "sp": null,
      "x": "CALCULATED",
      "X": "FILLED",
      "i": 9876543210,
      "l": "0.100",
      "z": "0.100",
      "L": "50000.00",
      "N": "USDT",
      "n": "5.00000000",
      "T": 1759347763167,
      "t": 1122334455,
      "b": "0",
      "a": "0",
      "m": false,
      "R": false,
      "wt": "CONTRACT_PRICE",
      "ot": "MARKET",
      "ps": "LONG",
      "cp": false,
      "AP": null,
      "cr": null,
      "pP": false,
      "si": 0,
      "ss": 0,
      "rp": "-100.00",
      "gtd": 0,
      "W": null,
      "V": null
    }
  }
}
</document_content>
</document>
<document index="2558">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_futures_order_update_liquidation_zero_qty.json</source>
<document_content>
{
  "stream": "ORDER_TRADE_UPDATE",
  "data": {
    "e": "ORDER_TRADE_UPDATE",
    "E": 1759347763250,
    "T": 1759347763250,
    "o": {
      "s": "BTCUSDT",
      "c": "autoclose-7654321098765432",
      "S": "SELL",
      "o": "MARKET",
      "f": "GTC",
      "q": "0.000",
      "p": "0",
      "ap": "0.00",
      "sp": null,
      "x": "CALCULATED",
      "X": "FILLED",
      "i": 7654321098,
      "l": "0.000",
      "z": "0.000",
      "L": "0.00",
      "N": null,
      "n": null,
      "T": 1759347763250,
      "t": 3344556677,
      "b": "0",
      "a": "0",
      "m": false,
      "R": false,
      "wt": "CONTRACT_PRICE",
      "ot": "MARKET",
      "ps": "LONG",
      "cp": false,
      "AP": null,
      "cr": null,
      "pP": false,
      "si": 0,
      "ss": 0,
      "rp": "0.00",
      "gtd": 0,
      "W": null,
      "V": null
    }
  }
}
</document_content>
</document>
<document index="2559">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_futures_order_update_new_limit_if_touched_price_match.json</source>
<document_content>
{
  "stream": "ORDER_TRADE_UPDATE",
  "data": {
    "e": "ORDER_TRADE_UPDATE",
    "E": 1759347763200,
    "T": 1759347763200,
    "o": {
      "s": "ETHUSDT",
      "c": "O-12345-test-limit-if-touched-price-match",
      "S": "BUY",
      "o": "TAKE_PROFIT",
      "f": "GTC",
      "q": "1.000",
      "p": "2505.25",
      "ap": "0.00",
      "sp": "2500.00",
      "x": "NEW",
      "X": "NEW",
      "i": 8765432102,
      "l": "0.000",
      "z": "0.000",
      "L": "0.00",
      "N": null,
      "n": null,
      "T": 1759347763200,
      "t": 0,
      "b": "0",
      "a": "0",
      "m": false,
      "R": false,
      "wt": "CONTRACT_PRICE",
      "ot": "TAKE_PROFIT",
      "ps": "LONG",
      "cp": false,
      "AP": null,
      "cr": null,
      "pP": false,
      "si": 0,
      "ss": 0,
      "rp": "0.00",
      "gtd": 0,
      "W": 1759347763200,
      "V": null
    }
  }
}
</document_content>
</document>
<document index="2560">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_futures_order_update_new_price_match.json</source>
<document_content>
{
  "stream": "ORDER_TRADE_UPDATE",
  "data": {
    "e": "ORDER_TRADE_UPDATE",
    "E": 1759347763200,
    "T": 1759347763200,
    "o": {
      "s": "ETHUSDT",
      "c": "O-12345-test-price-match",
      "S": "BUY",
      "o": "LIMIT",
      "f": "GTC",
      "q": "1.000",
      "p": "2495.50",
      "ap": "0.00",
      "sp": "0",
      "x": "NEW",
      "X": "NEW",
      "i": 8765432100,
      "l": "0.000",
      "z": "0.000",
      "L": "0.00",
      "N": null,
      "n": null,
      "T": 1759347763200,
      "t": 0,
      "b": "0",
      "a": "0",
      "m": false,
      "R": false,
      "wt": "CONTRACT_PRICE",
      "ot": "LIMIT",
      "ps": "LONG",
      "cp": false,
      "AP": null,
      "cr": null,
      "pP": false,
      "si": 0,
      "ss": 0,
      "rp": "0.00",
      "gtd": 0,
      "W": 1759347763200,
      "V": null
    }
  }
}
</document_content>
</document>
<document index="2561">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_futures_order_update_new_stop_limit_price_match.json</source>
<document_content>
{
  "stream": "ORDER_TRADE_UPDATE",
  "data": {
    "e": "ORDER_TRADE_UPDATE",
    "E": 1759347763200,
    "T": 1759347763200,
    "o": {
      "s": "ETHUSDT",
      "c": "O-12345-test-stop-limit-price-match",
      "S": "SELL",
      "o": "STOP",
      "f": "GTC",
      "q": "1.000",
      "p": "2405.75",
      "ap": "0.00",
      "sp": "2400.00",
      "x": "NEW",
      "X": "NEW",
      "i": 8765432101,
      "l": "0.000",
      "z": "0.000",
      "L": "0.00",
      "N": null,
      "n": null,
      "T": 1759347763200,
      "t": 0,
      "b": "0",
      "a": "0",
      "m": false,
      "R": false,
      "wt": "CONTRACT_PRICE",
      "ot": "STOP",
      "ps": "SHORT",
      "cp": false,
      "AP": null,
      "cr": null,
      "pP": false,
      "si": 0,
      "ss": 0,
      "rp": "0.00",
      "gtd": 0,
      "W": 1759347763200,
      "V": null
    }
  }
}
</document_content>
</document>
<document index="2562">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_futures_order_update_settlement.json</source>
<document_content>
{
  "stream": "ORDER_TRADE_UPDATE",
  "data": {
    "e": "ORDER_TRADE_UPDATE",
    "E": 1759347763300,
    "T": 1759347763300,
    "o": {
      "s": "BTCUSDT",
      "c": "settlement_autoclose-1111222233334444",
      "S": "BUY",
      "o": "MARKET",
      "f": "GTC",
      "q": "0.050",
      "p": "0",
      "ap": "51000.00",
      "sp": null,
      "x": "CALCULATED",
      "X": "FILLED",
      "i": 6543210987,
      "l": "0.050",
      "z": "0.050",
      "L": "51000.00",
      "N": "USDT",
      "n": "2.55000000",
      "T": 1759347763300,
      "t": 4455667788,
      "b": "0",
      "a": "0",
      "m": false,
      "R": false,
      "wt": "CONTRACT_PRICE",
      "ot": "MARKET",
      "ps": "SHORT",
      "cp": false,
      "AP": null,
      "cr": null,
      "pP": false,
      "si": 0,
      "ss": 0,
      "rp": "25.00",
      "gtd": 0,
      "W": null,
      "V": null
    }
  }
}
</document_content>
</document>
<document index="2563">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_futures_ticker_24hr.json</source>
<document_content>
{
  "e": "24hrTicker",
  "E": 123456789,
  "s": "BTCUSDT",
  "p": "0.0015",
  "P": "250.00",
  "w": "0.0018",
  "c": "0.0025",
  "Q": "10",
  "o": "0.0010",
  "h": "0.0025",
  "l": "0.0010",
  "v": "10000",
  "q": "18",
  "O": 0,
  "C": 86400000,
  "F": 0,
  "L": 18150,
  "n": 18151
}
</document_content>
</document>
<document index="2564">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_futures_trade_lite.json</source>
<document_content>
{
  "e": "TRADE_LITE",
  "E": 1727683915920,
  "T": 1727683915920,
  "s": "ETHUSDT",
  "q": "0.037",
  "p": "2631.90",
  "m": false,
  "c": "O-20240930-081155-001-000-29",
  "S": "BUY",
  "L": "2631.90",
  "l": "0.037",
  "t": 4467432841,
  "i": 8389765739703625592
}
</document_content>
</document>
<document index="2565">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_agg_trade.json</source>
<document_content>
{
  "stream":"ethusdt@aggTrade",
  "data":{
    "e":"aggTrade",
    "E":1675759520848,
    "s":"ETHUSDT",
    "a":226532,
    "p":"1632.46000000",
    "q":"0.34305000",
    "f":228423,
    "l":228423,
    "T":1675759520847,
    "m":false,
    "M":true
    }
}
</document_content>
</document>
<document index="2566">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_binance_us.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "BTCUSD",
    "c": "T0ESHzso0banw0QiPFZYgj",
    "S": "SELL",
    "o": "LIMIT",
    "f": "GTC",
    "q": "0.00042000",
    "p": "117290.77000000",
    "P": "0.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "TRADE",
    "X": "FILLED",
    "r": "NONE",
    "i": 2281896601,
    "l": "0.00042000",
    "z": "0.00042000",
    "L": "117290.77000000",
    "n": "0.00492621",
    "N": "USD",
    "T": 1759347763167,
    "t": 88685053,
    "I": 4644480641,
    "w": false,
    "m": false,
    "M": true,
    "O": 1759347763167,
    "Z": "49.26212340",
    "Y": "49.26212340",
    "Q": "0.00000000",
    "W": 1759347763167,
    "V": "EXPIRE_MAKER"
  }
}
</document_content>
</document>
<document index="2567">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_calculated.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "BTCUSDT",
    "c": "autoclose-123456789",
    "S": "SELL",
    "o": "LIMIT",
    "f": "GTC",
    "q": "0.01000000",
    "p": "50000.00000000",
    "P": "0.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "CALCULATED",
    "X": "FILLED",
    "r": "NONE",
    "i": 1234567890,
    "l": "0.01000000",
    "z": "0.01000000",
    "L": "49500.00000000",
    "n": "2.475",
    "N": "USDT",
    "T": 1759347763167,
    "t": 98765432,
    "I": 4644480641,
    "w": false,
    "m": false,
    "M": false,
    "O": 1759347763000,
    "Z": "495.00000000",
    "Y": "495.00000000",
    "Q": "0.00000000"
  }
}
</document_content>
</document>
<document index="2568">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_canceled.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "ETHUSDT",
    "c": "O-12345-test-cancel",
    "S": "SELL",
    "o": "LIMIT",
    "f": "GTC",
    "q": "0.50000000",
    "p": "2500.00000000",
    "P": "0.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "CANCELED",
    "X": "CANCELED",
    "r": "NONE",
    "i": 9876543210,
    "l": "0.00000000",
    "z": "0.10000000",
    "L": "0.00000000",
    "n": "0",
    "N": null,
    "T": 1759347763167,
    "t": -1,
    "I": 4644480641,
    "w": false,
    "m": false,
    "M": false,
    "O": 1759347763100,
    "Z": "250.00000000",
    "Y": "0.00000000",
    "Q": "0.00000000"
  }
}
</document_content>
</document>
<document index="2569">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_expired.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "BTCUSDT",
    "c": "O-12345-test-expired",
    "S": "BUY",
    "o": "LIMIT",
    "f": "GTD",
    "q": "0.01000000",
    "p": "50000.00000000",
    "P": "0.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "EXPIRED",
    "X": "EXPIRED",
    "r": "NONE",
    "i": 1234567891,
    "l": "0.00000000",
    "z": "0.00000000",
    "L": "0.00000000",
    "n": "0",
    "N": null,
    "T": 1759347763167,
    "t": -1,
    "I": 4644480641,
    "w": false,
    "m": false,
    "M": false,
    "O": 1759347763000,
    "Z": "0.00000000",
    "Y": "0.00000000",
    "Q": "0.00000000"
  }
}
</document_content>
</document>
<document index="2570">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_new.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "ETHUSDT",
    "c": "O-12345-test-new",
    "S": "BUY",
    "o": "LIMIT",
    "f": "GTC",
    "q": "1.00000000",
    "p": "2500.00000000",
    "P": "0.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "NEW",
    "X": "NEW",
    "r": "NONE",
    "i": 1234567890,
    "l": "0.00000000",
    "z": "0.00000000",
    "L": "0.00000000",
    "n": "0",
    "N": null,
    "T": 1759347763167,
    "t": -1,
    "I": 4644480641,
    "w": true,
    "m": false,
    "M": false,
    "O": 1759347763167,
    "Z": "0.00000000",
    "Y": "0.00000000",
    "Q": "0.00000000"
  }
}
</document_content>
</document>
<document index="2571">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_new_limit_if_touched_price_match.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "ETHUSDT",
    "c": "O-12345-test-limit-if-touched-price-match",
    "S": "BUY",
    "o": "TAKE_PROFIT_LIMIT",
    "f": "GTC",
    "q": "1.00000000",
    "p": "2505.25000000",
    "P": "2500.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "NEW",
    "X": "NEW",
    "r": "NONE",
    "i": 1234567892,
    "l": "0.00000000",
    "z": "0.00000000",
    "L": "0.00000000",
    "n": "0",
    "N": null,
    "T": 1759347763167,
    "t": -1,
    "I": 4644480643,
    "w": true,
    "m": false,
    "M": false,
    "O": 1759347763167,
    "Z": "0.00000000",
    "Y": "0.00000000",
    "Q": "0.00000000"
  }
}
</document_content>
</document>
<document index="2572">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_new_price_match.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "ETHUSDT",
    "c": "O-12345-test-price-match",
    "S": "BUY",
    "o": "LIMIT",
    "f": "GTC",
    "q": "1.00000000",
    "p": "2495.50000000",
    "P": "0.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "NEW",
    "X": "NEW",
    "r": "NONE",
    "i": 1234567890,
    "l": "0.00000000",
    "z": "0.00000000",
    "L": "0.00000000",
    "n": "0",
    "N": null,
    "T": 1759347763167,
    "t": -1,
    "I": 4644480641,
    "w": true,
    "m": false,
    "M": false,
    "O": 1759347763167,
    "Z": "0.00000000",
    "Y": "0.00000000",
    "Q": "0.00000000"
  }
}
</document_content>
</document>
<document index="2573">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_new_stop_limit_price_match.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "ETHUSDT",
    "c": "O-12345-test-stop-limit-price-match",
    "S": "SELL",
    "o": "STOP_LOSS_LIMIT",
    "f": "GTC",
    "q": "1.00000000",
    "p": "2405.75000000",
    "P": "2400.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "NEW",
    "X": "NEW",
    "r": "NONE",
    "i": 1234567891,
    "l": "0.00000000",
    "z": "0.00000000",
    "L": "0.00000000",
    "n": "0",
    "N": null,
    "T": 1759347763167,
    "t": -1,
    "I": 4644480642,
    "w": true,
    "m": false,
    "M": false,
    "O": 1759347763167,
    "Z": "0.00000000",
    "Y": "0.00000000",
    "Q": "0.00000000"
  }
}
</document_content>
</document>
<document index="2574">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_pending_cancel.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "ETHUSDT",
    "c": "O-12345-test-cancel",
    "S": "SELL",
    "o": "LIMIT",
    "f": "GTC",
    "q": "0.50000000",
    "p": "2500.00000000",
    "P": "0.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "CANCELED",
    "X": "PENDING_CANCEL",
    "r": "NONE",
    "i": 9876543210,
    "l": "0.00000000",
    "z": "0.10000000",
    "L": "0.00000000",
    "n": "0",
    "N": null,
    "T": 1759347763167,
    "t": -1,
    "I": 4644480641,
    "w": true,
    "m": false,
    "M": false,
    "O": 1759347763100,
    "Z": "250.00000000",
    "Y": "0.00000000",
    "Q": "0.00000000",
    "W": 1759347763100,
    "V": "NONE"
  }
}
</document_content>
</document>
<document index="2575">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_rejected.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "BTCUSDT",
    "c": "O-12345-test-reject",
    "S": "BUY",
    "o": "LIMIT",
    "f": "GTX",
    "q": "0.00100000",
    "p": "50000.00000000",
    "P": "0.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "REJECTED",
    "X": "REJECTED",
    "r": "GTX_ORDER_REJECT",
    "i": 1234567890,
    "l": "0.00000000",
    "z": "0.00000000",
    "L": "0.00000000",
    "n": "0",
    "N": null,
    "T": 1759347763167,
    "t": -1,
    "I": 4644480641,
    "w": false,
    "m": false,
    "M": false,
    "O": 1759347763167,
    "Z": "0.00000000",
    "Y": "0.00000000",
    "Q": "0.00000000",
    "W": 0,
    "V": "NONE"
  }
}
</document_content>
</document>
<document index="2576">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_trade.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "ETHUSDT",
    "c": "O-12345-test-trade",
    "S": "BUY",
    "o": "LIMIT",
    "f": "GTC",
    "q": "1.00000000",
    "p": "2500.00000000",
    "P": "0.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "TRADE",
    "X": "PARTIALLY_FILLED",
    "r": "NONE",
    "i": 1234567890,
    "l": "0.50000000",
    "z": "0.50000000",
    "L": "2499.50000000",
    "n": "0.00050000",
    "N": "ETH",
    "T": 1759347763167,
    "t": 98765432,
    "I": 4644480641,
    "w": true,
    "m": true,
    "M": false,
    "O": 1759347763100,
    "Z": "1249.75000000",
    "Y": "1249.75000000",
    "Q": "0.00000000"
  }
}
</document_content>
</document>
<document index="2577">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_trade_l_zero.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "ETHUSDT",
    "c": "O-12345-test-trade-l-zero",
    "S": "BUY",
    "o": "LIMIT",
    "f": "GTC",
    "q": "0.00100000",
    "p": "2500.00000000",
    "P": "0.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "TRADE",
    "X": "FILLED",
    "r": "NONE",
    "i": 1234567890,
    "l": "0.00100000",
    "z": "0.00100000",
    "L": "0.00000000",
    "n": "0",
    "N": null,
    "T": 1759347763167,
    "t": 12345678,
    "I": 4644480641,
    "w": false,
    "m": true,
    "M": false,
    "O": 1759347763167,
    "Z": "0.00000000",
    "Y": "0.00000000",
    "Q": "0.00000000",
    "W": 1759347763167,
    "V": "NONE"
  }
}
</document_content>
</document>
<document index="2578">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_trade_l_zero_canceled.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "ETHUSDT",
    "c": "O-12345-test-l-zero-canceled",
    "S": "BUY",
    "o": "LIMIT",
    "f": "GTC",
    "q": "0.00100000",
    "p": "2500.00000000",
    "P": "0.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "TRADE",
    "X": "CANCELED",
    "r": "NONE",
    "i": 1234567890,
    "l": "0.00000000",
    "z": "0.00000000",
    "L": "0.00000000",
    "n": "0",
    "N": null,
    "T": 1759347763167,
    "t": -1,
    "I": 4644480641,
    "w": false,
    "m": false,
    "M": false,
    "O": 1759347763167,
    "Z": "0.00000000",
    "Y": "0.00000000",
    "Q": "0.00000000",
    "W": 1759347763167,
    "V": "NONE"
  }
}
</document_content>
</document>
<document index="2579">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_trade_l_zero_expired.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "BTCUSDT",
    "c": "O-12345-test-l-zero-expired",
    "S": "BUY",
    "o": "LIMIT",
    "f": "GTD",
    "q": "0.01000000",
    "p": "50000.00000000",
    "P": "0.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "TRADE",
    "X": "EXPIRED",
    "r": "NONE",
    "i": 1234567891,
    "l": "0.00000000",
    "z": "0.00000000",
    "L": "0.00000000",
    "n": "0",
    "N": null,
    "T": 1759347763167,
    "t": -1,
    "I": 4644480641,
    "w": false,
    "m": false,
    "M": false,
    "O": 1759347763000,
    "Z": "0.00000000",
    "Y": "0.00000000",
    "Q": "0.00000000"
  }
}
</document_content>
</document>
<document index="2580">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_trade_l_zero_new.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "ETHUSDT",
    "c": "O-12345-test-l-zero-new",
    "S": "BUY",
    "o": "LIMIT",
    "f": "GTC",
    "q": "1.00000000",
    "p": "2500.00000000",
    "P": "0.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "TRADE",
    "X": "NEW",
    "r": "NONE",
    "i": 1234567890,
    "l": "0.00000000",
    "z": "0.00000000",
    "L": "0.00000000",
    "n": "0",
    "N": null,
    "T": 1759347763167,
    "t": -1,
    "I": 4644480641,
    "w": true,
    "m": false,
    "M": false,
    "O": 1759347763167,
    "Z": "0.00000000",
    "Y": "0.00000000",
    "Q": "0.00000000",
    "W": 1759347763167,
    "V": "NONE"
  }
}
</document_content>
</document>
<document index="2581">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_trade_l_zero_partial.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "ETHUSDT",
    "c": "O-12345-test-l-zero-partial",
    "S": "BUY",
    "o": "LIMIT",
    "f": "GTC",
    "q": "1.00000000",
    "p": "2500.00000000",
    "P": "0.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "TRADE",
    "X": "PARTIALLY_FILLED",
    "r": "NONE",
    "i": 1234567890,
    "l": "0.00000000",
    "z": "0.50000000",
    "L": "0.00000000",
    "n": "0",
    "N": null,
    "T": 1759347763167,
    "t": 12345678,
    "I": 4644480641,
    "w": true,
    "m": false,
    "M": false,
    "O": 1759347763167,
    "Z": "0.00000000",
    "Y": "0.00000000",
    "Q": "0.00000000",
    "W": 1759347763167,
    "V": "NONE"
  }
}
</document_content>
</document>
<document index="2582">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_execution_report_trade_prevention.json</source>
<document_content>
{
  "stream": "executionReport",
  "data": {
    "e": "executionReport",
    "E": 1759347763167,
    "s": "ETHUSDT",
    "c": "O-12345-test-stp",
    "S": "BUY",
    "o": "LIMIT",
    "f": "GTC",
    "q": "1.00000000",
    "p": "2500.00000000",
    "P": "0.00000000",
    "F": "0.00000000",
    "g": -1,
    "C": "",
    "x": "TRADE_PREVENTION",
    "X": "EXPIRED_IN_MATCH",
    "r": "SELF_TRADE_PREVENTION",
    "i": 1234567890,
    "l": "0.50000000",
    "z": "0.00000000",
    "L": "2500.00000000",
    "n": "0",
    "N": null,
    "T": 1759347763167,
    "t": -1,
    "I": 4644480641,
    "w": false,
    "m": false,
    "M": false,
    "O": 1759347763100,
    "Z": "0.00000000",
    "Y": "0.00000000",
    "Q": "0.00000000",
    "V": "EXPIRE_MAKER"
  }
}
</document_content>
</document>
<document index="2583">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_ticker_24hr.json</source>
<document_content>
{
  "e": "24hrTicker",
  "E": 123456789,
  "s": "BNBBTC",
  "p": "0.0015",
  "P": "250.00",
  "w": "0.0018",
  "x": "0.0009",
  "c": "0.0025",
  "Q": "10",
  "b": "0.0024",
  "B": "10",
  "a": "0.0026",
  "A": "100",
  "o": "0.0010",
  "h": "0.0025",
  "l": "0.0010",
  "v": "10000",
  "q": "18",
  "O": 0,
  "C": 86400000,
  "F": 0,
  "L": 18150,
  "n": 18151
}
</document_content>
</document>
<document index="2584">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_ticker_book.json</source>
<document_content>
{
  "stream":"ethusdt@bookTicker",
  "data":{
    "u":12711621188,
    "s":"ETHUSDT",
    "b":"4507.24000000",
    "B":"2.35950000",
    "a":"4507.25000000",
    "A":"2.84570000",
    "T":1646199228121,
    "E":1646199228123
  }
}
</document_content>
</document>
<document index="2585">
<source>tests/integration_tests/adapters/binance/resources/ws_messages/ws_spot_trade.json</source>
<document_content>
{
  "stream":"ethusdt@trade",
  "data":{
    "e":"trade",
    "E":1639351062244,
    "s":"ETHUSDT",
    "t":705291099,
    "p":"4149.74000000",
    "q":"0.43870000",
    "b":7038593583,
    "a":7038593613,
    "T":1639351062243,
    "m":true,
    "M":true
  }
}
</document_content>
</document>
<document index="2586">
<source>tests/integration_tests/adapters/binance/sandbox/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="2587">
<source>tests/integration_tests/adapters/binance/sandbox/sandbox_http_futures_account.py</source>
<document_content>

import pytest
@pytest.mark.asyncio()
async def test_binance_futures_account_http_client():
    clock = LiveClock()
    client = get_cached_binance_http_client(
        clock=clock,
        account_type=BinanceAccountType.USDT_FUTURES,
    )
    http_account = BinanceFuturesAccountHttpAPI(
        clock=clock,
        client=client,
        account_type=BinanceAccountType.USDT_FUTURES,
    )
    ############################################################################
    # ACCOUNT STATUS
    ############################################################################
    response = await http_account.account(recv_window=5000)
    print(response)
    ############################################################################
    # NEW ORDER (MARKET)
    ############################################################################
    # response = await http_account.new_order(
    #     symbol="ETHUSDT",
    #     side="BUY",
    #     type="MARKET",
    #     quantity="0.01",
    #     # stop_price="4200",
    #     # new_client_order_id="O-20211120-021300-001-001-1",
    #     # recv_window=5000,
    # )
    # print(json.dumps(response, indent=4))
    ############################################################################
    # NEW ORDER (LIMIT)
    ############################################################################
    # response = await http_account.new_order(
    #     symbol="ETHUSDT",
    #     side="BUY",
    #     type="LIMIT",
    #     quantity="0.01",
    #     time_in_force="GTC",
    #     price="1000",
    #     # stop_price="4200",
    #     # new_client_order_id="O-20211120-021300-001-001-1",
    #     # recv_window=5000,
    # )
    # print(json.dumps(response, indent=4))
    ############################################################################
    # CANCEL ORDER
    ############################################################################
    # response = await http_account.cancel_order(
    #     symbol="ETHUSDT",
    #     orig_client_order_id="fxSU6k85PZlwQEDFODh4Ad",
    #     #new_client_order_id=str(uuid.uuid4()),
    #     #recv_window=5000,
    # )
    # print(json.dumps(response, indent=4))
    ############################################################################
    # CANCEL ALL ORDERS
    ############################################################################
    # response = await http_account.cancel_open_orders(symbol="ETHUSDT")
    # print(json.dumps(response, indent=4))
    ############################################################################
    # OPEN ORDERS
    ############################################################################
    orders = await http_account.get_open_orders()
    print(orders)
    ############################################################################
    # POSITIONS
    ############################################################################
    positions = await http_account.get_position_risk()
    print(positions)
    await client.disconnect()
</document_content>
</document>
<document index="2588">
<source>tests/integration_tests/adapters/binance/sandbox/sandbox_http_futures_testnet_account.py</source>
<document_content>

import os
import pytest
@pytest.mark.asyncio()
async def test_binance_spot_account_http_client():
    clock = LiveClock()
    client = get_cached_binance_http_client(
        clock=clock,
        account_type=BinanceAccountType.USDT_FUTURES,
        api_key=os.getenv("BINANCE_FUTURES_TESTNET_API_KEY"),
        api_secret=os.getenv("BINANCE_FUTURES_TESTNET_API_SECRET"),
        is_testnet=True,
    )
    http_account = BinanceFuturesAccountHttpAPI(
        client=client,
        clock=clock,
        account_type=BinanceAccountType.USDT_FUTURES,
    )
    await http_account.query_futures_hedge_mode()
    # trades = await http_account.get_account_trades(symbol="ETHUSDT")
    ############################################################################
    # NEW ORDER
    ############################################################################
    # await http_account.new_order(
    #     symbol="ETHUSDT",
    #     side=BinanceOrderSide.BUY,
    #     order_type=BinanceOrderType.LIMIT,
    #     quantity="0.01",
    #     time_in_force=BinanceTimeInForce.GTC,
    #     price="1000",
    #     # iceberg_qty="0.005",
    #     # stop_price="3200",
    #     # working_type="CONTRACT_PRICE",
    #     # new_client_order_id="O-20211120-021300-001-001-1",
    #     recv_window="5000",
    # )
    ############################################################################
    # NEW ORDER
    ############################################################################
    # response = await account.new_order_futures(
    #     symbol="ETHUSDT",
    #     side="SELL",
    #     type="TAKE_PROFIT_MARKET",
    #     quantity="0.01",
    #     time_in_force="GTC",
    #     # price="3000",
    #     # iceberg_qty="0.005",
    #     stop_price="3200",
    #     working_type="CONTRACT_PRICE",
    #     # new_client_order_id="O-20211120-021300-001-001-1",
    #     recv_window=5000,
    # )
    ############################################################################
    # CANCEL ORDER
    ############################################################################
    # response = await account.cancel_order(
    #     symbol="ETHUSDT",
    #     orig_client_order_id="9YDq1gEAGjBkZmMbTSX1ww",
    #     # new_client_order_id=str(uuid.uuid4()),
    #     recv_window=5000,
    # )
    # print(trades)
</document_content>
</document>
<document index="2589">
<source>tests/integration_tests/adapters/binance/sandbox/sandbox_http_futures_testnet_instrument_provider.py</source>
<document_content>

import os
import pytest
@pytest.mark.asyncio()
async def test_binance_futures_testnet_instrument_provider():
    clock = LiveClock()
    client = get_cached_binance_http_client(
        clock=clock,
        account_type=BinanceAccountType.USDT_FUTURES,
        api_key=os.getenv("BINANCE_FUTURES_TESTNET_API_KEY"),
        api_secret=os.getenv("BINANCE_FUTURES_TESTNET_API_SECRET"),
        is_testnet=True,
    )
    provider = BinanceFuturesInstrumentProvider(
        client=client,
        clock=clock,
    )
    # await provider.load_all_async()
    btcusdt_perp = InstrumentId(Symbol("BTCUSDT-PERP"), BINANCE_VENUE)
    await provider.load_ids_async(instrument_ids=[btcusdt_perp])
    await provider.load_all_async()
    print(provider.count)
</document_content>
</document>
<document index="2590">
<source>tests/integration_tests/adapters/binance/sandbox/sandbox_http_futures_testnet_market.py</source>
<document_content>

import os
import pytest
@pytest.mark.asyncio()
async def test_binance_futures_testnet_market_http_client():
    clock = LiveClock()
    account_type = BinanceAccountType.USDT_FUTURES
    client = get_cached_binance_http_client(
        clock=clock,
        account_type=account_type,
        api_key=os.getenv("BINANCE_FUTURES_TESTNET_API_KEY"),
        api_secret=os.getenv("BINANCE_FUTURES_TESTNET_API_SECRET"),
        is_testnet=True,
    )
    provider = BinanceFuturesInstrumentProvider(
        client=client,
        clock=clock,
        account_type=BinanceAccountType.USDT_FUTURES,
    )
    await provider.load_all_async()
    print(provider.count)
</document_content>
</document>
<document index="2591">
<source>tests/integration_tests/adapters/binance/sandbox/sandbox_http_futures_testnet_wallet.py</source>
<document_content>

import json
import os
import pytest
@pytest.mark.asyncio()
async def test_binance_futures_testnet_wallet_http_client():
    clock = LiveClock()
    client = get_cached_binance_http_client(
        clock=clock,
        account_type=BinanceAccountType.USDT_FUTURES,
        api_key=os.getenv("BINANCE_FUTURES_TESTNET_API_KEY"),
        api_secret=os.getenv("BINANCE_FUTURES_TESTNET_API_SECRET"),
        is_testnet=True,
    )
    wallet = BinanceFuturesWalletHttpAPI(clock=clock, client=client)
    response = await wallet.commission_rate(symbol="BTCUSDT")
    print(json.dumps(response, indent=4))
</document_content>
</document>
<document index="2592">
<source>tests/integration_tests/adapters/binance/sandbox/sandbox_http_spot_account.py</source>
<document_content>

import os
import pytest
@pytest.mark.asyncio()
async def test_binance_spot_account_http_client():
    clock = LiveClock()
    client = get_cached_binance_http_client(
        clock=clock,
        account_type=BinanceAccountType.SPOT,
        api_key=os.getenv("BINANCE_API_KEY"),
        api_secret=os.getenv("BINANCE_API_SECRET"),
    )
    http_account = BinanceSpotAccountHttpAPI(client=client)
    ############################################################################
    # ACCOUNT STATUS
    ############################################################################
    response = await http_account.account(recv_window=5000)
    print(response)
    # print(json.dumps(response, indent=4))
    ############################################################################
    # NEW ORDER
    ############################################################################
    # response = await http_account.new_order(
    #     symbol="ETHUSDT",
    #     side="SELL",
    #     type="MARKET",
    #     quantity="0.005",
    #     # time_in_force="GTC",
    #     # price="4300",
    #     # iceberg_qty="0.005",
    #     # stop_price="4200",
    #     # new_client_order_id="Z01",
    #     recv_window=5000,
    # )
    # print(response)
    # response = await http_account.cancel_order(
    #     symbol="ETHUSDT",
    #     orig_client_order_id="TLgKPsHY1f0rMqBDIOa24Y",
    #     #new_client_order_id=str(uuid.uuid4()),
    #     recv_window=5000,
    # )
    # print(response)
</document_content>
</document>
<document index="2593">
<source>tests/integration_tests/adapters/binance/sandbox/sandbox_http_spot_instrument_provider.py</source>
<document_content>

import os
import pytest
@pytest.mark.asyncio()
async def test_binance_spot_instrument_provider():
    clock = LiveClock()
    client = get_cached_binance_http_client(
        clock=clock,
        account_type=BinanceAccountType.SPOT,
        api_key=os.getenv("BINANCE_API_KEY"),
        api_secret=os.getenv("BINANCE_API_SECRET"),
        is_testnet=True,  # <-- add this argument to use the testnet
    )
    provider = BinanceSpotInstrumentProvider(
        client=client,
        clock=clock,
    )
    await provider.load_all_async()
    print(provider.count)
</document_content>
</document>
<document index="2594">
<source>tests/integration_tests/adapters/binance/sandbox/sandbox_http_spot_user.py</source>
<document_content>

import json
import os
import pytest
@pytest.mark.asyncio()
async def test_binance_spot_account_http_client():
    clock = LiveClock()
    client = get_cached_binance_http_client(
        clock=clock,
        account_type=BinanceAccountType.SPOT,
        api_key=os.getenv("BINANCE_API_KEY"),
        api_secret=os.getenv("BINANCE_API_SECRET"),
    )
    user = BinanceSpotUserDataHttpAPI(client=client)
    response = await user.create_listen_key()
    print(json.dumps(response, indent=4))
</document_content>
</document>
<document index="2595">
<source>tests/integration_tests/adapters/binance/sandbox/sandbox_http_wallet.py</source>
<document_content>

import json
import os
import pytest
@pytest.mark.asyncio()
async def test_binance_spot_wallet_http_client():
    clock = LiveClock()
    client = get_cached_binance_http_client(
        clock=clock,
        account_type=BinanceAccountType.SPOT,
        api_key=os.getenv("BINANCE_API_KEY"),
        api_secret=os.getenv("BINANCE_API_SECRET"),
    )
    wallet = BinanceSpotWalletHttpAPI(clock=clock, client=client)
    response = await wallet.trade_fee_spot(symbol="BTCUSDT")
    print(json.dumps(response, indent=4))
</document_content>
</document>
<document index="2596">
<source>tests/integration_tests/adapters/binance/sandbox/sandbox_ws_futures_market.py</source>
<document_content>

import asyncio
import pytest
@pytest.mark.asyncio()
async def test_binance_websocket_client():
    clock = LiveClock()
    loop = asyncio.get_running_loop()
    client = BinanceWebSocketClient(
        clock=clock,
        handler=print,
        base_url="wss://fstream.binance.com",
        loop=loop,
    )
    await client.connect()
    await client.subscribe_book_ticker("BTCUSDT-PERP")
    await asyncio.sleep(4)
    await client.disconnect()
</document_content>
</document>
<document index="2597">
<source>tests/integration_tests/adapters/binance/sandbox/sandbox_ws_spot_user.py</source>
<document_content>

import asyncio
import os
import pytest
@pytest.mark.asyncio()
async def test_binance_websocket_client():
    clock = LiveClock()
    client = get_cached_binance_http_client(
        clock=clock,
        account_type=BinanceAccountType.SPOT,
        api_key=os.getenv("BINANCE_API_KEY"),
        api_secret=os.getenv("BINANCE_API_SECRET"),
    )
    user = BinanceSpotUserDataHttpAPI(client=client)
    response = await user.create_listen_key()
    key = response["listenKey"]
    loop = asyncio.get_running_loop()
    ws = BinanceWebSocketClient(
        clock=clock,
        handler=print,
        loop=loop,
    )
    ws.subscribe(key=key)
    await ws.connect()
    await asyncio.sleep(4)
    await ws.disconnect()
</document_content>
</document>
<document index="2598">
<source>tests/integration_tests/adapters/binance/test_config_validation.py</source>
<document_content>

import pytest
@pytest.fixture
def default_data_config():
    return BinanceDataClientConfig()
@pytest.fixture
def default_exec_config():
    return BinanceExecClientConfig()
def test_data_client_config_documentation_accuracy(default_data_config):
    config = default_data_config
    # Verify default values are as documented
def test_exec_client_config_documentation_accuracy(default_exec_config):
    config = default_exec_config
    # Verify default values are as documented
def test_data_client_config_with_valid_parameters():
    config = BinanceDataClientConfig(
        api_key="test_api_key",
        api_secret="test_api_secret",
        testnet=True,
        us=True,
        update_instruments_interval_mins=30,
        use_agg_trade_ticks=True,
    )
def test_exec_client_config_with_valid_parameters():
    config = BinanceExecClientConfig(
        api_key="test_api_key",
        api_secret="test_api_secret",
        testnet=True,
        us=True,
        use_gtd=False,
        use_reduce_only=False,
        use_position_ids=False,
        use_trade_lite=True,
        treat_expired_as_canceled=True,
        recv_window_ms=10_000,
        max_retries=5,
    )
def test_config_frozen_behavior(default_data_config):
    config = default_data_config
    # Should not be able to modify frozen config
    with pytest.raises(AttributeError):
        config.api_key = "new_key"
def test_exec_config_optional_parameters_none():
    config = BinanceExecClientConfig(
        max_retries=None,
        retry_delay_initial_ms=None,
        retry_delay_max_ms=None,
        futures_leverages=None,
        futures_margin_types=None,
    )
</document_content>
</document>
<document index="2599">
<source>tests/integration_tests/adapters/binance/test_core_functions.py</source>
<document_content>

import pytest
class TestBinanceCoreFunctions:
    def test_format_symbol(self):
        # Arrange
        symbol = "ethusdt-perp"
        # Act
        result = BinanceSymbol(symbol)
    def test_convert_symbols_list_to_json_array(self):
        # Arrange
        symbols = ["BTCUSDT", "ETHUSDT-PERP", " XRDUSDT"]
        # Act
        result = BinanceSymbols(symbols)
    @pytest.mark.parametrize(
        ("account_type", "expected"),
        [
            [BinanceAccountType.SPOT, True],
            [BinanceAccountType.MARGIN, False],
            [BinanceAccountType.ISOLATED_MARGIN, False],
            [BinanceAccountType.USDT_FUTURES, False],
            [BinanceAccountType.COIN_FUTURES, False],
        ],
    )
    def test_binance_account_type_is_spot(self, account_type, expected):
    @pytest.mark.parametrize(
        ("account_type", "expected"),
        [
            [BinanceAccountType.SPOT, False],
            [BinanceAccountType.MARGIN, True],
            [BinanceAccountType.ISOLATED_MARGIN, True],
            [BinanceAccountType.USDT_FUTURES, False],
            [BinanceAccountType.COIN_FUTURES, False],
        ],
    )
    def test_binance_account_type_is_margin(self, account_type, expected):
    @pytest.mark.parametrize(
        ("account_type", "expected"),
        [
            [BinanceAccountType.SPOT, True],
            [BinanceAccountType.MARGIN, True],
            [BinanceAccountType.ISOLATED_MARGIN, True],
            [BinanceAccountType.USDT_FUTURES, False],
            [BinanceAccountType.COIN_FUTURES, False],
        ],
    )
    def test_binance_account_type_is_spot_or_margin(self, account_type, expected):
    @pytest.mark.parametrize(
        ("account_type", "expected"),
        [
            [BinanceAccountType.SPOT, False],
            [BinanceAccountType.MARGIN, False],
            [BinanceAccountType.ISOLATED_MARGIN, False],
            [BinanceAccountType.USDT_FUTURES, True],
            [BinanceAccountType.COIN_FUTURES, True],
        ],
    )
    def test_binance_account_type_is_futures(self, account_type, expected):
</document_content>
</document>
<document index="2600">
<source>tests/integration_tests/adapters/binance/test_core_types.py</source>
<document_content>

import pickle
from decimal import Decimal
import pytest
def test_binance_ticker_repr():
    # Arrange
    ticker = BinanceTicker(
        instrument_id=TestIdStubs.btcusdt_binance_id(),
        price_change=Decimal("-94.99999800"),
        price_change_percent=Decimal("-95.960"),
        weighted_avg_price=Decimal("0.29628482"),
        prev_close_price=Decimal("0.10002000"),
        last_price=Decimal("4.00000200"),
        last_qty=Decimal("200.00000000"),
        bid_price=Decimal("4.00000000"),
        bid_qty=Decimal("24.00000000"),
        ask_price=Decimal("4.00000200"),
        ask_qty=Decimal("24.00000200"),
        open_price=Decimal("99.00000000"),
        high_price=Decimal("100.00000000"),
        low_price=Decimal("0.10000000"),
        volume=Decimal("8913.30000000"),
        quote_volume=Decimal("15.30000000"),
        open_time_ms=1499783499040,
        close_time_ms=1499869899040,
        first_id=28385,
        last_id=28460,
        count=76,
        ts_event=1650000000000000000,
        ts_init=1650000000000000000,
    )
        repr(ticker)
        == "BinanceTicker(instrument_id=BTCUSDT.BINANCE, price_change=-94.99999800, price_change_percent=-95.960, weighted_avg_price=0.29628482, prev_close_price=0.10002000, last_price=4.00000200, last_qty=200.00000000, bid_price=4.00000000, bid_qty=24.00000000, ask_price=4.00000200, ask_qty=24.00000200, open_price=99.00000000, high_price=100.00000000, low_price=0.10000000, volume=8913.30000000, quote_volume=15.30000000, open_time_ms=1499783499040, close_time_ms=1499869899040, first_id=28385, last_id=28460, count=76, ts_event=1650000000000000000, ts_init=1650000000000000000)"
    )
def test_binance_ticker_pickle():
    # Arrange
    ticker = BinanceTicker(
        instrument_id=TestIdStubs.btcusdt_binance_id(),
        price_change=Decimal("-94.99999800"),
        price_change_percent=Decimal("-95.960"),
        weighted_avg_price=Decimal("0.29628482"),
        prev_close_price=Decimal("0.10002000"),
        last_price=Decimal("4.00000200"),
        last_qty=Decimal("200.00000000"),
        bid_price=Decimal("4.00000000"),
        bid_qty=Decimal("24.00000000"),
        ask_price=Decimal("4.00000200"),
        ask_qty=Decimal("24.00000200"),
        open_price=Decimal("99.00000000"),
        high_price=Decimal("100.00000000"),
        low_price=Decimal("0.10000000"),
        volume=Decimal("8913.30000000"),
        quote_volume=Decimal("15.30000000"),
        open_time_ms=1499783499040,
        close_time_ms=1499869899040,
        first_id=28385,
        last_id=28460,
        count=76,
        ts_event=1650000000000000000,
        ts_init=1650000000000000000,
    )
    # Act
    pickled = pickle.dumps(ticker)
    unpickled = pickle.loads(pickled)  # noqa: S301 (pickle is safe here)
        repr(unpickled)
        == "BinanceTicker(instrument_id=BTCUSDT.BINANCE, price_change=-94.99999800, price_change_percent=-95.960, weighted_avg_price=0.29628482, prev_close_price=0.10002000, last_price=4.00000200, last_qty=200.00000000, bid_price=4.00000000, bid_qty=24.00000000, ask_price=4.00000200, ask_qty=24.00000200, open_price=99.00000000, high_price=100.00000000, low_price=0.10000000, volume=8913.30000000, quote_volume=15.30000000, open_time_ms=1499783499040, close_time_ms=1499869899040, first_id=28385, last_id=28460, count=76, ts_event=1650000000000000000, ts_init=1650000000000000000)"
    )
def test_binance_ticker_to_from_dict():
    # Arrange
    ticker = BinanceTicker(
        instrument_id=TestIdStubs.btcusdt_binance_id(),
        price_change=Decimal("-94.99999800"),
        price_change_percent=Decimal("-95.960"),
        weighted_avg_price=Decimal("0.29628482"),
        prev_close_price=Decimal("0.10002000"),
        last_price=Decimal("4.00000200"),
        last_qty=Decimal("200.00000000"),
        bid_price=Decimal("4.00000000"),
        bid_qty=Decimal("24.00000000"),
        ask_price=Decimal("4.00000200"),
        ask_qty=Decimal("24.00000200"),
        open_price=Decimal("99.00000000"),
        high_price=Decimal("100.00000000"),
        low_price=Decimal("0.10000000"),
        volume=Decimal("8913.30000000"),
        quote_volume=Decimal("15.30000000"),
        open_time_ms=1499783499040,
        close_time_ms=1499869899040,
        first_id=28385,
        last_id=28460,
        count=76,
        ts_event=1650000000000000000,
        ts_init=1650000000000000000,
    )
    # Act
    values = ticker.to_dict(ticker)
        "type": "BinanceTicker",
        "instrument_id": "BTCUSDT.BINANCE",
        "price_change": "-94.99999800",
        "price_change_percent": "-95.960",
        "weighted_avg_price": "0.29628482",
        "prev_close_price": "0.10002000",
        "last_price": "4.00000200",
        "last_qty": "200.00000000",
        "bid_price": "4.00000000",
        "bid_qty": "24.00000000",
        "ask_price": "4.00000200",
        "ask_qty": "24.00000200",
        "open_price": "99.00000000",
        "high_price": "100.00000000",
        "low_price": "0.10000000",
        "volume": "8913.30000000",
        "quote_volume": "15.30000000",
        "open_time_ms": 1499783499040,
        "close_time_ms": 1499869899040,
        "first_id": 28385,
        "last_id": 28460,
        "count": 76,
        "ts_event": 1650000000000000000,
        "ts_init": 1650000000000000000,
    }
def test_binance_bar_repr():
    # Arrange
    bar = BinanceBar(
        bar_type=BarType(
            instrument_id=TestIdStubs.btcusdt_binance_id(),
            bar_spec=TestDataStubs.bar_spec_1min_last(),
        ),
        open=Price.from_str("0.01634790"),
        high=Price.from_str("0.01640000"),
        low=Price.from_str("0.01575800"),
        close=Price.from_str("0.01577100"),
        volume=Quantity.from_str("148976.11427815"),
        quote_volume=Decimal("2434.19055334"),
        count=100,
        taker_buy_base_volume=Decimal("1756.87402397"),
        taker_buy_quote_volume=Decimal("28.46694368"),
        ts_event=1650000000000000000,
        ts_init=1650000000000000000,
    )
        repr(bar)
        == "BinanceBar(bar_type=BTCUSDT.BINANCE-1-MINUTE-LAST-EXTERNAL, open=0.01634790, high=0.01640000, low=0.01575800, close=0.01577100, volume=148976.11427815, quote_volume=2434.19055334, count=100, taker_buy_base_volume=1756.87402397, taker_buy_quote_volume=28.46694368, taker_sell_base_volume=147219.24025418, taker_sell_quote_volume=2405.72360966, ts_event=1650000000000000000, ts_init=1650000000000000000)"
    )
def test_binance_bar_to_from_dict():
    # Arrange
    bar = BinanceBar(
        bar_type=BarType(
            instrument_id=TestIdStubs.btcusdt_binance_id(),
            bar_spec=TestDataStubs.bar_spec_1min_last(),
        ),
        open=Price.from_str("0.01634790"),
        high=Price.from_str("0.01640000"),
        low=Price.from_str("0.01575800"),
        close=Price.from_str("0.01577100"),
        volume=Quantity.from_str("148976.11427815"),
        quote_volume=Decimal("2434.19055334"),
        count=100,
        taker_buy_base_volume=Decimal("1756.87402397"),
        taker_buy_quote_volume=Decimal("28.46694368"),
        ts_event=1650000000000000000,
        ts_init=1650000000000000000,
    )
    # Act
    values = bar.to_dict(bar)
        "type": "BinanceBar",
        "bar_type": "BTCUSDT.BINANCE-1-MINUTE-LAST-EXTERNAL",
        "open": "0.01634790",
        "high": "0.01640000",
        "low": "0.01575800",
        "close": "0.01577100",
        "volume": "148976.11427815",
        "quote_volume": "2434.19055334",
        "count": 100,
        "taker_buy_base_volume": "1756.87402397",
        "taker_buy_quote_volume": "28.46694368",
        "ts_event": 1650000000000000000,
        "ts_init": 1650000000000000000,
    }
def test_binance_bar_pickling():
    # Arrange
    bar = BinanceBar(
        bar_type=BarType(
            instrument_id=TestIdStubs.btcusdt_binance_id(),
            bar_spec=TestDataStubs.bar_spec_1min_last(),
        ),
        open=Price.from_str("0.01634790"),
        high=Price.from_str("0.01640000"),
        low=Price.from_str("0.01575800"),
        close=Price.from_str("0.01577100"),
        volume=Quantity.from_str("148976.11427815"),
        quote_volume=Decimal("2434.19055334"),
        count=100,
        taker_buy_base_volume=Decimal("1756.87402397"),
        taker_buy_quote_volume=Decimal("28.46694368"),
        ts_event=1650000000000000000,
        ts_init=1650000000000000000,
    )
    # Act
    pickled = pickle.dumps(bar)
    unpickled = pickle.loads(pickled)  # noqa: S301 (pickle is safe here)
        repr(bar)
        == "BinanceBar(bar_type=BTCUSDT.BINANCE-1-MINUTE-LAST-EXTERNAL, open=0.01634790, high=0.01640000, low=0.01575800, close=0.01577100, volume=148976.11427815, quote_volume=2434.19055334, count=100, taker_buy_base_volume=1756.87402397, taker_buy_quote_volume=28.46694368, taker_sell_base_volume=147219.24025418, taker_sell_quote_volume=2405.72360966, ts_event=1650000000000000000, ts_init=1650000000000000000)"
    )
def test_binance_mark_price_to_from_dict():
    # Arrange
    update = BinanceFuturesMarkPriceUpdate(
        instrument_id=TestIdStubs.ethusdt_perp_binance_id(),
        mark=Price.from_str("1642.28584467"),
        index=Price.from_str("1642.28316456"),
        estimated_settle=Price.from_str("1639.27811452"),
        funding_rate=Decimal("0.00081453"),
        next_funding_ns=1650000000000000002,
        ts_event=1650000000000000001,
        ts_init=1650000000000000000,
    )
    # Act
    values = update.to_dict(update)
    BinanceFuturesMarkPriceUpdate.from_dict(values)
        "type": "BinanceFuturesMarkPriceUpdate",
        "instrument_id": "ETHUSDT-PERP.BINANCE",
        "mark": "1642.28584467",
        "index": "1642.28316456",
        "estimated_settle": "1639.27811452",
        "funding_rate": "0.00081453",
        "next_funding_ns": 1650000000000000002,
        "ts_event": 1650000000000000001,
        "ts_init": 1650000000000000000,
    }
def test_binance_mark_price_pickling():
    # Arrange
    update = BinanceFuturesMarkPriceUpdate(
        instrument_id=TestIdStubs.ethusdt_perp_binance_id(),
        mark=Price.from_str("1642.28584467"),
        index=Price.from_str("1642.28316456"),
        estimated_settle=Price.from_str("1639.27811452"),
        funding_rate=Decimal("0.00081453"),
        next_funding_ns=1650000000000000002,
        ts_event=1650000000000000001,
        ts_init=1650000000000000000,
    )
    # Act
    pickled = pickle.dumps(update)
    unpickled = pickle.loads(pickled)  # noqa: S301 (pickle is safe here)
        "type": "BinanceFuturesMarkPriceUpdate",
        "instrument_id": "ETHUSDT-PERP.BINANCE",
        "mark": "1642.28584467",
        "index": "1642.28316456",
        "estimated_settle": "1639.27811452",
        "funding_rate": "0.00081453",
        "next_funding_ns": 1650000000000000002,
        "ts_event": 1650000000000000001,
        "ts_init": 1650000000000000000,
    }
@pytest.fixture
def catalog(tmp_path) -> ParquetDataCatalog:
    return setup_catalog(protocol="memory", path=tmp_path / "catalog")
def test_binance_bar_data_catalog_serialization(catalog: ParquetDataCatalog):
    """
    Test that BinanceBar can be serialized to and deserialized from a data catalog.
    Regression test for the BinanceBar serialization issue where Arrow registration was
    incomplete (missing encoder/decoder).
    """
    # Arrange
    bar = BinanceBar(
        bar_type=BarType(
            instrument_id=TestIdStubs.btcusdt_binance_id(),
            bar_spec=TestDataStubs.bar_spec_1min_last(),
        ),
        open=Price.from_str("0.01634790"),
        high=Price.from_str("0.01640000"),
        low=Price.from_str("0.01575800"),
        close=Price.from_str("0.01577100"),
        volume=Quantity.from_str("148976.11427815"),
        quote_volume=Decimal("2434.19055334"),
        count=100,
        taker_buy_base_volume=Decimal("1756.87402397"),
        taker_buy_quote_volume=Decimal("28.46694368"),
        ts_event=1650000000000000000,
        ts_init=1650000000000000000,
    )
    # Act
    catalog.write_data([bar])
    binance_bars = catalog.custom_data(cls=BinanceBar)
    retrieved_bar = binance_bars[0]
    # Verify all standard bar fields
    # Verify Binance-specific fields are preserved
    # Verify object equality
</document_content>
</document>
<document index="2601">
<source>tests/integration_tests/adapters/binance/test_error_handling.py</source>
<document_content>

import pytest
@pytest.fixture
def retry_error():
    """
    Create a BinanceError with a retryable error code.
    """
    return BinanceError(
        status=400,
        message={"code": -1021, "msg": "Timestamp for this request is outside of the recvWindow."},
        headers={},
    )
@pytest.fixture
def non_retry_error():
    """
    Create a BinanceError with a non-retryable error code.
    """
    return BinanceError(
        status=400,
        message={"code": -1000, "msg": "Unknown error"},
        headers={},
    )
def test_should_retry_with_dict_message_containing_code(retry_error):
    result = should_retry(retry_error)
    # -1021 is in BINANCE_RETRY_ERRORS, so should return True
def test_should_retry_with_dict_message_missing_code():
    error = BinanceError(
        status=400,
        message={"msg": "Some error message without code"},
        headers={},
    )
    result = should_retry(error)
    # Should not crash and return False
def test_should_retry_with_string_message_json_parseable():
    error = BinanceError(
        status=400,
        message='{"code": -1021, "msg": "Timestamp error"}',
        headers={},
    )
    result = should_retry(error)
    # Should parse JSON and find code -1021
def test_should_retry_with_string_message_not_json():
    error = BinanceError(
        status=400,
        message="This is just a plain string error message",
        headers={},
    )
    result = should_retry(error)
    # Should not crash and return False
def test_should_retry_with_malformed_json_string():
    error = BinanceError(
        status=400,
        message='{"code": -1021, "msg": "Malformed JSON',  # Missing closing brace
        headers={},
    )
    result = should_retry(error)
    # Should not crash and return False
def test_should_retry_with_none_message():
    error = BinanceError(
        status=400,
        message=None,
        headers={},
    )
    result = should_retry(error)
    # Should not crash and return False
def test_should_retry_with_non_retry_error_code(non_retry_error):
    result = should_retry(non_retry_error)
def test_should_retry_with_non_binance_error():
    error = ValueError("Some other error")
    result = should_retry(error)
def test_should_retry_with_empty_dict_message():
    error = BinanceError(
        status=400,
        message={},
        headers={},
    )
    result = should_retry(error)
def test_should_retry_with_string_code_value():
    error = BinanceError(
        status=400,
        message={"code": "-1021", "msg": "String code value"},
        headers={},
    )
    result = should_retry(error)
    # Should handle string to int conversion
def test_should_retry_with_invalid_code_type():
    error = BinanceError(
        status=400,
        message={"code": "invalid", "msg": "Invalid code type"},
        headers={},
    )
    result = should_retry(error)
    # Should not crash on invalid int conversion
</document_content>
</document>
<document index="2602">
<source>tests/integration_tests/adapters/binance/test_execution_futures.py</source>
<document_content>

from decimal import Decimal
import pytest
ETHUSDT_PERP_BINANCE = TestInstrumentProvider.ethusdt_perp_binance()
class TestBinanceFuturesExecutionClient:
    @pytest.fixture(autouse=True)
    def setup(self, request):
        # Fixture Setup
        self.loop = request.getfixturevalue("event_loop")
        self.loop.set_debug(True)
        self.clock = LiveClock()
        self.trader_id = TestIdStubs.trader_id()
        self.venue = BINANCE_VENUE
        self.account_id = AccountId(f"{self.venue.value}-001")
        self.msgbus = MessageBus(
            trader_id=self.trader_id,
            clock=self.clock,
        )
        self.cache = TestComponentStubs.cache()
        self.http_client = BinanceHttpClient(
            clock=self.clock,
            api_key="SOME_BINANCE_API_KEY",
            api_secret="SOME_BINANCE_API_SECRET",
            base_url="https://api.binance.com/",  # Spot/Margin
        )
        self.provider = BinanceFuturesInstrumentProvider(
            client=self.http_client,
            clock=self.clock,
            config=InstrumentProviderConfig(load_all=True),
        )
        self.portfolio = Portfolio(
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )
        self.data_engine = DataEngine(
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )
        self.exec_engine = ExecutionEngine(
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )
        self.risk_engine = RiskEngine(
            portfolio=self.portfolio,
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )
        self.exec_client = BinanceFuturesExecutionClient(
            loop=self.loop,
            client=self.http_client,
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
            instrument_provider=self.provider,
            base_url_ws="",
            config=BinanceExecClientConfig(),
            account_type=BinanceAccountType.USDT_FUTURES,
        )
        self.strategy = Strategy()
        self.strategy.register(
            trader_id=self.trader_id,
            portfolio=self.portfolio,
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )
        yield
    @pytest.mark.asyncio()
    @pytest.mark.parametrize(
        ("_is_dual_side_position", "position_id", "expected"),
        [
            # One-way mode
            (False, None, "BOTH"),
            (False, TestIdStubs.position_id(), "BOTH"),
            (False, TestIdStubs.position_id_long(), "BOTH"),
            (False, TestIdStubs.position_id_short(), "BOTH"),
            (False, TestIdStubs.position_id_both(), "BOTH"),
            # Hedge mode
            (True, TestIdStubs.position_id_long(), "LONG"),
            (True, TestIdStubs.position_id_short(), "SHORT"),
            # (True, TestIdStubs.position_id_both(), "BOTH"),
        ],
    )
    async def test_submit_market_order(self, mocker, _is_dual_side_position, position_id, expected):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        # For one-way mode: _is_dual_side_position is False
        # For hedge mode: _is_dual_side_position is True
        mocker.patch.object(self.exec_client, "_is_dual_side_position", _is_dual_side_position)
        order = self.strategy.order_factory.market(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(1),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=position_id,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_send_request.call_args)
        request = mock_send_request.call_args
    @pytest.mark.asyncio()
    @pytest.mark.parametrize(
        ("_is_dual_side_position", "position_id", "expected"),
        [
            # One-way mode
            (False, None, "BOTH"),
            (False, TestIdStubs.position_id(), "BOTH"),
            (False, TestIdStubs.position_id_long(), "BOTH"),
            (False, TestIdStubs.position_id_short(), "BOTH"),
            (False, TestIdStubs.position_id_both(), "BOTH"),
            # Hedge mode
            (True, TestIdStubs.position_id_long(), "LONG"),
            (True, TestIdStubs.position_id_short(), "SHORT"),
            # (True, TestIdStubs.position_id_both(), "BOTH"),
        ],
    )
    async def test_submit_limit_order(self, mocker, _is_dual_side_position, position_id, expected):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mocker.patch.object(self.exec_client, "_is_dual_side_position", _is_dual_side_position)
        order = self.strategy.order_factory.limit(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(10),
            price=Price.from_str("10050.80"),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=position_id,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_send_request.call_args)
        request = mock_send_request.call_args
    @pytest.mark.asyncio()
    async def test_submit_limit_order_with_price_match(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mocker.patch.object(self.exec_client, "_is_dual_side_position", True)
        order = self.strategy.order_factory.limit(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(2),
            price=Price.from_str("42000"),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=TestIdStubs.position_id_long(),
            order=order,
            command_id=UUID4(),
            ts_init=0,
            params={"price_match": "queue"},
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_send_request.call_args)
        request = mock_send_request.call_args
        payload = request[1]["payload"]
    @pytest.mark.asyncio()
    async def test_submit_limit_order_with_price_match_post_only_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        order = self.strategy.order_factory.limit(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_int(1),
            price=Price.from_str("35000"),
            post_only=True,
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=TestIdStubs.position_id_short(),
            order=order,
            command_id=UUID4(),
            ts_init=0,
            params={"price_match": "QUEUE"},
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_generate_denied.called)
        reason = mock_generate_denied.call_args.kwargs["reason"]
    @pytest.mark.asyncio()
    async def test_submit_limit_order_with_price_match_display_qty_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        order = self.strategy.order_factory.limit(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(3),
            price=Price.from_str("28000"),
            display_qty=Quantity.from_int(1),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=TestIdStubs.position_id_long(),
            order=order,
            command_id=UUID4(),
            ts_init=0,
            params={"price_match": "QUEUE"},
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_generate_denied.called)
        reason = mock_generate_denied.call_args.kwargs["reason"]
    @pytest.mark.asyncio()
    async def test_submit_market_order_with_quote_quantity_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        order = self.strategy.order_factory.market(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(100),
            quote_quantity=True,
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_generate_denied.called)
        denied_kwargs = mock_generate_denied.call_args.kwargs
    @pytest.mark.asyncio()
    async def test_submit_market_order_with_price_match_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        order = self.strategy.order_factory.market(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_int(1),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=TestIdStubs.position_id_short(),
            order=order,
            command_id=UUID4(),
            ts_init=0,
            params={"price_match": "QUEUE"},
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_generate_denied.called)
        reason = mock_generate_denied.call_args.kwargs["reason"]
    @pytest.mark.asyncio()
    async def test_submit_limit_order_with_invalid_price_match_value_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        order = self.strategy.order_factory.limit(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_int(1),
            price=Price.from_str("33000"),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=TestIdStubs.position_id_short(),
            order=order,
            command_id=UUID4(),
            ts_init=0,
            params={"price_match": "invalid"},
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_generate_denied.called)
        reason = mock_generate_denied.call_args.kwargs["reason"]
    @pytest.mark.asyncio()
    async def test_submit_limit_order_with_non_string_price_match_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        order = self.strategy.order_factory.limit(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(2),
            price=Price.from_str("30000"),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=TestIdStubs.position_id_long(),
            order=order,
            command_id=UUID4(),
            ts_init=0,
            params={"price_match": 123},
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_generate_denied.called)
        reason = mock_generate_denied.call_args.kwargs["reason"]
    @pytest.mark.asyncio()
    @pytest.mark.parametrize(
        ("_is_dual_side_position", "position_id", "expected"),
        [
            # One-way mode
            (False, None, "BOTH"),
            (False, TestIdStubs.position_id(), "BOTH"),
            (False, TestIdStubs.position_id_long(), "BOTH"),
            (False, TestIdStubs.position_id_short(), "BOTH"),
            (False, TestIdStubs.position_id_both(), "BOTH"),
            # Hedge mode
            (True, TestIdStubs.position_id_long(), "LONG"),
            (True, TestIdStubs.position_id_short(), "SHORT"),
            # (True, TestIdStubs.position_id_both(), "BOTH"),
        ],
    )
    async def test_submit_limit_post_only_order(
        self,
        mocker,
        _is_dual_side_position,
        position_id,
        expected,
    ):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mocker.patch.object(self.exec_client, "_is_dual_side_position", _is_dual_side_position)
        order = self.strategy.order_factory.limit(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(10),
            price=Price.from_str("10050.80"),
            post_only=True,
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=position_id,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_send_request.call_args)
        request = mock_send_request.call_args
    @pytest.mark.asyncio()
    @pytest.mark.parametrize(
        ("_is_dual_side_position", "position_id", "expected"),
        [
            # One-way mode
            (False, None, "BOTH"),
            (False, TestIdStubs.position_id(), "BOTH"),
            (False, TestIdStubs.position_id_long(), "BOTH"),
            (False, TestIdStubs.position_id_short(), "BOTH"),
            (False, TestIdStubs.position_id_both(), "BOTH"),
            # Hedge mode
            (True, TestIdStubs.position_id_long(), "LONG"),
            (True, TestIdStubs.position_id_short(), "SHORT"),
            # (True, TestIdStubs.position_id_both(), "BOTH"),
        ],
    )
    async def test_submit_stop_market_order(
        self,
        mocker,
        _is_dual_side_position,
        position_id,
        expected,
    ):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mocker.patch.object(self.exec_client, "_is_dual_side_position", _is_dual_side_position)
        mocker.patch.object(self.exec_client, "_use_reduce_only", not _is_dual_side_position)
        order = self.strategy.order_factory.stop_market(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_int(10),
            trigger_price=Price.from_str("10099.00"),
            reduce_only=True,
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=position_id,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_send_request.call_args)
        request = mock_send_request.call_args
        if _is_dual_side_position:
        else:
    @pytest.mark.asyncio()
    @pytest.mark.parametrize(
        ("_is_dual_side_position", "position_id", "expected"),
        [
            # One-way mode
            (False, None, "BOTH"),
            (False, TestIdStubs.position_id(), "BOTH"),
            (False, TestIdStubs.position_id_long(), "BOTH"),
            (False, TestIdStubs.position_id_short(), "BOTH"),
            (False, TestIdStubs.position_id_both(), "BOTH"),
            # Hedge mode
            (True, TestIdStubs.position_id_long(), "LONG"),
            (True, TestIdStubs.position_id_short(), "SHORT"),
            # (True, TestIdStubs.position_id_both(), "BOTH"),
        ],
    )
    async def test_submit_stop_limit_order(
        self,
        mocker,
        _is_dual_side_position,
        position_id,
        expected,
    ):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mocker.patch.object(self.exec_client, "_is_dual_side_position", _is_dual_side_position)
        order = self.strategy.order_factory.stop_limit(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(10),
            price=Price.from_str("10050.80"),
            trigger_price=Price.from_str("10050.00"),
            trigger_type=TriggerType.MARK_PRICE,
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=position_id,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_send_request.call_args)
        request = mock_send_request.call_args
    @pytest.mark.asyncio()
    @pytest.mark.parametrize(
        ("_is_dual_side_position", "position_id", "expected"),
        [
            # One-way mode
            (False, None, "BOTH"),
            (False, TestIdStubs.position_id(), "BOTH"),
            (False, TestIdStubs.position_id_long(), "BOTH"),
            (False, TestIdStubs.position_id_short(), "BOTH"),
            (False, TestIdStubs.position_id_both(), "BOTH"),
            # Hedge mode
            (True, TestIdStubs.position_id_long(), "LONG"),
            (True, TestIdStubs.position_id_short(), "SHORT"),
            # (True, TestIdStubs.position_id_both(), "BOTH"),
        ],
    )
    async def test_submit_market_if_touched_order(
        self,
        mocker,
        _is_dual_side_position,
        position_id,
        expected,
    ):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mocker.patch.object(self.exec_client, "_is_dual_side_position", _is_dual_side_position)
        order = self.strategy.order_factory.market_if_touched(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_int(10),
            trigger_price=Price.from_str("10099.00"),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=position_id,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_send_request.call_args)
        request = mock_send_request.call_args
    @pytest.mark.asyncio()
    @pytest.mark.parametrize(
        ("_is_dual_side_position", "position_id", "expected"),
        [
            # One-way mode
            (False, None, "BOTH"),
            (False, TestIdStubs.position_id(), "BOTH"),
            (False, TestIdStubs.position_id_long(), "BOTH"),
            (False, TestIdStubs.position_id_short(), "BOTH"),
            (False, TestIdStubs.position_id_both(), "BOTH"),
            # Hedge mode
            (True, TestIdStubs.position_id_long(), "LONG"),
            (True, TestIdStubs.position_id_short(), "SHORT"),
            # (True, TestIdStubs.position_id_both(), "BOTH"),
        ],
    )
    async def test_submit_limit_if_touched_order(
        self,
        mocker,
        _is_dual_side_position,
        position_id,
        expected,
    ):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mocker.patch.object(self.exec_client, "_is_dual_side_position", _is_dual_side_position)
        order = self.strategy.order_factory.limit_if_touched(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_int(10),
            price=Price.from_str("10050.80"),
            trigger_price=Price.from_str("10099.00"),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=position_id,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_send_request.call_args)
        request = mock_send_request.call_args
    @pytest.mark.asyncio()
    @pytest.mark.parametrize(
        ("_is_dual_side_position", "position_id", "expected"),
        [
            # One-way mode
            (False, None, "BOTH"),
            (False, TestIdStubs.position_id(), "BOTH"),
            (False, TestIdStubs.position_id_long(), "BOTH"),
            (False, TestIdStubs.position_id_short(), "BOTH"),
            (False, TestIdStubs.position_id_both(), "BOTH"),
            # Hedge mode
            (True, TestIdStubs.position_id_long(), "LONG"),
            (True, TestIdStubs.position_id_short(), "SHORT"),
            # (True, TestIdStubs.position_id_both(), "BOTH"),
        ],
    )
    async def test_trailing_stop_market_order(
        self,
        mocker,
        _is_dual_side_position,
        position_id,
        expected,
    ):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mocker.patch.object(self.exec_client, "_is_dual_side_position", _is_dual_side_position)
        mocker.patch.object(self.exec_client, "_use_reduce_only", not _is_dual_side_position)
        order = self.strategy.order_factory.trailing_stop_market(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_int(10),
            trailing_offset=Decimal(100),
            trailing_offset_type=TrailingOffsetType.BASIS_POINTS,
            activation_price=Price.from_str("10000.00"),
            trigger_type=TriggerType.MARK_PRICE,
            reduce_only=True,
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=position_id,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_send_request.call_args)
        request = mock_send_request.call_args
        if _is_dual_side_position:
        else:
    @pytest.mark.asyncio()
    async def test_submit_stop_limit_order_with_invalid_trigger_type_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        order = self.strategy.order_factory.stop_limit(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(10),
            price=Price.from_str("10050.80"),
            trigger_price=Price.from_str("10050.00"),
            trigger_type=TriggerType.BID_ASK,
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_generate_denied.called)
        reason = mock_generate_denied.call_args.kwargs["reason"]
    @pytest.mark.asyncio()
    async def test_submit_stop_market_order_with_invalid_trigger_type_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        order = self.strategy.order_factory.stop_market(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_int(5),
            trigger_price=Price.from_str("9950.00"),
            trigger_type=TriggerType.BID_ASK,
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_generate_denied.called)
        reason = mock_generate_denied.call_args.kwargs["reason"]
    @pytest.mark.asyncio()
    async def test_submit_trailing_stop_with_invalid_trigger_type_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        order = self.strategy.order_factory.trailing_stop_market(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_int(10),
            trailing_offset=Decimal(100),
            trailing_offset_type=TrailingOffsetType.BASIS_POINTS,
            activation_price=Price.from_str("10000.00"),
            trigger_type=TriggerType.BID_ASK,
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_generate_denied.called)
        reason = mock_generate_denied.call_args.kwargs["reason"]
    @pytest.mark.asyncio()
    async def test_submit_trailing_stop_with_invalid_offset_type_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        order = self.strategy.order_factory.trailing_stop_market(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_int(10),
            trailing_offset=Decimal(50),
            trailing_offset_type=TrailingOffsetType.PRICE,
            activation_price=Price.from_str("10000.00"),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_generate_denied.called)
        reason = mock_generate_denied.call_args.kwargs["reason"]
    @pytest.mark.asyncio()
    async def test_submit_trailing_stop_with_offset_too_small_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        order = self.strategy.order_factory.trailing_stop_market(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_int(10),
            trailing_offset=Decimal(5),  # 0.05% - too small (min is 0.1%)
            trailing_offset_type=TrailingOffsetType.BASIS_POINTS,
            activation_price=Price.from_str("10000.00"),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_generate_denied.called)
        reason = mock_generate_denied.call_args.kwargs["reason"]
    @pytest.mark.asyncio()
    async def test_submit_trailing_stop_with_offset_too_large_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        order = self.strategy.order_factory.trailing_stop_market(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_int(10),
            trailing_offset=Decimal(60000),  # 600% - too large (max is 5%)
            trailing_offset_type=TrailingOffsetType.BASIS_POINTS,
            activation_price=Price.from_str("10000.00"),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_generate_denied.called)
        reason = mock_generate_denied.call_args.kwargs["reason"]
    @pytest.mark.asyncio()
    async def test_submit_trailing_stop_with_trigger_price_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        order = self.strategy.order_factory.trailing_stop_market(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_int(10),
            trailing_offset=Decimal(100),
            trailing_offset_type=TrailingOffsetType.BASIS_POINTS,
            trigger_price=Price.from_str("10000.00"),  # Should use activation_price instead
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_generate_denied.called)
        reason = mock_generate_denied.call_args.kwargs["reason"]
    @pytest.mark.asyncio()
    async def test_submit_trailing_stop_without_activation_price_omits_param(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mocker.patch.object(self.exec_client, "_is_dual_side_position", False)
        order = self.strategy.order_factory.trailing_stop_market(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_int(10),
            trailing_offset=Decimal(100),
            trailing_offset_type=TrailingOffsetType.BASIS_POINTS,
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_send_request.call_args)
        request = mock_send_request.call_args
        payload = request[1]["payload"]
        # Critical: activationPrice should NOT be in the payload when None
        # This allows Binance to use server-side current market price
    @pytest.mark.asyncio()
    async def test_submit_oco_order_list_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        # Create a bracket order which has linked_order_ids (simulates OCO-like structure)
        bracket = self.strategy.order_factory.bracket(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(10),
            sl_trigger_price=Price.from_str("9500.00"),
            tp_price=Price.from_str("10500.00"),
        )
        for order in bracket.orders:
            self.cache.add_order(order, None)
        submit_order_list = SubmitOrderList(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            order_list=bracket,
            position_id=None,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order_list(submit_order_list)
        await eventually(lambda: mock_generate_denied.called)
        # All orders in bracket should be denied (entry + stop loss + take profit = 3 orders)
        denied_client_order_ids = {
            call.kwargs["client_order_id"] for call in mock_generate_denied.call_args_list
        }
        for call in mock_generate_denied.call_args_list:
    @pytest.mark.asyncio()
    async def test_submit_unsupported_order_type_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        # Create an order with unsupported type (MARKET_TO_LIMIT not supported on Binance)
        order = self.strategy.order_factory.market_to_limit(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(10),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_generate_denied.called)
        reason = mock_generate_denied.call_args.kwargs["reason"]
    @pytest.mark.asyncio()
    async def test_submit_unsupported_time_in_force_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        # Create an order with unsupported TIF (DAY not supported on Binance Futures)
        order = self.strategy.order_factory.limit(
            instrument_id=ETHUSDT_PERP_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(10),
            price=Price.from_str("10050.80"),
            time_in_force=TimeInForce.DAY,
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_generate_denied.called)
        reason = mock_generate_denied.call_args.kwargs["reason"]
    @pytest.mark.asyncio()
    async def test_leverage_initialization_from_symbol_config(self, mocker):
        """
        Test that leverage is initialized from symbolConfig endpoint.
        This ensures leverage is set for all symbols, including those without active
        positions, fixing the issue where fresh accounts would have default 1x leverage.
        """
        # Arrange
        # Mock account info query
        account_info = BinanceFuturesAccountInfo(
            feeTier=0,
            canTrade=True,
            canDeposit=True,
            canWithdraw=True,
            updateTime=1234567890000,
            assets=[],
        )
        mocker.patch.object(
            self.exec_client._futures_http_account,
            "query_futures_account_info",
            return_value=account_info,
        )
        # Mock generate_account_state
        mocker.patch.object(self.exec_client, "generate_account_state")
        # Mock account retrieval
        mock_account = mocker.Mock()
        mock_account.set_leverage = mocker.Mock()
        mocker.patch.object(self.exec_client, "get_account", return_value=mock_account)
        mocker.patch.object(self.exec_client, "_await_account_registered", return_value=None)
        # Create multiple symbol configs (including symbols without positions)
        symbol_configs = [
            BinanceFuturesSymbolConfig(
                symbol="ETHUSDT",
                marginType="CROSSED",
                isAutoAddMargin=False,
                leverage=20,
                maxNotionalValue="1000000",
            ),
            BinanceFuturesSymbolConfig(
                symbol="BTCUSDT",
                marginType="CROSSED",
                isAutoAddMargin=False,
                leverage=25,
                maxNotionalValue="2000000",
            ),
        ]
        mock_query_symbol_config = mocker.patch.object(
            self.exec_client._futures_http_account,
            "query_futures_symbol_config",
            return_value=symbol_configs,
        )
        # Mock instrument cache to return instrument IDs
        def get_instrument_id(symbol):
            if symbol == "ETHUSDT":
                return ETHUSDT_PERP_BINANCE.id
            raise KeyError(f"Symbol {symbol} not loaded")
        mocker.patch.object(
            self.exec_client,
            "_get_cached_instrument_id",
            side_effect=get_instrument_id,
        )
        # Act
        await self.exec_client._update_account_state()
        # Verify leverage was set for ETHUSDT (loaded instrument)
        call_args = mock_account.set_leverage.call_args
</document_content>
</document>
<document index="2603">
<source>tests/integration_tests/adapters/binance/test_execution_handlers.py</source>
<document_content>

import json
import pkgutil
from unittest.mock import call
import msgspec
ETHUSDT_BINANCE = TestInstrumentProvider.ethusdt_binance()
BTCUSDT_BINANCE = TestInstrumentProvider.btcusdt_binance()
class TestBinanceSpotExecutionHandlers:
    """
    Tests for Binance Spot execution report handler methods with mocked dependencies.
    """
    def test_trade_execution_generates_fill_with_correct_params(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_trade.json",
        )
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Create mocked exec_client
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = StrategyId("S-001")
        exec_client._get_cached_instrument_id.return_value = ETHUSDT_BINANCE.id
        exec_client._instrument_provider.find.return_value = ETHUSDT_BINANCE
        exec_client._enum_parser.parse_binance_order_side.return_value = OrderSide.BUY
        exec_client._enum_parser.parse_binance_order_type.return_value = mocker.MagicMock()
        # Act
        wrapper.data.handle_execution_report(exec_client)
        call_kwargs = exec_client.generate_order_filled.call_args.kwargs
    def test_trade_execution_with_l_zero_filled_generates_fill_with_warning(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_trade_l_zero.json",
        )
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Create mocked exec_client
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = StrategyId("S-001")
        exec_client._get_cached_instrument_id.return_value = ETHUSDT_BINANCE.id
        exec_client._instrument_provider.find.return_value = ETHUSDT_BINANCE
        exec_client._enum_parser.parse_binance_order_side.return_value = OrderSide.BUY
        exec_client._enum_parser.parse_binance_order_type.return_value = mocker.MagicMock()
        # Act
        wrapper.data.handle_execution_report(exec_client)
        warning_calls = [call[0][0] for call in exec_client._log.warning.call_args_list]
        # Verify fill has L=0
        call_kwargs = exec_client.generate_order_filled.call_args.kwargs
    def test_trade_execution_with_l_zero_canceled_generates_order_canceled(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_trade_l_zero_canceled.json",
        )
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Create mocked exec_client
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = StrategyId("S-001")
        exec_client._get_cached_instrument_id.return_value = ETHUSDT_BINANCE.id
        # Act
        wrapper.data.handle_execution_report(exec_client)
    def test_trade_execution_with_l_zero_expired_generates_order_expired(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_trade_l_zero_expired.json",
        )
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Create mocked exec_client
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = StrategyId("S-001")
        exec_client._get_cached_instrument_id.return_value = BTCUSDT_BINANCE.id
        # Act
        wrapper.data.handle_execution_report(exec_client)
    def test_trade_execution_with_l_zero_non_terminal_skips_fill(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_trade_l_zero_new.json",
        )
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Create mocked exec_client
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = StrategyId("S-001")
        exec_client._get_cached_instrument_id.return_value = ETHUSDT_BINANCE.id
        # Act
        wrapper.data.handle_execution_report(exec_client)
    def test_calculated_execution_generates_fill_with_taker_side(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_calculated.json",
        )
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Create mocked exec_client
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = StrategyId("S-001")
        exec_client._get_cached_instrument_id.return_value = BTCUSDT_BINANCE.id
        exec_client._instrument_provider.find.return_value = BTCUSDT_BINANCE
        exec_client._enum_parser.parse_binance_order_side.return_value = OrderSide.SELL
        exec_client._enum_parser.parse_binance_order_type.return_value = mocker.MagicMock()
        # Act
        wrapper.data.handle_execution_report(exec_client)
        call_kwargs = exec_client.generate_order_filled.call_args.kwargs
    def test_trade_prevention_logs_but_no_fill(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_trade_prevention.json",
        )
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Create mocked exec_client
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = StrategyId("S-001")
        exec_client._get_cached_instrument_id.return_value = ETHUSDT_BINANCE.id
        # Act
        wrapper.data.handle_execution_report(exec_client)
    def test_canceled_execution_generates_order_canceled(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_canceled.json",
        )
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Create mocked exec_client
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = StrategyId("S-001")
        exec_client._get_cached_instrument_id.return_value = ETHUSDT_BINANCE.id
        # Act
        wrapper.data.handle_execution_report(exec_client)
        call_kwargs = exec_client.generate_order_canceled.call_args.kwargs
    def test_expired_execution_generates_order_expired(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_expired.json",
        )
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Create mocked exec_client
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = StrategyId("S-001")
        exec_client._get_cached_instrument_id.return_value = BTCUSDT_BINANCE.id
        # Act
        wrapper.data.handle_execution_report(exec_client)
        call_kwargs = exec_client.generate_order_expired.call_args.kwargs
    def test_rejected_execution_generates_order_rejected_with_post_only_flag(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_rejected.json",
        )
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Create mocked exec_client
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = StrategyId("S-001")
        exec_client._get_cached_instrument_id.return_value = ETHUSDT_BINANCE.id
        # Act
        wrapper.data.handle_execution_report(exec_client)
        call_kwargs = exec_client.generate_order_rejected.call_args.kwargs
    def test_new_execution_limit_order_price_match_generates_order_updated(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_new_price_match.json",
        )
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Create mocked order with different price than in message
        mock_order = mocker.MagicMock()
        mock_order.order_type = mocker.MagicMock()
        mock_order.order_type.name = "LIMIT"
        mock_order.price = Price.from_str("2500.00000000")  # Original price
        mock_order.quantity = Quantity.from_str("1.00000000")
        mock_order.has_price = True  # LIMIT orders have prices
        mock_order.has_trigger_price = False  # LIMIT orders don't have trigger prices
        # Create mocked exec_client
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = StrategyId("S-001")
        exec_client._cache.order.return_value = mock_order
        exec_client._get_cached_instrument_id.return_value = ETHUSDT_BINANCE.id
        exec_client._instrument_provider.find.return_value = ETHUSDT_BINANCE
        # Mock order type to be LIMIT
                mock_order.order_type = OrderType.LIMIT
        # Act
        wrapper.data.handle_execution_report(exec_client)
        # Verify OrderUpdated was called with new price
        update_kwargs = exec_client.generate_order_updated.call_args.kwargs
    def test_new_execution_stop_limit_order_price_match_preserves_trigger_price(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_new_stop_limit_price_match.json",
        )
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Create mocked order with different price than in message
        mock_order = mocker.MagicMock()
        mock_order.price = Price.from_str("2410.00000000")  # Original limit price
        mock_order.trigger_price = Price.from_str("2400.00000000")  # Original stop price
        mock_order.quantity = Quantity.from_str("1.00000000")
        mock_order.has_price = True  # STOP_LIMIT orders have prices
        mock_order.has_trigger_price = True  # STOP_LIMIT orders have trigger prices
        # Create mocked exec_client
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = StrategyId("S-001")
        exec_client._cache.order.return_value = mock_order
        exec_client._get_cached_instrument_id.return_value = ETHUSDT_BINANCE.id
        exec_client._instrument_provider.find.return_value = ETHUSDT_BINANCE
        # Mock order type to be STOP_LIMIT
                mock_order.order_type = OrderType.STOP_LIMIT
        # Act
        wrapper.data.handle_execution_report(exec_client)
        # Verify OrderUpdated was called with new price but preserved trigger price
        update_kwargs = exec_client.generate_order_updated.call_args.kwargs
            "2405.75000000",
        )  # New limit price from message
            "2400.00000000",
        )  # Preserved stop price
    def test_new_execution_limit_if_touched_order_price_match_preserves_trigger_price(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_new_limit_if_touched_price_match.json",
        )
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Create mocked order with different price than in message
        mock_order = mocker.MagicMock()
        mock_order.price = Price.from_str("2510.00000000")  # Original limit price
        mock_order.trigger_price = Price.from_str("2500.00000000")  # Original trigger price
        mock_order.quantity = Quantity.from_str("1.00000000")
        mock_order.has_price = True  # LIMIT_IF_TOUCHED orders have prices
        mock_order.has_trigger_price = True  # LIMIT_IF_TOUCHED orders have trigger prices
        # Create mocked exec_client
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = StrategyId("S-001")
        exec_client._cache.order.return_value = mock_order
        exec_client._get_cached_instrument_id.return_value = ETHUSDT_BINANCE.id
        exec_client._instrument_provider.find.return_value = ETHUSDT_BINANCE
        # Mock order type to be LIMIT_IF_TOUCHED
                mock_order.order_type = OrderType.LIMIT_IF_TOUCHED
        # Act
        wrapper.data.handle_execution_report(exec_client)
        # Verify OrderUpdated was called with new price but preserved trigger price
        update_kwargs = exec_client.generate_order_updated.call_args.kwargs
            "2505.25000000",
        )  # New limit price from message
            "2500.00000000",
        )  # Preserved trigger price
class TestBinanceFuturesExecutionHandlers:
    """
    Tests for Binance Futures ORDER_TRADE_UPDATE handler methods with mocked
    dependencies.
    """
    def test_liquidation_order_sends_order_status_then_fill_report(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_futures_order_update_liquidation.json",
        )
        decoder = msgspec.json.Decoder(BinanceFuturesOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        exec_client = mocker.MagicMock()
        exec_client.account_id = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = None
        exec_client._get_cached_instrument_id.return_value = BTCUSDT_BINANCE.id
        exec_client._instrument_provider.find.return_value = BTCUSDT_BINANCE
        exec_client._enum_parser.parse_binance_order_side.return_value = OrderSide.SELL
        exec_client._clock.timestamp_ns.return_value = 1759347763167000000
        exec_client.use_position_ids = False
        # Act
        wrapper.data.o.handle_order_trade_update(exec_client)
        order_report = exec_client._send_order_status_report.call_args[0][0]
        fill_report = exec_client._send_fill_report.call_args[0][0]
        # Verify OrderStatusReport sent before FillReport
        status_call = call._send_order_status_report(order_report)
        fill_call = call._send_fill_report(fill_report)
        status_idx = exec_client.mock_calls.index(status_call)
        fill_idx = exec_client.mock_calls.index(fill_call)
    def test_adl_order_sends_order_status_then_fill_report(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_futures_order_update_adl.json",
        )
        decoder = msgspec.json.Decoder(BinanceFuturesOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        exec_client = mocker.MagicMock()
        exec_client.account_id = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = None
        exec_client._get_cached_instrument_id.return_value = ETHUSDT_BINANCE.id
        exec_client._instrument_provider.find.return_value = ETHUSDT_BINANCE
        exec_client._enum_parser.parse_binance_order_side.return_value = OrderSide.BUY
        exec_client._clock.timestamp_ns.return_value = 1759347763200000000
        exec_client.use_position_ids = False
        # Act
        wrapper.data.o.handle_order_trade_update(exec_client)
        order_report = exec_client._send_order_status_report.call_args[0][0]
        fill_report = exec_client._send_fill_report.call_args[0][0]
        # Verify OrderStatusReport sent before FillReport
        status_call = call._send_order_status_report(order_report)
        fill_call = call._send_fill_report(fill_report)
        status_idx = exec_client.mock_calls.index(status_call)
        fill_idx = exec_client.mock_calls.index(fill_call)
    def test_settlement_order_sends_order_status_then_fill_report(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_futures_order_update_settlement.json",
        )
        decoder = msgspec.json.Decoder(BinanceFuturesOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        exec_client = mocker.MagicMock()
        exec_client.account_id = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = None
        exec_client._get_cached_instrument_id.return_value = BTCUSDT_BINANCE.id
        exec_client._instrument_provider.find.return_value = BTCUSDT_BINANCE
        exec_client._enum_parser.parse_binance_order_side.return_value = OrderSide.BUY
        exec_client._clock.timestamp_ns.return_value = 1759347763300000000
        exec_client.use_position_ids = False
        # Act
        wrapper.data.o.handle_order_trade_update(exec_client)
        order_report = exec_client._send_order_status_report.call_args[0][0]
        fill_report = exec_client._send_fill_report.call_args[0][0]
        # Verify OrderStatusReport sent before FillReport
        status_call = call._send_order_status_report(order_report)
        fill_call = call._send_fill_report(fill_report)
        status_idx = exec_client.mock_calls.index(status_call)
        fill_idx = exec_client.mock_calls.index(fill_call)
    def test_liquidation_order_zero_quantity_skipped(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_futures_order_update_liquidation_zero_qty.json",
        )
        decoder = msgspec.json.Decoder(BinanceFuturesOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = None
        exec_client._get_cached_instrument_id.return_value = BTCUSDT_BINANCE.id
        exec_client._instrument_provider.find.return_value = BTCUSDT_BINANCE
        # Act
        wrapper.data.o.handle_order_trade_update(exec_client)
        warning_calls = [call[0][0] for call in exec_client._log.warning.call_args_list]
    def test_liquidation_fill_commission_calculated_when_not_provided(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_futures_order_update_liquidation.json",
        )
        decoder = msgspec.json.Decoder(BinanceFuturesOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        data = json.loads(raw)
        data["data"]["o"]["N"] = None
        data["data"]["o"]["n"] = None
        wrapper = decoder.decode(json.dumps(data).encode())
        exec_client = mocker.MagicMock()
        exec_client.account_id = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = None
        exec_client._get_cached_instrument_id.return_value = BTCUSDT_BINANCE.id
        exec_client._instrument_provider.find.return_value = BTCUSDT_BINANCE
        exec_client._enum_parser.parse_binance_order_side.return_value = OrderSide.SELL
        exec_client._clock.timestamp_ns.return_value = 1759347763167000000
        exec_client.use_position_ids = False
        # Act
        wrapper.data.o.handle_order_trade_update(exec_client)
        fill_report = exec_client._send_fill_report.call_args[0][0]
        expected_commission = float(
            Quantity.from_str("0.100") * Price.from_str("50000.00") * BTCUSDT_BINANCE.taker_fee,
        )
        # Verify OrderStatusReport sent before FillReport
        order_report = exec_client._send_order_status_report.call_args[0][0]
        status_call = call._send_order_status_report(order_report)
        fill_call = call._send_fill_report(fill_report)
        status_idx = exec_client.mock_calls.index(status_call)
        fill_idx = exec_client.mock_calls.index(fill_call)
    def test_new_execution_limit_order_price_match_generates_order_updated(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_futures_order_update_new_price_match.json",
        )
        decoder = msgspec.json.Decoder(BinanceFuturesOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Create mocked order with different price than in message
        mock_order = mocker.MagicMock()
        mock_order.price = Price.from_str("2500.00")  # Original price
        mock_order.quantity = Quantity.from_str("1.000")
        mock_order.has_price = True  # LIMIT orders have prices
        mock_order.has_trigger_price = False  # LIMIT orders don't have trigger prices
        # Create mocked exec_client
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = StrategyId("S-001")
        exec_client._cache.order.return_value = mock_order
        exec_client._get_cached_instrument_id.return_value = ETHUSDT_BINANCE.id
        exec_client._instrument_provider.find.return_value = ETHUSDT_BINANCE
        # Mock order type to be LIMIT
                mock_order.order_type = OrderType.LIMIT
        # Act
        wrapper.data.o.handle_order_trade_update(exec_client)
        # Verify OrderUpdated was called with new price
        update_kwargs = exec_client.generate_order_updated.call_args.kwargs
    def test_new_execution_stop_limit_order_price_match_preserves_trigger_price(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_futures_order_update_new_stop_limit_price_match.json",
        )
        decoder = msgspec.json.Decoder(BinanceFuturesOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Create mocked order with different price than in message
        mock_order = mocker.MagicMock()
        mock_order.price = Price.from_str("2410.00")  # Original limit price
        mock_order.trigger_price = Price.from_str("2400.00")  # Original stop price
        mock_order.quantity = Quantity.from_str("1.000")
        mock_order.has_price = True  # STOP_LIMIT orders have prices
        mock_order.has_trigger_price = True  # STOP_LIMIT orders have trigger prices
        # Create mocked exec_client
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = StrategyId("S-001")
        exec_client._cache.order.return_value = mock_order
        exec_client._get_cached_instrument_id.return_value = ETHUSDT_BINANCE.id
        exec_client._instrument_provider.find.return_value = ETHUSDT_BINANCE
        # Mock order type to be STOP_LIMIT
                mock_order.order_type = OrderType.STOP_LIMIT
        # Act
        wrapper.data.o.handle_order_trade_update(exec_client)
        # Verify OrderUpdated was called with new price but preserved trigger price
        update_kwargs = exec_client.generate_order_updated.call_args.kwargs
    def test_new_execution_limit_if_touched_order_price_match_preserves_trigger_price(self, mocker):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_futures_order_update_new_limit_if_touched_price_match.json",
        )
        decoder = msgspec.json.Decoder(BinanceFuturesOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Create mocked order with different price than in message
        mock_order = mocker.MagicMock()
        mock_order.price = Price.from_str("2510.00")  # Original limit price
        mock_order.trigger_price = Price.from_str("2500.00")  # Original trigger price
        mock_order.quantity = Quantity.from_str("1.000")
        mock_order.has_price = True  # LIMIT_IF_TOUCHED orders have prices
        mock_order.has_trigger_price = True  # LIMIT_IF_TOUCHED orders have trigger prices
        # Create mocked exec_client
        exec_client = mocker.MagicMock()
        exec_client._cache.strategy_id_for_order.return_value = StrategyId("S-001")
        exec_client._cache.order.return_value = mock_order
        exec_client._get_cached_instrument_id.return_value = ETHUSDT_BINANCE.id
        exec_client._instrument_provider.find.return_value = ETHUSDT_BINANCE
        # Mock order type to be LIMIT_IF_TOUCHED
                mock_order.order_type = OrderType.LIMIT_IF_TOUCHED
        # Act
        wrapper.data.o.handle_order_trade_update(exec_client)
        # Verify OrderUpdated was called with new price but preserved trigger price
        update_kwargs = exec_client.generate_order_updated.call_args.kwargs
            "2500.00",
        )  # Preserved trigger price
</document_content>
</document>
<document index="2604">
<source>tests/integration_tests/adapters/binance/test_execution_spot.py</source>
<document_content>

import asyncio
import pytest
ETHUSDT_BINANCE = TestInstrumentProvider.ethusdt_binance()
class TestBinanceSpotExecutionClient:
    @pytest.fixture(autouse=True)
    def setup(self, request):
        # Fixture Setup
        self.loop = request.getfixturevalue("event_loop")
        self.loop.set_debug(True)
        self.clock = LiveClock()
        self.trader_id = TestIdStubs.trader_id()
        self.venue = BINANCE_VENUE
        self.account_id = AccountId(f"{self.venue.value}-001")
        self.msgbus = MessageBus(
            trader_id=self.trader_id,
            clock=self.clock,
        )
        self.cache = TestComponentStubs.cache()
        self.http_client = BinanceHttpClient(
            clock=self.clock,
            api_key="SOME_BINANCE_API_KEY",
            api_secret="SOME_BINANCE_API_SECRET",
            base_url="https://api.binance.com/",  # Spot/Margin
        )
        self.provider = BinanceSpotInstrumentProvider(
            client=self.http_client,
            clock=self.clock,
            config=InstrumentProviderConfig(load_all=True),
        )
        self.portfolio = Portfolio(
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )
        self.data_engine = DataEngine(
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )
        self.exec_engine = ExecutionEngine(
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )
        self.risk_engine = RiskEngine(
            portfolio=self.portfolio,
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )
        self.exec_client = BinanceSpotExecutionClient(
            loop=self.loop,
            client=self.http_client,
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
            instrument_provider=self.provider,
            base_url_ws="",  # Not required for testing
            config=BinanceExecClientConfig(),
            account_type=BinanceAccountType.SPOT,
        )
        self.exec_engine.register_client(self.exec_client)
        self.strategy = Strategy()
        self.strategy.register(
            trader_id=self.trader_id,
            portfolio=self.portfolio,
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )
        yield
    @pytest.mark.asyncio()
    async def test_submit_unsupported_order_logs_error(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        order = self.strategy.order_factory.market_to_limit(
            instrument_id=ETHUSDT_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(10),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await asyncio.sleep(0.3)
    @pytest.mark.asyncio()
    async def test_submit_market_order(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        order = self.strategy.order_factory.market(
            instrument_id=ETHUSDT_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(1),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_send_request.call_args)
        request = mock_send_request.call_args
    @pytest.mark.asyncio()
    async def test_submit_limit_order(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        order = self.strategy.order_factory.limit(
            instrument_id=ETHUSDT_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(10),
            price=Price.from_str("10050.80"),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_send_request.call_args)
        request = mock_send_request.call_args
    @pytest.mark.asyncio()
    async def test_submit_limit_order_with_price_match_denied(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        mock_generate_denied = mocker.patch.object(self.exec_client, "generate_order_denied")
        order = self.strategy.order_factory.limit(
            instrument_id=ETHUSDT_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(10),
            price=Price.from_str("10050.80"),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
            params={"price_match": "QUEUE"},
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_generate_denied.called)
        reason = mock_generate_denied.call_args.kwargs["reason"]
    @pytest.mark.asyncio()
    async def test_submit_stop_limit_order(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        order = self.strategy.order_factory.stop_limit(
            instrument_id=ETHUSDT_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(10),
            price=Price.from_str("10050.80"),
            trigger_price=Price.from_str("10050.00"),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_send_request.call_args)
        request = mock_send_request.call_args
    @pytest.mark.asyncio()
    async def test_submit_limit_if_touched_order(self, mocker):
        # Arrange
        mock_send_request = mocker.patch(
            target="nautilus_trader.adapters.binance.http.client.BinanceHttpClient.send_request",
        )
        order = self.strategy.order_factory.limit_if_touched(
            instrument_id=ETHUSDT_BINANCE.id,
            order_side=OrderSide.SELL,
            quantity=Quantity.from_int(10),
            price=Price.from_str("10100.00"),
            trigger_price=Price.from_str("10099.00"),
        )
        self.cache.add_order(order, None)
        submit_order = SubmitOrder(
            trader_id=self.trader_id,
            strategy_id=self.strategy.id,
            position_id=None,
            order=order,
            command_id=UUID4(),
            ts_init=0,
        )
        # Act
        self.exec_client.submit_order(submit_order)
        await eventually(lambda: mock_send_request.call_args)
        request = mock_send_request.call_args
    @pytest.mark.asyncio()
    async def test_query_order(self, mocker):
        # Arrange
        mock_query_order = mocker.patch(
            target="nautilus_trader.adapters.binance.spot.execution.BinanceSpotExecutionClient.query_order",
        )
        order = self.strategy.order_factory.limit(
            instrument_id=ETHUSDT_BINANCE.id,
            order_side=OrderSide.BUY,
            quantity=Quantity.from_int(10),
            price=Price.from_str("10050.80"),
        )
        # Act
        self.strategy.query_order(order)
        await eventually(lambda: mock_query_order.called)
</document_content>
</document>
<document index="2605">
<source>tests/integration_tests/adapters/binance/test_factories.py</source>
<document_content>

import pytest
class TestBinanceFactories:
    @pytest.fixture(autouse=True)
    def setup(self, request):
        # Fixture Setup
        self.loop = request.getfixturevalue("event_loop")
        self.clock = LiveClock()
        self.trader_id = TestIdStubs.trader_id()
        self.strategy_id = TestIdStubs.strategy_id()
        self.account_id = TestIdStubs.account_id()
        self.msgbus = MessageBus(
            trader_id=self.trader_id,
            clock=self.clock,
        )
        self.cache_db = MockCacheDatabase()
        self.cache = Cache(
            database=self.cache_db,
        )
        yield
    @pytest.mark.parametrize(
        ("account_type", "is_testnet", "is_us", "expected"),
        [
            [
                BinanceAccountType.SPOT,
                False,
                False,
                "https://api.binance.com",
            ],
            [
                BinanceAccountType.MARGIN,
                False,
                False,
                "https://sapi.binance.com",
            ],
            [
                BinanceAccountType.ISOLATED_MARGIN,
                False,
                False,
                "https://sapi.binance.com",
            ],
            [
                BinanceAccountType.USDT_FUTURES,
                False,
                False,
                "https://fapi.binance.com",
            ],
            [
                BinanceAccountType.COIN_FUTURES,
                False,
                False,
                "https://dapi.binance.com",
            ],
            [
                BinanceAccountType.SPOT,
                False,
                True,
                "https://api.binance.us",
            ],
            [
                BinanceAccountType.MARGIN,
                False,
                True,
                "https://sapi.binance.us",
            ],
            [
                BinanceAccountType.ISOLATED_MARGIN,
                False,
                True,
                "https://sapi.binance.us",
            ],
            [
                BinanceAccountType.USDT_FUTURES,
                False,
                True,
                "https://fapi.binance.us",
            ],
            [
                BinanceAccountType.COIN_FUTURES,
                False,
                True,
                "https://dapi.binance.us",
            ],
            [
                BinanceAccountType.SPOT,
                True,
                False,
                "https://testnet.binance.vision",
            ],
            [
                BinanceAccountType.MARGIN,
                True,
                False,
                "https://testnet.binance.vision",
            ],
            [
                BinanceAccountType.ISOLATED_MARGIN,
                True,
                False,
                "https://testnet.binance.vision",
            ],
            [
                BinanceAccountType.USDT_FUTURES,
                True,
                False,
                "https://testnet.binancefuture.com",
            ],
        ],
    )
    def test_get_http_base_url(self, account_type, is_testnet, is_us, expected):
        # Arrange, Act
        base_url = get_http_base_url(account_type, is_testnet, is_us)
    @pytest.mark.parametrize(
        ("account_type", "is_testnet", "is_us", "expected"),
        [
            [
                BinanceAccountType.SPOT,
                False,
                False,
                "wss://stream.binance.com:9443",
            ],
            [
                BinanceAccountType.MARGIN,
                False,
                False,
                "wss://stream.binance.com:9443",
            ],
            [
                BinanceAccountType.ISOLATED_MARGIN,
                False,
                False,
                "wss://stream.binance.com:9443",
            ],
            [
                BinanceAccountType.USDT_FUTURES,
                False,
                False,
                "wss://fstream.binance.com",
            ],
            [
                BinanceAccountType.COIN_FUTURES,
                False,
                False,
                "wss://dstream.binance.com",
            ],
            [
                BinanceAccountType.SPOT,
                False,
                True,
                "wss://stream.binance.us:9443",
            ],
            [
                BinanceAccountType.MARGIN,
                False,
                True,
                "wss://stream.binance.us:9443",
            ],
            [
                BinanceAccountType.ISOLATED_MARGIN,
                False,
                True,
                "wss://stream.binance.us:9443",
            ],
            [
                BinanceAccountType.USDT_FUTURES,
                False,
                True,
                "wss://fstream.binance.us",
            ],
            [
                BinanceAccountType.COIN_FUTURES,
                False,
                True,
                "wss://dstream.binance.us",
            ],
            [
                BinanceAccountType.SPOT,
                True,
                False,
                "wss://stream.testnet.binance.vision",
            ],
            [
                BinanceAccountType.MARGIN,
                True,
                False,
                "wss://stream.testnet.binance.vision",
            ],
            [
                BinanceAccountType.ISOLATED_MARGIN,
                True,
                False,
                "wss://stream.testnet.binance.vision",
            ],
            [
                BinanceAccountType.USDT_FUTURES,
                True,
                False,
                "wss://stream.binancefuture.com",
            ],
        ],
    )
    def test_get_ws_base_url(self, account_type, is_testnet, is_us, expected):
        # Arrange, Act
        base_url = get_ws_base_url(account_type, is_testnet, is_us)
    def test_create_binance_live_spot_data_client(self, binance_http_client):
        # Arrange, Act
        data_client = BinanceLiveDataClientFactory.create(
            loop=self.loop,
            name="BINANCE",
            config=BinanceDataClientConfig(  # (S106 Possible hardcoded password)
                api_key="SOME_BINANCE_API_KEY",  # Do not remove or will fail in CI
                api_secret="SOME_BINANCE_API_SECRET",  # Do not remove or will fail in CI
                account_type=BinanceAccountType.SPOT,
            ),
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )
    def test_create_binance_live_futures_data_client(self, binance_http_client):
        # Arrange, Act
        data_client = BinanceLiveDataClientFactory.create(
            loop=self.loop,
            name="BINANCE",
            config=BinanceDataClientConfig(  # (S106 Possible hardcoded password)
                api_key="SOME_BINANCE_API_KEY",  # Do not remove or will fail in CI
                api_secret="SOME_BINANCE_API_SECRET",  # Do not remove or will fail in CI
                account_type=BinanceAccountType.USDT_FUTURES,
            ),
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )
    def test_create_binance_spot_exec_client(self, binance_http_client):
        # Arrange, Act
        exec_client = BinanceLiveExecClientFactory.create(
            loop=self.loop,
            name="BINANCE",
            config=BinanceExecClientConfig(  # (S106 Possible hardcoded password)
                api_key="SOME_BINANCE_API_KEY",  # Do not remove or will fail in CI
                api_secret="SOME_BINANCE_API_SECRET",  # Do not remove or will fail in CI
                account_type=BinanceAccountType.SPOT,
            ),
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )
    def test_create_binance_futures_exec_client(self, binance_http_client):
        # Arrange, Act
        exec_client = BinanceLiveExecClientFactory.create(
            loop=self.loop,
            name="BINANCE",
            config=BinanceExecClientConfig(  # (S106 Possible hardcoded password)
                api_key="SOME_BINANCE_API_KEY",
                api_secret="SOME_BINANCE_API_SECRET",
                account_type=BinanceAccountType.USDT_FUTURES,
            ),
            msgbus=self.msgbus,
            cache=self.cache,
            clock=self.clock,
        )
</document_content>
</document>
<document index="2606">
<source>tests/integration_tests/adapters/binance/test_loaders.py</source>
<document_content>

def test_load_binance_deltas() -> None:
    # Arrange
    instrument = TestInstrumentProvider.btcusdt_binance()
    data_path = TEST_DATA_DIR / "binance" / "btcusdt-depth-snap.csv"
    df = BinanceOrderBookDeltaDataLoader.load(data_path)
    wrangler = OrderBookDeltaDataWrangler(instrument)
    # Act
    deltas = wrangler.process(df)
</document_content>
</document>
<document index="2607">
<source>tests/integration_tests/adapters/binance/test_parsing_common.py</source>
<document_content>

import pytest
BTCUSDT_BINANCE = TestInstrumentProvider.ethusdt_binance()
class TestBinanceCommonParsing:
    def setup(self):
        self._spot_enum_parser = BinanceSpotEnumParser()
        self._futures_enum_parser = BinanceFuturesEnumParser()
    @pytest.mark.parametrize(
        ("order_type", "expected"),
        [
            [BinanceOrderType.LIMIT, OrderType.LIMIT],
            [BinanceOrderType.MARKET, OrderType.MARKET],
            [BinanceOrderType.STOP, OrderType.STOP_MARKET],
            [BinanceOrderType.STOP_LOSS, OrderType.STOP_MARKET],
            [BinanceOrderType.STOP_LOSS_LIMIT, OrderType.STOP_LIMIT],
            [BinanceOrderType.TAKE_PROFIT, OrderType.LIMIT],
            [BinanceOrderType.TAKE_PROFIT_LIMIT, OrderType.STOP_LIMIT],
            [BinanceOrderType.LIMIT_MAKER, OrderType.LIMIT],
        ],
    )
    def test_parse_order_type(self, order_type, expected):
        # Arrange, # Act
        result = self._spot_enum_parser.parse_binance_order_type(order_type)
    @pytest.mark.parametrize(
        ("resolution", "expected_type"),
        [
            [
                BinanceKlineInterval("1s"),
                BarType(
                    BTCUSDT_BINANCE.id,
                    BarSpecification(1, BarAggregation.SECOND, PriceType.LAST),
                    AggregationSource.EXTERNAL,
                ),
            ],
            [
                BinanceKlineInterval("1m"),
                BarType(
                    BTCUSDT_BINANCE.id,
                    BarSpecification(1, BarAggregation.MINUTE, PriceType.LAST),
                    AggregationSource.EXTERNAL,
                ),
            ],
            [
                BinanceKlineInterval("3m"),
                BarType(
                    BTCUSDT_BINANCE.id,
                    BarSpecification(3, BarAggregation.MINUTE, PriceType.LAST),
                    AggregationSource.EXTERNAL,
                ),
            ],
            [
                BinanceKlineInterval("5m"),
                BarType(
                    BTCUSDT_BINANCE.id,
                    BarSpecification(5, BarAggregation.MINUTE, PriceType.LAST),
                    AggregationSource.EXTERNAL,
                ),
            ],
            [
                BinanceKlineInterval("15m"),
                BarType(
                    BTCUSDT_BINANCE.id,
                    BarSpecification(15, BarAggregation.MINUTE, PriceType.LAST),
                    AggregationSource.EXTERNAL,
                ),
            ],
            [
                BinanceKlineInterval("30m"),
                BarType(
                    BTCUSDT_BINANCE.id,
                    BarSpecification(30, BarAggregation.MINUTE, PriceType.LAST),
                    AggregationSource.EXTERNAL,
                ),
            ],
            [
                BinanceKlineInterval("1h"),
                BarType(
                    BTCUSDT_BINANCE.id,
                    BarSpecification(1, BarAggregation.HOUR, PriceType.LAST),
                    AggregationSource.EXTERNAL,
                ),
            ],
            [
                BinanceKlineInterval("2h"),
                BarType(
                    BTCUSDT_BINANCE.id,
                    BarSpecification(2, BarAggregation.HOUR, PriceType.LAST),
                    AggregationSource.EXTERNAL,
                ),
            ],
            [
                BinanceKlineInterval("4h"),
                BarType(
                    BTCUSDT_BINANCE.id,
                    BarSpecification(4, BarAggregation.HOUR, PriceType.LAST),
                    AggregationSource.EXTERNAL,
                ),
            ],
            [
                BinanceKlineInterval("6h"),
                BarType(
                    BTCUSDT_BINANCE.id,
                    BarSpecification(6, BarAggregation.HOUR, PriceType.LAST),
                    AggregationSource.EXTERNAL,
                ),
            ],
            [
                BinanceKlineInterval("8h"),
                BarType(
                    BTCUSDT_BINANCE.id,
                    BarSpecification(8, BarAggregation.HOUR, PriceType.LAST),
                    AggregationSource.EXTERNAL,
                ),
            ],
            [
                BinanceKlineInterval("12h"),
                BarType(
                    BTCUSDT_BINANCE.id,
                    BarSpecification(12, BarAggregation.HOUR, PriceType.LAST),
                    AggregationSource.EXTERNAL,
                ),
            ],
            [
                BinanceKlineInterval("1d"),
                BarType(
                    BTCUSDT_BINANCE.id,
                    BarSpecification(1, BarAggregation.DAY, PriceType.LAST),
                    AggregationSource.EXTERNAL,
                ),
            ],
            [
                BinanceKlineInterval("1d"),
                BarType(
                    BTCUSDT_BINANCE.id,
                    BarSpecification(1, BarAggregation.DAY, PriceType.LAST),
                    AggregationSource.EXTERNAL,
                ),
            ],
            [
                BinanceKlineInterval("1w"),
                BarType(
                    BTCUSDT_BINANCE.id,
                    BarSpecification(1, BarAggregation.WEEK, PriceType.LAST),
                    AggregationSource.EXTERNAL,
                ),
            ],
            [
                BinanceKlineInterval("1M"),
                BarType(
                    BTCUSDT_BINANCE.id,
                    BarSpecification(1, BarAggregation.MONTH, PriceType.LAST),
                    AggregationSource.EXTERNAL,
                ),
            ],
        ],
    )
    def test_parse_parse_bar_ws(self, resolution, expected_type):
        # Arrange
        candle = BinanceCandlestick(
            t=1638747660000,
            T=1638747719999,
            s="BTCUSDT",
            i=resolution,
            f=100,
            L=200,
            o="0.0015",
            c="0.0020",
            h="0.0025",
            l="0.0015",
            v="1000",
            n=100,
            x=False,
            q="1.0000",
            V="500",
            Q="0.500",
            B="123456",
        )
        # Act
        bar = candle.parse_to_binance_bar(
            instrument_id=BTCUSDT_BINANCE.id,
            enum_parser=self._spot_enum_parser,
            ts_init=millis_to_nanos(1638747720000),
        )
    @pytest.mark.parametrize(
        ("position_id", "expected"),
        [
            [PositionId("P-20240817-BTCUSDT-LONG"), BinanceFuturesPositionSide.LONG],
            [PositionId("P-20240817-BTCUSDT-SHORT"), BinanceFuturesPositionSide.SHORT],
            [PositionId("P-20240817-BTCUSDT-BOTH"), BinanceFuturesPositionSide.BOTH],
        ],
    )
    def test_parse_position_id_to_binance_futures_position_side(self, position_id, expected):
        # Arrange, Act
        result = self._futures_enum_parser.parse_position_id_to_binance_futures_position_side(
            position_id,
        )
def test_binance_futures_parse_to_balances() -> None:
    # Arrange
    balance_infos = [
        BinanceFuturesBalanceInfo(
            asset="FDUSD",
            walletBalance="0.00000000",
            unrealizedProfit="0.00000000",
            marginBalance="0.00000000",
            maintMargin="0.00000000",
            initialMargin="0.00000000",
            positionInitialMargin="0.00000000",
            openOrderInitialMargin="0.00000000",
            crossWalletBalance="0.00000000",
            crossUnPnl="0.00000000",
            availableBalance="145.00731942",
            maxWithdrawAmount="0.00000000",
            marginAvailable=True,
            updateTime=0,
        ),
        BinanceFuturesBalanceInfo(
            asset="BNB",
            walletBalance="0.00000000",
            unrealizedProfit="0.00000000",
            marginBalance="0.00000000",
            maintMargin="0.00000000",
            initialMargin="0.00000000",
            positionInitialMargin="0.00000000",
            openOrderInitialMargin="0.00000000",
            crossWalletBalance="0.00000000",
            crossUnPnl="0.00000000",
            availableBalance="0.26632926",
            maxWithdrawAmount="0.00000000",
            marginAvailable=True,
            updateTime=0,
        ),
        BinanceFuturesBalanceInfo(
            asset="USDT",
            walletBalance="0.00000000",
            unrealizedProfit="0.00000000",
            marginBalance="0.00000000",
            maintMargin="0.00000000",
            initialMargin="2.19077500",
            positionInitialMargin="0.00000000",
            openOrderInitialMargin="2.19077500",
            crossWalletBalance="0.00000000",
            crossUnPnl="0.00000000",
            availableBalance="144.65930217",
            maxWithdrawAmount="0.00000000",
            marginAvailable=True,
            updateTime=1709962270029,
        ),
        BinanceFuturesBalanceInfo(
            asset="USDC",
            walletBalance="0.00000000",
            unrealizedProfit="0.00000000",
            marginBalance="0.00000000",
            maintMargin="0.00000000",
            initialMargin="0.00000000",
            positionInitialMargin="0.00000000",
            openOrderInitialMargin="0.00000000",
            crossWalletBalance="0.00000000",
            crossUnPnl="0.00000000",
            availableBalance="141.87086959",
            maxWithdrawAmount="0.00000000",
            marginAvailable=True,
            updateTime=0,
        ),
        BinanceFuturesBalanceInfo(
            asset="BUSD",
            walletBalance="0.00000000",
            unrealizedProfit="0.00000000",
            marginBalance="0.00000000",
            maintMargin="0.00000000",
            initialMargin="0.00000000",
            positionInitialMargin="0.00000000",
            openOrderInitialMargin="0.00000000",
            crossWalletBalance="0.00000000",
            crossUnPnl="0.00000000",
            availableBalance="142.12699008",
            maxWithdrawAmount="0.00000000",
            marginAvailable=True,
            updateTime=0,
        ),
        BinanceFuturesBalanceInfo(
            asset="ETH",
            walletBalance="0.03856162",
            unrealizedProfit="0.00000000",
            marginBalance="0.03856162",
            maintMargin="0.00000000",
            initialMargin="0.00000000",
            positionInitialMargin="0.00000000",
            openOrderInitialMargin="0.00000000",
            crossWalletBalance="0.03856162",
            crossUnPnl="0.00000000",
            availableBalance="0.03436859",
            maxWithdrawAmount="0.03436859",
            marginAvailable=True,
            updateTime=1709962270029,
        ),
        BinanceFuturesBalanceInfo(
            asset="BTC",
            walletBalance="0.00000000",
            unrealizedProfit="0.00000000",
            marginBalance="0.00000000",
            maintMargin="0.00000000",
            initialMargin="0.00000000",
            positionInitialMargin="0.00000000",
            openOrderInitialMargin="0.00000000",
            crossWalletBalance="0.00000000",
            crossUnPnl="0.00000000",
            availableBalance="0.00192305",
            maxWithdrawAmount="0.00000000",
            marginAvailable=True,
            updateTime=0,
        ),
    ]
    for info in balance_infos:
        info.parse_to_account_balance()
</document_content>
</document>
<document index="2608">
<source>tests/integration_tests/adapters/binance/test_parsing_http.py</source>
<document_content>

import pkgutil
import msgspec
ETHUSDT = TestInstrumentProvider.ethusdt_binance()
class TestBinanceHttpParsing:
    def test_parse_book_snapshot(self):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.http_responses",
            resource="http_spot_market_depth.json",
        )
        decoder = msgspec.json.Decoder(BinanceDepth)
        # Act
        data = decoder.decode(raw)
        result = data.parse_to_order_book_snapshot(
            instrument_id=ETHUSDT.id,
            ts_init=2,
        )
    def test_parse_futures_symbol_config(self):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.http_responses",
            resource="http_futures_account_symbol_config.json",
        )
        decoder = msgspec.json.Decoder(list[BinanceFuturesSymbolConfig])
        # Act
        data = decoder.decode(raw)
</document_content>
</document>
<document index="2609">
<source>tests/integration_tests/adapters/binance/test_parsing_ws.py</source>
<document_content>

import pkgutil
import msgspec
ETHUSDT = TestInstrumentProvider.ethusdt_binance()
class TestBinanceWebSocketParsing:
    def test_parse_ticker(self):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_ticker_24hr.json",
        )
        # Act
        decoder = msgspec.json.Decoder(BinanceTickerData)
        data = decoder.decode(raw)
        result = data.parse_to_binance_ticker(
            instrument_id=ETHUSDT.id,
            ts_init=9999999999999991,
        )
    def test_parse_trade_lite(self):
        # Arrange
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_futures_trade_lite.json",
        )
        # Act
        decoder = msgspec.json.Decoder(BinanceFuturesTradeLiteMsg)
        data = decoder.decode(raw)
    def test_parse_spot_execution_report_binance_us(self):
        # Arrange: Load Binance US execution report with W and V fields
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_binance_us.json",
        )
        # Act
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
    def test_parse_to_order_status_report_with_filled_status(self):
        # Arrange: Load Binance US execution report with FILLED status
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_binance_us.json",
        )
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Act: Parse to OrderStatusReport
                                                enum_parser = BinanceSpotEnumParser()
        report = wrapper.data.parse_to_order_status_report(
            account_id=AccountId("BINANCE-001"),
            instrument_id=ETHUSDT.id,
            client_order_id=ClientOrderId("test-001"),
            venue_order_id=VenueOrderId("12345"),
            ts_event=millis_to_nanos(wrapper.data.T),
            ts_init=0,
            enum_parser=enum_parser,
        )
        from decimal import Decimal
            def test_parse_to_order_status_report_with_rejected_status(self):
        # Arrange: Load execution report with REJECTED status (e.g., GTX post-only order)
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_rejected.json",
        )
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Act: Parse to OrderStatusReport
                                                enum_parser = BinanceSpotEnumParser()
        report = wrapper.data.parse_to_order_status_report(
            account_id=AccountId("BINANCE-001"),
            instrument_id=ETHUSDT.id,
            client_order_id=ClientOrderId("test-reject"),
            venue_order_id=VenueOrderId("1234567890"),
            ts_event=millis_to_nanos(wrapper.data.T),
            ts_init=0,
            enum_parser=enum_parser,
        )
            def test_parse_to_order_status_report_with_pending_cancel_status(self):
        # Arrange: Load execution report with PENDING_CANCEL status
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_pending_cancel.json",
        )
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        # Act: Parse to OrderStatusReport
                                                enum_parser = BinanceSpotEnumParser()
        report = wrapper.data.parse_to_order_status_report(
            account_id=AccountId("BINANCE-001"),
            instrument_id=ETHUSDT.id,
            client_order_id=ClientOrderId("test-cancel"),
            venue_order_id=VenueOrderId("9876543210"),
            ts_event=millis_to_nanos(wrapper.data.T),
            ts_init=0,
            enum_parser=enum_parser,
        )
            def test_parse_spot_execution_report_trade_with_l_zero(self):
        # Arrange: Load execution report with TRADE execution type but L=0
        # This can occur with self-trade prevention or other edge cases
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_trade_l_zero.json",
        )
        # Act
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        from decimal import Decimal
    def test_parse_spot_execution_report_calculated(self):
        # Arrange: Load execution report with CALCULATED (liquidation) execution type
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_calculated.json",
        )
        # Act
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
        from decimal import Decimal
    def test_parse_spot_execution_report_trade_prevention(self):
        # Arrange: Load execution report with TRADE_PREVENTION execution type
        raw = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.ws_messages",
            resource="ws_spot_execution_report_trade_prevention.json",
        )
        # Act
        decoder = msgspec.json.Decoder(BinanceSpotOrderUpdateWrapper)
        wrapper = decoder.decode(raw)
</document_content>
</document>
<document index="2610">
<source>tests/integration_tests/adapters/binance/test_providers.py</source>
<document_content>

import json
import pkgutil
import pytest
class TestBinanceInstrumentProvider:
    def setup(self):
        # Fixture Setup
        self.clock = LiveClock()
    @pytest.mark.asyncio()
    async def test_load_all_async_for_futures_markets(
        self,
        binance_http_client,
        live_logger,
        monkeypatch,
    ):
        # Arrange: prepare data for monkey patch
        exchange_info_response = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.http_responses",
            resource="http_futures_market_exchange_info.json",
        )
        account_info = BinanceFuturesAccountInfo(
            feeTier=0,
            canTrade=True,
            canDeposit=True,
            canWithdraw=True,
            updateTime=1234567890000,
            assets=[],
        )
        responses = [exchange_info_response]
        # Mock coroutine for patch
        async def mock_send_request(
            self,  # (needed for mock)
            http_method: str,  # (needed for mock)
            url_path: str,  # (needed for mock)
            payload: dict[str, str],  # (needed for mock)
            ratelimiter_keys: list[str] | None = None,  # (needed for mock)
        ) -> bytes:
            return responses.pop()
        async def mock_query_account_info(recv_window: str):
            return account_info
        # Apply mock coroutine to client
        monkeypatch.setattr(
            target=BinanceHttpClient,
            name="send_request",
            value=mock_send_request,
        )
        self.provider = BinanceFuturesInstrumentProvider(
            client=binance_http_client,
            clock=self.clock,
            account_type=BinanceAccountType.USDT_FUTURES,
        )
        monkeypatch.setattr(
            self.provider._http_account,
            "query_futures_account_info",
            mock_query_account_info,
        )
        # Act
        await self.provider.load_all_async()
            self.provider.find(InstrumentId(Symbol("BTCUSDT-PERP"), Venue("BINANCE"))) is not None
        )
            self.provider.find(InstrumentId(Symbol("ETHUSDT-PERP"), Venue("BINANCE"))) is not None
        )
            self.provider.find(InstrumentId(Symbol("BTCUSDT_220325"), Venue("BINANCE"))) is not None
        )
    @pytest.mark.asyncio()
    async def test_futures_instrument_info_dict_is_json_serializable(
        self,
        binance_http_client,
        live_logger,
        monkeypatch,
    ):
        """
        Test that the instrument info dict contains only JSON-serializable primitives.
        This regression test ensures that enums (like BinanceFuturesContractStatus,
        BinanceOrderType, BinanceTimeInForce) are converted to their string values
        in the info dict, preventing JSON serialization errors in PyO3 interop.
        See: https://github.com/nautechsystems/nautilus_trader/issues/3128
        """
        # Arrange
        exchange_info_response = pkgutil.get_data(
            package="tests.integration_tests.adapters.binance.resources.http_responses",
            resource="http_futures_market_exchange_info.json",
        )
        account_info = BinanceFuturesAccountInfo(
            feeTier=0,
            canTrade=True,
            canDeposit=True,
            canWithdraw=True,
            updateTime=1234567890000,
            assets=[],
        )
        responses = [exchange_info_response]
        async def mock_send_request(
            self,
            http_method: str,
            url_path: str,
            payload: dict[str, str],
            ratelimiter_keys: list[str] | None = None,
        ) -> bytes:
            return responses.pop()
        async def mock_query_account_info(recv_window: str):
            return account_info
        monkeypatch.setattr(
            target=BinanceHttpClient,
            name="send_request",
            value=mock_send_request,
        )
        self.provider = BinanceFuturesInstrumentProvider(
            client=binance_http_client,
            clock=self.clock,
            account_type=BinanceAccountType.USDT_FUTURES,
        )
        monkeypatch.setattr(
            self.provider._http_account,
            "query_futures_account_info",
            mock_query_account_info,
        )
        # Act
        await self.provider.load_all_async()
        btc_perp = self.provider.find(InstrumentId(Symbol("BTCUSDT-PERP"), Venue("BINANCE")))
        info_dict = btc_perp.info
        # This should not raise TypeError about enum not being JSON serializable
        json_str = json.dumps(info_dict)
        # Verify enum fields were converted to strings
</document_content>
</document>
<document index="2611">
<source>tests/integration_tests/adapters/binance/test_url_generation.py</source>
<document_content>

import pytest
@pytest.mark.parametrize(
    ("account_type", "is_testnet", "is_us", "expected"),
    [
        # Live URLs
        (BinanceAccountType.SPOT, False, False, "https://api.binance.com"),
        (BinanceAccountType.SPOT, False, True, "https://api.binance.us"),
        (BinanceAccountType.MARGIN, False, False, "https://sapi.binance.com"),
        (BinanceAccountType.MARGIN, False, True, "https://sapi.binance.us"),
        (BinanceAccountType.USDT_FUTURES, False, False, "https://fapi.binance.com"),
        (BinanceAccountType.USDT_FUTURES, False, True, "https://fapi.binance.us"),
        (BinanceAccountType.COIN_FUTURES, False, False, "https://dapi.binance.com"),
        (BinanceAccountType.COIN_FUTURES, False, True, "https://dapi.binance.us"),
        # Testnet URLs (US flag ignored)
        (BinanceAccountType.SPOT, True, False, "https://testnet.binance.vision"),
        (BinanceAccountType.SPOT, True, True, "https://testnet.binance.vision"),
        (BinanceAccountType.MARGIN, True, False, "https://testnet.binance.vision"),
        (BinanceAccountType.USDT_FUTURES, True, False, "https://testnet.binancefuture.com"),
        (BinanceAccountType.COIN_FUTURES, True, False, "https://testnet.binancefuture.com"),
    ],
)
def test_get_http_base_url(account_type, is_testnet, is_us, expected):
    url = get_http_base_url(account_type, is_testnet=is_testnet, is_us=is_us)
@pytest.mark.parametrize(
    ("account_type", "is_testnet", "is_us", "expected"),
    [
        # Live URLs
        (BinanceAccountType.SPOT, False, False, "wss://stream.binance.com:9443"),
        (BinanceAccountType.SPOT, False, True, "wss://stream.binance.us:9443"),
        (BinanceAccountType.MARGIN, False, False, "wss://stream.binance.com:9443"),
        (BinanceAccountType.MARGIN, False, True, "wss://stream.binance.us:9443"),
        (BinanceAccountType.USDT_FUTURES, False, False, "wss://fstream.binance.com"),
        (BinanceAccountType.USDT_FUTURES, False, True, "wss://fstream.binance.us"),
        (BinanceAccountType.COIN_FUTURES, False, False, "wss://dstream.binance.com"),
        (BinanceAccountType.COIN_FUTURES, False, True, "wss://dstream.binance.us"),
        # Testnet URLs (US flag ignored)
        (BinanceAccountType.SPOT, True, False, "wss://stream.testnet.binance.vision"),
        (BinanceAccountType.SPOT, True, True, "wss://stream.testnet.binance.vision"),
        (BinanceAccountType.MARGIN, True, False, "wss://stream.testnet.binance.vision"),
        (BinanceAccountType.USDT_FUTURES, True, False, "wss://stream.binancefuture.com"),
    ],
)
def test_get_ws_base_url(account_type, is_testnet, is_us, expected):
    url = get_ws_base_url(account_type, is_testnet=is_testnet, is_us=is_us)
def test_get_ws_base_url_coin_futures_testnet_raises_error():
    with pytest.raises(ValueError, match="no testnet for COIN-M futures"):
        get_ws_base_url(BinanceAccountType.COIN_FUTURES, is_testnet=True, is_us=False)
</document_content>
</document>
</documents>